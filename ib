#!/bin/bash
# ib (ittybitty) - multi-agent orchestration for Claude Code
# Usage: ib <command> [options]
#
# A minimal tool for spawning and managing multiple Claude Code agents
# using tmux sessions and git worktrees.

set -e

ITTYBITTY_DIR="${ITTYBITTY_DIR:-.ittybitty}"
SESSION_PREFIX="ittybitty-"  # Will be updated to include repo UUID after init_paths()
TMUX_WIDTH=60  # Width for agent tmux panes (used by watch command)

# Initialize paths - will be set to root repo after get_root_repo is defined
AGENTS_DIR=""
ARCHIVE_DIR=""
ROOT_REPO_PATH=""
REPO_ID=""  # Unique ID for this repo instance, prevents tmux collision across repos

# Convert agent ID to tmux session name
# Checks meta.json first (for stored tmux_session), falls back to SESSION_PREFIX + id
# This ensures consistency when SESSION_PREFIX changes between agent creation and lookup
session_name() {
    local id="$1"

    # Try to read tmux_session from meta.json if agent directory exists
    if [[ -n "$AGENTS_DIR" && -f "$AGENTS_DIR/$id/meta.json" ]]; then
        local stored_session
        stored_session=$(grep -o '"tmux_session"[[:space:]]*:[[:space:]]*"[^"]*"' "$AGENTS_DIR/$id/meta.json" 2>/dev/null | sed 's/.*: *"\([^"]*\)".*/\1/')
        if [[ -n "$stored_session" ]]; then
            echo "$stored_session"
            return
        fi
    fi

    # Fallback: construct from current SESSION_PREFIX
    echo "${SESSION_PREFIX}$id"
}

# =============================================================================
# HELPERS
# =============================================================================

# Archive an agent's output before cleanup
# Creates .ittybitty/archive/YYYYMMDD-HHMMSS-<agent-id>/ with output.log, agent.log, meta.json
archive_agent_output() {
    local ID="$1"
    local AGENT_DIR="$AGENTS_DIR/$ID"

    # Capture final output if session is still running
    local SESSION=$(session_name "$ID")
    if tmux has-session -t "$SESSION" 2>/dev/null; then
        tmux capture-pane -t "$SESSION" -p -S - > "$AGENT_DIR/output.log" 2>/dev/null || true
    fi

    # Only archive if there's something to archive
    if [[ -f "$AGENT_DIR/output.log" || -f "$AGENT_DIR/agent.log" || -f "$AGENT_DIR/meta.json" ]]; then
        local timestamp=$(date +%Y%m%d-%H%M%S)
        local archive_folder="$ARCHIVE_DIR/${timestamp}-${ID}"
        mkdir -p "$archive_folder"

        # Archive output.log (tmux output)
        if [[ -f "$AGENT_DIR/output.log" ]]; then
            mv "$AGENT_DIR/output.log" "$archive_folder/output.log"
        fi

        # Archive agent.log (agent's log entries)
        if [[ -f "$AGENT_DIR/agent.log" ]]; then
            cp "$AGENT_DIR/agent.log" "$archive_folder/agent.log"
        fi

        # Archive meta.json (agent config: prompt, model, session_id, etc.)
        if [[ -f "$AGENT_DIR/meta.json" ]]; then
            cp "$AGENT_DIR/meta.json" "$archive_folder/meta.json"
        fi

        # Archive settings.local.json (permissions and hooks configuration)
        # Note: copied to $AGENT_DIR before worktree removal in teardown_agent
        if [[ -f "$AGENT_DIR/settings.local.json" ]]; then
            mv "$AGENT_DIR/settings.local.json" "$archive_folder/settings.local.json"
        fi

        echo "Archived to: $archive_folder/"
    fi
}

# Log a message to an agent's log file and optionally echo to stdout
# Args: $1 = agent ID, $2 = message, $3 = --quiet (optional, suppress stdout)
# This is the central logging function - use it for all agent logging
log_agent() {
    local ID="$1"
    local MESSAGE="$2"
    local QUIET="${3:-}"
    local AGENT_DIR="$AGENTS_DIR/$ID"
    local LOG_FILE="$AGENT_DIR/agent.log"

    # Only log if agent directory exists
    if [[ -d "$AGENT_DIR" ]]; then
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        echo "[$timestamp] $MESSAGE" >> "$LOG_FILE"
    fi

    # Echo to stdout unless --quiet
    if [[ "$QUIET" != "--quiet" ]]; then
        echo "$MESSAGE"
    fi
}

# Log multi-line content with a header/footer to an agent's log file
# Args: $1 = agent ID, $2 = title, $3 = content
log_multi_line() {
    local ID="$1"
    local TITLE="$2"
    local CONTENT="$3"
    local AGENT_DIR="$AGENTS_DIR/$ID"
    local LOG_FILE="$AGENT_DIR/agent.log"

    # Only log if agent directory exists and we have content
    [[ -d "$AGENT_DIR" ]] || return
    [[ -n "$CONTENT" ]] || return

    {
        echo "========== $TITLE =========="
        echo "$CONTENT"
        echo "============================="
    } >> "$LOG_FILE"
}

# Log tmux screen content for debugging state detection
# Args: $1 = agent ID
# Uses LAST_TMUX_CAPTURE if available (set by capture_tmux/get_state), otherwise captures fresh
log_tmux_screen() {
    local ID="$1"

    # Use cached capture if available, otherwise capture fresh
    local tmux_content="$LAST_TMUX_CAPTURE"
    if [[ -z "$tmux_content" ]]; then
        local TMUX_SESSION=$(session_name "$ID")
        capture_tmux "$TMUX_SESSION" 20
        tmux_content="$LAST_TMUX_CAPTURE"
    fi

    log_multi_line "$ID" "tmux" "$tmux_content"
}

# Check if ib is being called by Claude Code (vs user terminal)
# Returns: 0 if Claude is running the command, 1 if user terminal
# Detection: CLAUDECODE=1 env var is set by Claude Code
is_claude_running() {
    [[ "${CLAUDECODE:-}" == "1" ]]
}

# Check if a path is inside an agent worktree
# Args: $1 = path to check (optional, defaults to pwd)
# Returns: 0 if path is in agent worktree, 1 if not
# This is separated out for testability
is_in_agent_worktree() {
    local path="${1:-$(pwd)}"
    [[ "$path" == *"/.ittybitty/agents/"*"/repo"* ]]
}

# Check if running inside an ib-spawned tmux session
# Returns: 0 if in ittybitty-* tmux session, 1 if not
# Only returns true if $TMUX is set (actually inside tmux)
is_in_ib_tmux_session() {
    [[ -n "${TMUX:-}" ]] || return 1
    local session_name
    session_name=$(tmux display-message -p '#{session_name}' 2>/dev/null) || return 1
    [[ "$session_name" == ittybitty-* ]]
}

# Check if ib is being called from within an agent worktree or ib tmux session
# Returns: 0 if running as an agent, 1 if not
# Use this to detect when commands like kill/merge/nuke are called by an agent
# so we can error out instead of blocking on interactive prompts
is_running_as_agent() {
    # Debug mode: set IB_DEBUG_AGENT_DETECTION=1 to see why detection triggered
    local debug="${IB_DEBUG_AGENT_DETECTION:-}"

    # Primary check: worktree path pattern
    if is_in_agent_worktree; then
        [[ -n "$debug" ]] && echo "[DEBUG] is_running_as_agent: TRUE - pwd matches agent worktree: $(pwd)" >&2
        return 0
    fi

    # Secondary check: ib-spawned tmux session name (for cases where agent cd'd elsewhere)
    if is_in_ib_tmux_session; then
        [[ -n "$debug" ]] && echo "[DEBUG] is_running_as_agent: TRUE - in ittybitty tmux session" >&2
        return 0
    fi

    [[ -n "$debug" ]] && echo "[DEBUG] is_running_as_agent: FALSE - pwd: $(pwd), TMUX=${TMUX:-unset}" >&2
    return 1
}

# Check if a command is allowed for the current execution context
# Args: $1 = command name (e.g., "hooks", "test-tool-match")
#       $2 = subcommand (optional, for commands like "hooks install")
# Exits with error if command is not allowed
# Priority: 1) Agent restrictions, 2) User-in-worktree, 3) Claude restrictions, 4) Allow
enforce_command_access() {
    local cmd="$1"
    local subcmd="${2:-}"
    local in_worktree=false
    local in_tmux_session=false
    local is_claude=false

    is_in_agent_worktree && in_worktree=true
    is_in_ib_tmux_session && in_tmux_session=true
    is_claude_running && is_claude=true

    # Case 1: Agent (Claude running in worktree or ib tmux session)
    if [[ "$is_claude" == "true" ]] && { [[ "$in_worktree" == "true" ]] || [[ "$in_tmux_session" == "true" ]]; }; then
        case "$cmd" in
            watch)
                # Allow watch --debug for performance testing from agents
                if [[ "$subcmd" == "--debug" ]]; then
                    return 0
                fi
                echo "Error: '$cmd' is an interactive command not available to agents" >&2
                echo "Use 'ib watch --debug' for performance testing" >&2
                exit 1
                ;;
            hooks)
                case "$subcmd" in
                    install|uninstall)
                        echo "Error: 'ib hooks $subcmd' modifies main repo configuration" >&2
                        echo "Agents cannot install or uninstall hooks" >&2
                        exit 1
                        ;;
                esac
                ;;
        esac
        return 0
    fi

    # Case 2: User terminal inside agent worktree (not Claude, but in worktree)
    if [[ "$in_worktree" == "true" ]]; then
        case "$cmd" in
            watch)
                # Allow watch --debug from agent worktrees for performance testing
                if [[ "$subcmd" == "--debug" ]]; then
                    return 0
                fi
                echo "Error: You are inside an agent worktree" >&2
                echo "Run 'ib watch' from the main repository instead" >&2
                echo "Use 'ib watch --debug' for performance testing from worktrees" >&2
                exit 1
                ;;
        esac
        return 0
    fi

    # Case 3: Primary Claude (not in worktree, but is Claude)
    if [[ "$is_claude" == "true" ]]; then
        case "$cmd" in
            watch)
                echo "Error: '$cmd' requires an interactive terminal" >&2
                echo "Ask the user to run 'ib watch' in a separate terminal window" >&2
                exit 1
                ;;
        esac
        return 0
    fi

    # Case 4: User terminal (not in worktree, not Claude) - allow everything
    return 0
}

# Get children of a manager agent with optional state filtering
# Args: $1 = manager agent ID
#       $2 = filter (optional): all|unfinished|running|waiting|complete|creating (default: all)
# Returns: space-separated list of child IDs matching filter
# Note: "unfinished" includes creating, running, waiting, and complete states
get_children() {
    local manager_id="$1"
    local filter="${2:-all}"
    local children=""

    # Iterate through all agent directories
    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        local child_id=$(basename "$agent_dir")
        local meta_file="$agent_dir/meta.json"

        # Skip if no meta.json
        [[ -f "$meta_file" ]] || continue

        # Check if this agent's manager matches
        local manager=$(read_meta_field "$meta_file" "manager" "")
        if [[ "$manager" == "$manager_id" ]]; then
            # Apply state filter
            if [[ "$filter" == "all" ]]; then
                # Include all children regardless of state
                if [[ -n "$children" ]]; then
                    children="$children $child_id"
                else
                    children="$child_id"
                fi
            else
                # Check state for filtering
                local state=$(get_state "$child_id")

                if [[ "$filter" == "unfinished" ]]; then
                    # Unfinished = creating, running, waiting, or complete
                    if [[ "$state" == "creating" || "$state" == "running" || "$state" == "waiting" || "$state" == "complete" ]]; then
                        if [[ -n "$children" ]]; then
                            children="$children $child_id"
                        else
                            children="$child_id"
                        fi
                    fi
                elif [[ "$state" == "$filter" ]]; then
                    # Exact state match
                    if [[ -n "$children" ]]; then
                        children="$children $child_id"
                    else
                        children="$child_id"
                    fi
                fi
            fi
        fi
    done

    echo "$children"
}

# Get all descendants of a manager agent recursively (children, grandchildren, etc.)
# Args: $1 = manager agent ID
# Returns: space-separated list of all descendant IDs in depth-first order
# Note: Includes the manager itself as the first element
get_descendants_recursive() {
    local manager_id="$1"
    echo "$manager_id"  # Include the manager itself

    # Find all direct children
    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        [[ -f "$agent_dir/meta.json" ]] || continue

        local id="${agent_dir%/}"; id="${id##*/}"
        local manager=$(jq -r '.manager // ""' "$agent_dir/meta.json" 2>/dev/null)
        if [[ "$manager" == "null" ]]; then
            manager=""
        fi

        if [[ "$manager" == "$manager_id" ]]; then
            # Recursively get this child's descendants
            get_descendants_recursive "$id"
        fi
    done
}

# Get unfinished children of a manager agent (children that haven't been merged/killed)
# Args: $1 = manager agent ID
# Returns: space-separated list of unfinished child IDs (empty if none)
# Children in creating, running, waiting, or complete state all need attention before manager can complete
get_unfinished_children() {
    get_children "$1" "unfinished"
}

# Teardown an agent: kill processes, remove worktree, archive, cleanup
# Args: $1 = agent ID
#       $2 = --quiet (optional, suppress stdout for batch mode)
#       $3 = log message (optional, defaults to "Agent killed")
# Returns: 0 if successful, 1 if failed
# Note: Does NOT do confirmation prompts or orphan scanning - callers handle those
teardown_agent() {
    local ID="$1"
    local QUIET="${2:-}"
    local LOG_MSG="${3:-Agent killed}"
    local AGENT_DIR="$AGENTS_DIR/$ID"
    local TMUX_SESSION=$(session_name "$ID")

    # Log the action
    log_agent "$ID" "$LOG_MSG" "$QUIET"

    # Capture tmux output BEFORE killing session (so archive has it)
    if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        tmux capture-pane -t "$TMUX_SESSION" -p -S - > "$AGENT_DIR/output.log" 2>/dev/null || true
    fi

    # Kill Claude process gracefully before killing tmux session
    if kill_agent_process "$ID" 2>/dev/null; then
        log_agent "$ID" "Terminated Claude process" "$QUIET"
    fi

    # Kill tmux session if running
    if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        tmux kill-session -t "$TMUX_SESSION" 2>/dev/null || true
        log_agent "$ID" "Killed tmux session" "$QUIET"
    fi

    # Copy settings.local.json before removing worktree (for archiving)
    if [[ -f "$AGENT_DIR/repo/.claude/settings.local.json" ]]; then
        cp "$AGENT_DIR/repo/.claude/settings.local.json" "$AGENT_DIR/settings.local.json"
    fi

    # Remove git worktree if it exists
    if [[ -d "$AGENT_DIR/repo" ]]; then
        git worktree remove "$AGENT_DIR/repo" --force 2>/dev/null || {
            log_agent "$ID" "Warning: could not remove worktree, removing directory manually" "$QUIET"
            rm -rf "$AGENT_DIR/repo"
        }
        # Also try to delete the branch
        if git branch -D "agent/$ID" 2>/dev/null; then
            log_agent "$ID" "Deleted branch agent/$ID" "$QUIET"
        fi
    fi

    # Archive output after teardown (captures complete log)
    if [[ "$QUIET" == "--quiet" ]]; then
        archive_agent_output "$ID" > /dev/null 2>&1 || true
    else
        archive_agent_output "$ID"
    fi

    # Remove agent directory last
    if [[ -d "$AGENT_DIR" ]]; then
        rm -rf "$AGENT_DIR"
        return 0
    fi

    return 1
}

# Kill the Claude process for an agent using graceful shutdown
# Args: $1 = agent ID
# Returns: 0 if killed successfully, 1 if process not found
kill_agent_process() {
    local ID="$1"
    local AGENT_DIR="$AGENTS_DIR/$ID"
    local TMUX_SESSION=$(session_name "$ID")
    local PID=""

    # Strategy 1: Dynamic lookup from tmux (most reliable)
    if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        local PANE_PID=$(tmux list-panes -t "$TMUX_SESSION" -F '#{pane_pid}' 2>/dev/null | head -1)
        if [[ -n "$PANE_PID" ]]; then
            # Find Claude process under this pane
            PID=$(pgrep -P "$PANE_PID" -f "claude" 2>/dev/null | head -1)
        fi
    fi

    # Strategy 2: Fallback to meta.json PID
    if [[ -z "$PID" && -f "$AGENT_DIR/meta.json" ]]; then
        PID=$(read_meta_field "$AGENT_DIR/meta.json" "claude_pid" "")
        [[ "$PID" == "null" || -z "$PID" ]] && PID=""
    fi

    # No PID found - nothing to kill
    [[ -z "$PID" ]] && return 1

    # Check if process is still running
    ! kill -0 "$PID" 2>/dev/null && return 0  # Already dead, success

    # Graceful shutdown: SIGTERM first
    kill -TERM "$PID" 2>/dev/null || return 1

    # Wait up to 2 seconds for graceful shutdown
    local waited=0
    while kill -0 "$PID" 2>/dev/null && [[ $waited -lt 20 ]]; do
        sleep 0.1
        ((waited++))
    done

    # If still running, force kill with SIGKILL
    if kill -0 "$PID" 2>/dev/null; then
        kill -KILL "$PID" 2>/dev/null || return 1
        sleep 0.1
    fi

    # Return success if process is dead
    ! kill -0 "$PID" 2>/dev/null
}

# Scan for and kill orphaned Claude processes
# An orphaned process is one where:
# 1. The process cwd contains ".ittybitty/agents/"
# 2. The agent directory no longer exists (deleted)
# This prevents false positives from legitimate Claude instances
scan_and_kill_orphans() {
    local killed_count=0

    while IFS= read -r pid; do
        [[ -z "$pid" ]] && continue

        # Get process working directory (macOS: lsof, Linux: /proc)
        local proc_cwd=""
        if [[ "$(uname)" == "Darwin" ]]; then
            proc_cwd=$(lsof -a -d cwd -p "$pid" -Fn 2>/dev/null | grep '^n' | cut -c2-)
        else
            proc_cwd=$(readlink "/proc/$pid/cwd" 2>/dev/null)
        fi

        [[ -z "$proc_cwd" ]] && continue

        # Safety check 1: Must contain ".ittybitty/agents/"
        [[ "$proc_cwd" != *"/.ittybitty/agents/"* ]] && continue

        # Safety check 2: Extract agent dir and verify it doesn't exist
        local agent_path=""
        if [[ "$proc_cwd" =~ (.*/.ittybitty/agents/[^/]+) ]]; then
            agent_path="${BASH_REMATCH[1]}"
        fi

        # Skip if we couldn't extract path or if directory still exists
        [[ -z "$agent_path" || -d "$agent_path" ]] && continue

        # Confirmed orphan - kill it
        echo "  Found orphaned Claude process (PID $pid, deleted dir: $agent_path)"

        if kill -TERM "$pid" 2>/dev/null; then
            local waited=0
            while kill -0 "$pid" 2>/dev/null && [[ $waited -lt 20 ]]; do
                sleep 0.1
                ((waited++))
            done

            # Force kill if still alive
            kill -0 "$pid" 2>/dev/null && kill -KILL "$pid" 2>/dev/null
            sleep 0.1

            if ! kill -0 "$pid" 2>/dev/null; then
                echo "    ✓ Killed orphaned process $pid"
                ((killed_count++))
            else
                echo "    ✗ Failed to kill process $pid"
            fi
        fi
    done < <(pgrep -f "claude" 2>/dev/null)

    [[ $killed_count -gt 0 ]] && echo "Cleaned up $killed_count orphaned Claude process(es)"
    return 0
}

# Load config from .ittybitty.json if it exists
# Sets global variables: CONFIG_MANAGER_ALLOW, CONFIG_MANAGER_DENY, CONFIG_WORKER_ALLOW, CONFIG_WORKER_DENY, CONFIG_CREATE_PRS, CONFIG_MAX_AGENTS, CONFIG_MODEL, CONFIG_FPS, CONFIG_ALLOW_AGENT_QUESTIONS
load_config() {
    CONFIG_MANAGER_ALLOW=""
    CONFIG_MANAGER_DENY=""
    CONFIG_WORKER_ALLOW=""
    CONFIG_WORKER_DENY=""
    CONFIG_CREATE_PRS="false"
    CONFIG_MAX_AGENTS="10"
    CONFIG_MODEL=""
    CONFIG_FPS="10"
    CONFIG_ALLOW_AGENT_QUESTIONS="true"

    local config_file=".ittybitty.json"
    if [[ ! -f "$config_file" ]]; then
        return 0
    fi

    if ! command -v jq &>/dev/null; then
        echo "Warning: jq not available, cannot read $config_file" >&2
        return 0
    fi

    # Read manager permissions
    CONFIG_MANAGER_ALLOW=$(jq -r '.permissions.manager.allow // [] | @json' "$config_file" 2>/dev/null)
    CONFIG_MANAGER_DENY=$(jq -r '.permissions.manager.deny // [] | @json' "$config_file" 2>/dev/null)

    # Read worker permissions
    CONFIG_WORKER_ALLOW=$(jq -r '.permissions.worker.allow // [] | @json' "$config_file" 2>/dev/null)
    CONFIG_WORKER_DENY=$(jq -r '.permissions.worker.deny // [] | @json' "$config_file" 2>/dev/null)

    # Read PR creation setting
    CONFIG_CREATE_PRS=$(jq -r '.createPullRequests // false' "$config_file" 2>/dev/null)

    # Read max agents setting
    CONFIG_MAX_AGENTS=$(jq -r '.maxAgents // 10' "$config_file" 2>/dev/null)

    # Read model setting
    CONFIG_MODEL=$(jq -r '.model // ""' "$config_file" 2>/dev/null)
    if [[ "$CONFIG_MODEL" == "null" ]]; then
        CONFIG_MODEL=""
    fi

    # Read fps setting for watch screen
    CONFIG_FPS=$(jq -r '.fps // 10' "$config_file" 2>/dev/null)

    # Read allowAgentQuestions setting (defaults to true)
    CONFIG_ALLOW_AGENT_QUESTIONS=$(jq -r '.allowAgentQuestions // true' "$config_file" 2>/dev/null)
}

# Fetch Claude usage percentages from Anthropic API
# Uses OAuth token from macOS Keychain
# Sets global variables: _USAGE_SESSION_PCT, _USAGE_WEEKLY_PCT
# Returns 0 on success, 1 on failure
fetch_claude_usage() {
    _USAGE_SESSION_PCT=""
    _USAGE_WEEKLY_PCT=""

    # Get OAuth access token from macOS Keychain
    # The credentials are stored as JSON under "Claude Code-credentials"
    local creds token
    creds=$(security find-generic-password -s "Claude Code-credentials" -w 2>/dev/null)
    if [[ -z "$creds" ]]; then
        return 1
    fi

    # Parse JSON to get the access token
    if ! command -v jq &>/dev/null; then
        return 1
    fi
    token=$(echo "$creds" | jq -r '.claudeAiOauth.accessToken // empty' 2>/dev/null)
    if [[ -z "$token" ]]; then
        return 1
    fi

    # Call usage API
    local response
    response=$(curl -s --max-time 5 \
        -H "Authorization: Bearer $token" \
        -H "anthropic-beta: oauth-2025-04-20" \
        "https://api.anthropic.com/api/oauth/usage" 2>/dev/null)
    if [[ -z "$response" ]]; then
        return 1
    fi

    local session_util weekly_util
    session_util=$(echo "$response" | jq -r '.five_hour.utilization // empty' 2>/dev/null)
    weekly_util=$(echo "$response" | jq -r '.seven_day.utilization // empty' 2>/dev/null)

    # API returns utilization as percentage (0-100), just round to integer
    if [[ -n "$session_util" && "$session_util" != "null" ]]; then
        _USAGE_SESSION_PCT=$(printf '%.0f' "$session_util" 2>/dev/null)
    fi
    if [[ -n "$weekly_util" && "$weekly_util" != "null" ]]; then
        _USAGE_WEEKLY_PCT=$(printf '%.0f' "$weekly_util" 2>/dev/null)
    fi

    return 0
}

# Count active agents (agents with meta.json)
count_agents() {
    local count=0
    if [[ ! -d "$AGENTS_DIR" ]]; then
        echo "0"
        return 0
    fi

    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        [[ -f "$agent_dir/meta.json" ]] || continue
        ((count++))
    done

    echo "$count"
}

# Check if a tool matches an allow pattern
# Args: $1 = tool_name, $2 = tool_input JSON, $3 = pattern
# Returns: 0 if matches, 1 if not
# Pattern formats:
#   - "Edit" = exact tool name match
#   - "Bash(git:*)" = Bash tool where command starts with "git"
tool_matches_pattern() {
    local tool_name="$1"
    local tool_input="$2"
    local pattern="$3"

    # Check for Bash(prefix:*) pattern
    if [[ "$pattern" =~ ^Bash\(([^:]+):\*\)$ ]]; then
        local prefix="${BASH_REMATCH[1]}"
        if [[ "$tool_name" == "Bash" ]]; then
            local command
            command=$(echo "$tool_input" | jq -r '.command // ""')
            # Check if command starts with prefix (with space or end of string)
            if [[ "$command" == "$prefix" || "$command" == "$prefix "* ]]; then
                return 0
            fi
        fi
        return 1
    fi

    # Exact tool name match
    if [[ "$pattern" == "$tool_name" ]]; then
        return 0
    fi

    return 1
}

# Check if a tool is in the allow list
# Args: $1 = tool_name, $2 = tool_input JSON, $3 = settings file path
# Returns: 0 if allowed, 1 if not
tool_in_allow_list() {
    local tool_name="$1"
    local tool_input="$2"
    local settings_file="$3"

    if [[ ! -f "$settings_file" ]]; then
        return 1
    fi

    # Read allow list from settings
    local allow_list
    allow_list=$(jq -r '.permissions.allow // [] | .[]' "$settings_file" 2>/dev/null)

    # Check each pattern
    while IFS= read -r pattern; do
        [[ -z "$pattern" ]] && continue
        if tool_matches_pattern "$tool_name" "$tool_input" "$pattern"; then
            return 0
        fi
    done <<< "$allow_list"

    return 1
}

# Build settings.local.json content for an agent worktree
# Args: $1 = "manager" or "worker"
build_agent_settings() {
    local agent_type="$1"
    local base_settings="{}"

    # Start with existing settings if available
    if [[ -f ".claude/settings.local.json" ]]; then
        base_settings=$(cat ".claude/settings.local.json")
    fi

    # Load config
    load_config

    # Determine which permissions to use
    local allow_json="[]"
    local deny_json="[]"

    if [[ "$agent_type" == "worker" && "$CONFIG_WORKER_ALLOW" != "[]" && "$CONFIG_WORKER_ALLOW" != "" ]]; then
        allow_json="$CONFIG_WORKER_ALLOW"
        deny_json="${CONFIG_WORKER_DENY:-[]}"
    elif [[ "$CONFIG_MANAGER_ALLOW" != "[]" && "$CONFIG_MANAGER_ALLOW" != "" ]]; then
        allow_json="$CONFIG_MANAGER_ALLOW"
        deny_json="${CONFIG_MANAGER_DENY:-[]}"
    fi

    # Always include ib, git, task management, and basic file tool permissions
    # Git commands are safe in worktrees: agents can't switch branches or push
    # TodoWrite helps agents track and communicate progress
    # Basic file tools (Read, Write, Edit, etc.) are allowed by default because
    # the PreToolUse hook enforces path isolation - agents can only access their
    # own worktree, preventing access to main repo or other agents' files
    local ib_perms='["Bash(ib:*)", "Bash(./ib:*)", "Bash(ib parse-state:*)", "Bash(git status:*)", "Bash(git add:*)", "Bash(git commit:*)", "Bash(git diff:*)", "Bash(git show:*)", "Bash(git log:*)", "Bash(git ls-files:*)", "Bash(git grep:*)", "Bash(git rm:*)", "Bash(pwd:*)", "Bash(ls:*)", "Bash(head:*)", "Bash(tail:*)", "Bash(cat:*)", "Bash(grep:*)", "TodoWrite", "Read", "Write", "Edit", "MultiEdit", "Glob", "Grep", "LS", "Task", "TaskOutput", "NotebookEdit", "WebFetch", "WebSearch", "AskUserQuestion"]'

    # Always deny plan mode tools (agents should work directly, not enter planning mode)
    # Plan mode creates complexity and agents often get stuck trying to exit
    local blocked_tools='["EnterPlanMode", "ExitPlanMode"]'

    # Build the PermissionRequest hook command
    # The hook receives JSON via stdin with tool_name, tool_input, etc.
    # Format: "[PermissionRequest] Permission denied: ToolName (key1: val1, key2: val2)"
    local hook_cmd="jq -r '\"[PermissionRequest] Permission denied: \" + .tool_name + if .tool_input then \" (\" + (.tool_input | to_entries | map(.key + \": \" + (.value | tostring)) | join(\", \")) + \")\" else \"\" end' | xargs -I {} ib log --id __AGENT_ID__ --quiet \"{}\" && echo '{\"hookSpecificOutput\":{\"hookEventName\":\"PermissionRequest\",\"decision\":{\"behavior\":\"deny\"}}}'"

    # Merge everything together and add hooks
    echo "$base_settings" | jq --argjson ib "$ib_perms" \
        --argjson blocked "$blocked_tools" \
        --argjson cfg_allow "$allow_json" \
        --argjson cfg_deny "$deny_json" \
        --arg perm_hook "$hook_cmd" '
        .permissions.allow = ((.permissions.allow // []) + $ib + $cfg_allow | unique) |
        .permissions.deny = ((.permissions.deny // []) + $blocked + $cfg_deny | unique) |
        .hooks.Stop = [{
            "matcher": "*",
            "hooks": [{
                "type": "command",
                "command": "ib hook-status __AGENT_ID__"
            }]
        }] |
        .hooks.PermissionRequest = [{
            "matcher": "*",
            "hooks": [{
                "type": "command",
                "command": $perm_hook
            }]
        }] |
        .hooks.PreToolUse = [{
            "matcher": "*",
            "hooks": [{
                "type": "command",
                "command": "ib hook-check-path __AGENT_ID__"
            }]
        }]
    '
}

# Resolve a partial agent ID to a full ID
# Returns the full ID if exactly one match, errors otherwise
resolve_agent_id() {
    local partial="$1"
    local matches=()

    # Check for exact match first (tmux session or directory)
    if tmux has-session -t "$(session_name "$partial")" 2>/dev/null || [[ -d "$AGENTS_DIR/$partial" ]]; then
        echo "$partial"
        return 0
    fi

    # Look for partial matches in agent directories
    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        local id="${agent_dir%/}"; id="${id##*/}"
        if [[ "$id" == *"$partial"* ]]; then
            matches+=("$id")
        fi
    done

    # Also check tmux sessions that might not have directories
    # Filter to only sessions with our repo-specific prefix, then extract agent IDs
    while IFS= read -r session; do
        [[ -z "$session" ]] && continue
        [[ "$session" != "${SESSION_PREFIX}"* ]] && continue
        local agent_id="${session#${SESSION_PREFIX}}"
        if [[ "$agent_id" == *"$partial"* ]] && [[ ! " ${matches[*]} " =~ " $agent_id " ]]; then
            matches+=("$agent_id")
        fi
    done < <(tmux list-sessions -F '#{session_name}' 2>/dev/null || true)

    case ${#matches[@]} in
        0)
            echo "Error: no agent matching '$partial'" >&2
            return 1
            ;;
        1)
            echo "${matches[0]}"
            return 0
            ;;
        *)
            echo "Error: '$partial' matches multiple agents:" >&2
            printf "  %s\n" "${matches[@]}" >&2
            return 1
            ;;
    esac
}

# Check that we're in a git repo at its root directory
require_git_root() {
    # Check if in a git repo
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "Error: must be run from within a git repository" >&2
        exit 1
    fi

    # Check if at repo root
    local git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    local cwd=$(pwd)
    if [[ "$cwd" != "$git_root" ]]; then
        echo "Error: must be run from git repository root" >&2
        echo "  Current directory: $cwd" >&2
        echo "  Repository root:   $git_root" >&2
        exit 1
    fi
}

# Find the root repository path (the original repo, not a worktree)
# If running from within a worktree, returns the main repo root.
# If running from main repo, returns the current location.
get_root_repo() {
    # First check we're in a git repo
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "Error: not in a git repository" >&2
        return 1
    fi

    # Get the common git directory (shared across all worktrees)
    local common_dir=$(git rev-parse --git-common-dir 2>/dev/null)

    if [[ -z "$common_dir" ]]; then
        # Fallback for older git versions
        git rev-parse --show-toplevel
        return 0
    fi

    # If common_dir is relative (like ".git"), we're in the main repo
    if [[ "$common_dir" == ".git" || "$common_dir" == "$(git rev-parse --git-dir)" ]]; then
        git rev-parse --show-toplevel
    else
        # common_dir is absolute path like /path/to/repo/.git
        # Go up one level to get the repo root
        dirname "$common_dir"
    fi
}

# Get or create the unique repo ID for tmux session isolation
# This ensures multiple repos running ib don't interfere with each other's tmux sessions.
# The repo ID is stored in .ittybitty/repo-id and shared by all worktrees of the same repo.
# Args: $1 = root repo path (optional, uses ROOT_REPO_PATH if not provided)
# Returns: 8-character hex ID (e.g., "a1b2c3d4")
get_repo_id() {
    local root_path="${1:-$ROOT_REPO_PATH}"
    local repo_id_file="$root_path/$ITTYBITTY_DIR/repo-id"

    # Return existing ID if file exists
    if [[ -f "$repo_id_file" ]]; then
        cat "$repo_id_file"
        return 0
    fi

    # Generate new ID (8 hex chars = 4 bytes = 32 bits of entropy)
    # Using openssl for consistency with agent ID generation
    local new_id
    new_id=$(openssl rand -hex 4)

    # Create directory if needed and write ID
    mkdir -p "$root_path/$ITTYBITTY_DIR"
    echo "$new_id" > "$repo_id_file"

    echo "$new_id"
}

# Initialize global paths to use root repo
# Called once when script runs (if in a git repo)
# Also sets SESSION_PREFIX to include repo ID for tmux session isolation
init_paths() {
    if git rev-parse --git-dir >/dev/null 2>&1; then
        ROOT_REPO_PATH=$(get_root_repo)
        AGENTS_DIR="$ROOT_REPO_PATH/$ITTYBITTY_DIR/agents"
        ARCHIVE_DIR="$ROOT_REPO_PATH/$ITTYBITTY_DIR/archive"

        # Set repo-specific session prefix to avoid tmux collisions across repos
        # Format: ittybitty-<repo-id>-<agent-id>
        REPO_ID=$(get_repo_id "$ROOT_REPO_PATH")
        SESSION_PREFIX="ittybitty-${REPO_ID}-"
    else
        # Not in a git repo - use relative paths as fallback
        AGENTS_DIR="$ITTYBITTY_DIR/agents"
        ARCHIVE_DIR="$ITTYBITTY_DIR/archive"
        # Without a git repo, we can't reliably scope sessions, so use default prefix
    fi
}

# Check if merging source_branch into target_branch would cause conflicts
# Args: $1 = target branch (e.g., "main"), $2 = source branch (e.g., "agent/task-123")
# Returns: 0 if merge would succeed (no conflicts), 1 if conflicts would occur
# Outputs: If conflicts detected, prints conflicting file paths to stdout
check_merge_conflicts() {
    local target_branch="$1"
    local source_branch="$2"

    # Try git merge-tree --write-tree first (git 2.38+)
    # This is the cleanest method - doesn't touch working directory at all
    local merge_output
    if merge_output=$(git merge-tree --write-tree "$target_branch" "$source_branch" 2>/dev/null); then
        # Exit code 0 means merge would succeed
        return 0
    else
        local exit_code=$?
        # Exit code 1 with output means conflicts detected
        # Exit code could also indicate the command doesn't exist (older git)
        if [[ $exit_code -eq 1 && -n "$merge_output" ]]; then
            # Parse conflicting files from merge-tree output
            # Format includes lines like "CONFLICT (content): Merge conflict in <file>"
            echo "$merge_output" | grep "^CONFLICT" | sed 's/.*Merge conflict in //' | sed 's/.*: //' || true
            return 1
        fi
        # Command failed for other reason (possibly old git version)
        # Fall through to fallback method
    fi

    # Fallback for older git versions (< 2.38): use merge --no-commit --no-ff
    # This is messier but works on older git
    # Save current state
    local original_branch
    original_branch=$(git branch --show-current 2>/dev/null) || original_branch=$(git rev-parse HEAD)

    # Try a test merge
    if git checkout "$target_branch" >/dev/null 2>&1; then
        if git merge --no-commit --no-ff "$source_branch" >/dev/null 2>&1; then
            # Merge succeeded - abort and return success
            git merge --abort >/dev/null 2>&1 || true
            git checkout "$original_branch" >/dev/null 2>&1 || true
            return 0
        else
            # Merge failed - get conflicting files and abort
            git diff --name-only --diff-filter=U 2>/dev/null || true
            git merge --abort >/dev/null 2>&1 || true
            git checkout "$original_branch" >/dev/null 2>&1 || true
            return 1
        fi
    fi

    # Could not checkout target branch - assume no conflicts and let the actual merge handle it
    return 0
}

# Ensure .ittybitty directory structure exists
# Creates .ittybitty/, .ittybitty/agents/, and .ittybitty/archive/ if they don't exist
# Silent when directories already exist, idempotent (safe to call multiple times)
# Must be called after init_paths() sets ROOT_REPO_PATH
ensure_ittybitty_dirs() {
    # Skip if not in a git repo or paths not initialized
    [[ -z "$ROOT_REPO_PATH" ]] && return 0

    # Create directories silently (mkdir -p is idempotent)
    mkdir -p "$ROOT_REPO_PATH/$ITTYBITTY_DIR/agents" 2>/dev/null || true
    mkdir -p "$ROOT_REPO_PATH/$ITTYBITTY_DIR/archive" 2>/dev/null || true
}

# Format age from ISO timestamp
format_age() {
    local created="$1"
    local now="${2:-$(date +%s)}"  # Accept optional now param to avoid repeated date calls
    # Strip timezone suffix (use % not %% to get shortest match from end)
    local timestamp="${created%[-+]*}"
    local then=$(date -j -f "%Y-%m-%dT%H:%M:%S" "$timestamp" +%s 2>/dev/null || echo "$now")
    local diff=$((now - then))

    if [[ $diff -lt 60 ]]; then
        echo "${diff}s"
    elif [[ $diff -lt 3600 ]]; then
        echo "$((diff / 60))m"
    elif [[ $diff -lt 86400 ]]; then
        echo "$((diff / 3600))h"
    else
        echo "$((diff / 86400))d"
    fi
}

# Global variable to store the last tmux capture for debugging
# Set by capture_tmux, used by log_tmux_screen
LAST_TMUX_CAPTURE=""

# Pure bash tail - read last N lines from a file (no subprocess)
# Args: $1 = file path, $2 = number of lines (default 20)
# Result: stored in _TAIL_RESULT global variable
_TAIL_RESULT=""
_tail_file() {
    local file="$1"
    local lines="${2:-20}"

    _TAIL_RESULT=""
    [[ ! -f "$file" ]] && return

    local all_lines=()
    while IFS= read -r line || [[ -n "$line" ]]; do
        all_lines+=("$line")
    done < "$file"

    local count=${#all_lines[@]}
    local start=$((count - lines))
    [[ $start -lt 0 ]] && start=0

    local i
    for ((i=start; i<count; i++)); do
        [[ -n "$_TAIL_RESULT" ]] && _TAIL_RESULT+=$'\n'
        _TAIL_RESULT+="${all_lines[$i]}"
    done
}

# Pure bash fold - wrap text to specified width (no subprocess)
# Args: $1 = text to wrap, $2 = width
# Result: stored in _FOLD_LINES array
_FOLD_LINES=()
_fold_text() {
    local text="$1"
    local width="${2:-80}"

    _FOLD_LINES=()
    [[ -z "$text" ]] && return

    local line
    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ ${#line} -le $width ]]; then
            _FOLD_LINES+=("$line")
        else
            # Wrap long line
            while [[ ${#line} -gt $width ]]; do
                _FOLD_LINES+=("${line:0:$width}")
                line="${line:$width}"
            done
            [[ -n "$line" ]] && _FOLD_LINES+=("$line")
        fi
    done <<< "$text"
}

# Strip ANSI escape codes from a string (pure bash, no subprocess)
# Args: $1 = string with ANSI codes
# Result: stored in _STRIP_ANSI_RESULT
_STRIP_ANSI_RESULT=""
_strip_ansi() {
    local input="$1"
    # Use loop to remove ANSI sequences: ESC [ ... m
    # Keep removing until no more matches
    while [[ "$input" == *$'\e['* ]]; do
        local prefix="${input%%$'\e['*}"
        local rest="${input#*$'\e['}"
        # Skip until we hit a letter (end of escape sequence)
        while [[ -n "$rest" && ! "${rest:0:1}" =~ [a-zA-Z] ]]; do
            rest="${rest:1}"
        done
        rest="${rest:1}"  # Skip the letter
        input="${prefix}${rest}"
    done
    _STRIP_ANSI_RESULT="$input"
}

# Capture tmux pane content and store in LAST_TMUX_CAPTURE
# Args: $1 = tmux session name, $2 = number of lines (default 20)
# Result: stored in LAST_TMUX_CAPTURE global variable (no stdout, no subprocess needed)
# Note: Sets empty string if session doesn't exist
capture_tmux() {
    local session="$1"
    local lines="${2:-20}"

    # Try to read from background cache first (much faster)
    if [[ -n "$TMUX_CACHE_DIR" && "$session" == ${SESSION_PREFIX}* ]]; then
        local agent_id="${session#${SESSION_PREFIX}}"
        local cache_file="$TMUX_CACHE_DIR/$agent_id"
        if [[ -f "$cache_file" ]]; then
            _tail_file "$cache_file" "$lines"
            LAST_TMUX_CAPTURE="$_TAIL_RESULT"
            return
        fi
    fi

    # Fallback: capture directly from tmux
    # Note: || true prevents set -e from exiting when session doesn't exist
    local raw_capture
    raw_capture=$(tmux capture-pane -t "$session" -p -S "-$lines" 2>/dev/null) || true
    # Strip ANSI codes for consistent pattern matching (matches background cache behavior)
    _strip_ansi "$raw_capture"
    LAST_TMUX_CAPTURE="$_STRIP_ANSI_RESULT"
}

# Parse state from tmux output text
# States: running, waiting, complete, unknown
# Input: Text content (passed as first argument or stdin if no argument)
# Output: State string to stdout
#
# Priority order:
# 1. Strong running - definitive execution indicators (esc to interrupt, ⎿ Running, etc.)
#    These mean something is ACTIVELY running right now, overrides everything
# 2. Complete - agent explicitly said "I HAVE COMPLETED THE GOAL" in last 15 lines
# 3. Waiting - agent explicitly said "WAITING" as standalone in last 15 lines
# 4. Unknown - session exists but no clear state indicators
#
# Note: Strong running indicators take priority because they indicate active execution
# that happens AFTER any completion phrase in the output.
parse_state() {
    local input
    if [[ $# -gt 0 ]]; then
        input="$1"
    else
        input=$(cat)
    fi

    # Empty input = unknown (caller handles stopped for tmux sessions)
    if [[ -z "$input" ]]; then
        echo "unknown"
        return
    fi

    # Check for 'creating' state - Claude permission screens before fully started
    # These appear when Claude needs user acceptance before proceeding:
    # - Workspace trust prompt: "Do you trust the files" + "Enter to confirm"
    # - External imports prompt: "Allow external CLAUDE.md file imports" + "Enter to confirm"
    # IMPORTANT: Only detect as creating if Claude logo/[USER TASK] is NOT present
    # (if they're present, Claude has started and permission prompts are just history)
    if [[ "$input" != *"Claude Code v"* ]] && [[ "$input" != *"[USER TASK]"* ]]; then
        if [[ "$input" == *"Enter to confirm"* ]]; then
            if [[ "$input" == *"Do you trust the files"* ]] || \
               [[ "$input" == *"Allow external CLAUDE.md file imports"* ]]; then
                echo "creating"
                return
            fi
        fi
    fi

    # Get last 5 lines for active execution detection (very recent window)
    local very_recent
    very_recent=$(echo "$input" | tail -5)

    # Check for ACTIVE running indicators FIRST in very recent output
    # These indicate something is definitely executing RIGHT NOW:
    # - "(esc to interrupt)" / "(ctrl+c to interrupt)" - shown during tool execution (in parens)
    # - "⎿  Running" - explicit running status indicator
    # - Thinking spinners (✽ ✶ ✢ · ✻) at start of line - shown during model thinking
    # Active indicators in the last 5 lines override completion because the
    # agent may have resumed work after saying they completed
    # Note: We require parentheses around interrupt phrases to distinguish from discussion text
    if [[ "$very_recent" =~ \(esc\ to\ interrupt\)|\(ctrl\+c\ to\ interrupt\)|⎿\ \ Running ]]; then
        echo "running"
        return
    fi

    # Get last 15 lines for completion/waiting detection (broader window)
    local last_lines
    last_lines=$(echo "$input" | tail -15)

    # Check for completion signal
    # The agent saying "I HAVE COMPLETED THE GOAL" is the definitive completion signal
    if [[ "$last_lines" == *'I HAVE COMPLETED THE GOAL'* ]]; then
        echo "complete"
        return
    fi

    # Check for explicit waiting message
    # Look for WAITING as a standalone word (not in instruction text)
    # Matches: "WAITING" on its own line, or "⏺ ...WAITING" patterns
    if [[ "$last_lines" =~ (^|$'\n')[[:space:]]*WAITING[[:space:]]*($|$'\n') ]] || \
       [[ "$last_lines" =~ ⏺.*WAITING ]]; then
        echo "waiting"
        return
    fi

    # No completion/waiting - check for other running indicators in recent window
    # These may appear in discussions about Claude but are less definitive:
    # - "ctrl+b ctrl+b" - tmux passthrough indicator
    # - "thinking)" - model thinking indicator
    # - Thinking spinners (✽ ✶ ✢ · ✻) at start of line - shown during model thinking
    # Only checked in last 15 lines to avoid matching historical text
    if [[ "$last_lines" =~ ctrl\+b\ ctrl\+b|thinking\) ]]; then
        echo "running"
        return
    fi

    # Check for thinking spinners at start of line (model is actively thinking)
    # These Unicode spinner characters appear at line start when Claude is processing
    # Exclude "Brewed for" and "Worked for" lines - these are completion time indicators, not active spinners
    if [[ "$last_lines" =~ (^|$'\n')[✽✶✢·✻✳][[:space:]] ]]; then
        # Check if any spinner line contains completion time indicator
        if ! [[ "$last_lines" =~ [✽✶✢·✻✳][[:space:]]+(Brewed|Worked)[[:space:]]+for ]]; then
            echo "running"
            return
        fi
    fi

    # Check for tool invocation patterns (weaker running signal)
    # ⏺ followed by a tool name and opening paren indicates tool use
    # This is weaker than the strong indicators because tool output can remain
    # visible after completion, but if there's no completion/waiting phrase,
    # it suggests the agent might still be processing
    if [[ "$last_lines" =~ ⏺[[:space:]]*(Bash|Read|Write|Edit|Grep|Glob|Task|WebFetch|WebSearch|TodoWrite|NotebookEdit|LSP|AskUserQuestion)\( ]]; then
        echo "running"
        return
    fi

    # Check for permission prompts in recent output - these block agent progress
    # Workspace trust prompt: "Do you trust the files in this folder?"
    # External imports prompt: "Allow external CLAUDE.md file imports?"
    # Both show "Enter to confirm" and require user interaction
    # Only check last 15 lines to avoid false positives from prompts in scroll history
    if [[ "$last_lines" == *"Enter to confirm"* ]]; then
        if [[ "$last_lines" == *"Do you trust the files"* ]] || \
           [[ "$last_lines" == *"Allow external CLAUDE.md file imports"* ]]; then
            echo "creating"
            return
        fi
    fi

    # No explicit state indicators found
    echo "unknown"
}

# Detect agent state from tmux
# States: creating, running, waiting, stopped, complete, unknown
# Also sets LAST_TMUX_CAPTURE for debugging via capture_tmux
get_state() {
    local id="$1"
    local tmux_session=$(session_name "$id")

    # Capture visible pane for state detection (sets LAST_TMUX_CAPTURE)
    # This returns empty if session doesn't exist - no separate has-session needed
    capture_tmux "$tmux_session" 20
    local recent="$LAST_TMUX_CAPTURE"

    if [[ -z "$recent" ]]; then
        echo "stopped"
        return
    fi

    # Check if Claude hasn't started yet (creating state)
    # This happens when the agent is very new and either:
    # - Still showing permissions screen (hasn't been accepted yet)
    # - Still showing external imports prompt (needs acceptance)
    # - Nothing meaningful showing yet (Claude still loading)
    # We capture more history to check for Claude logo
    # Check for various Claude startup indicators:
    # - "Claude Code v" (version in logo on some versions)
    # - "╭─ Claude Code" (welcome box header)
    # - "[USER TASK]" or "[AGENT CONTEXT]" (agent prompt markers)
    local full_history=$(tmux capture-pane -t "$tmux_session" -p -S - 2>/dev/null | head -100)
    local claude_started=false
    if echo "$full_history" | grep -q "Claude Code v" || \
       echo "$full_history" | grep -q "╭─ Claude Code" || \
       echo "$full_history" | grep -q "\[USER TASK\]" || \
       echo "$full_history" | grep -q "\[AGENT CONTEXT\]"; then
        claude_started=true
    fi
    if [[ "$claude_started" == false ]]; then
        # Check if permissions screen is showing (workspace trust OR external imports)
        if echo "$full_history" | grep -qi "Enter to confirm"; then
            if echo "$full_history" | grep -qi "trust" || \
               echo "$full_history" | grep -qi "Allow external CLAUDE.md file imports"; then
                echo "creating"
                return
            fi
        fi
        # Check if session is very new (minimal output, just bash starting up)
        local line_count=$(echo "$full_history" | wc -l | tr -d ' ')
        if [[ "$line_count" -lt 10 ]]; then
            echo "creating"
            return
        fi
    fi

    # Use parse_state for the actual state detection logic
    parse_state "$recent"
}

# Wait for Claude to start - logo OR permissions screen appears
# When permissions are NOT needed: logo appears immediately
# When permissions ARE needed: permissions screen appears first, logo after accepting
# Two types of permission prompts:
#   - Workspace trust: "Do you trust the files in this folder?"
#   - External imports: "Allow external CLAUDE.md file imports?"
# Args: $1 = tmux session name
# Returns: 0 if Claude started (logo or permissions detected), 1 if timed out
# Sets global CLAUDE_STARTED_WITH to "logo" or "permissions"
wait_for_claude_start() {
    local TMUX_SESSION="$1"
    local max_wait=30  # Max half-seconds to wait (15 seconds total)
    local waited=0

    while [[ $waited -lt $max_wait ]]; do
        sleep 0.5
        waited=$((waited + 1))

        # Capture ALL history from tmux and check the top 50 lines
        local top_output=$(tmux capture-pane -t "$TMUX_SESSION" -p -S - 2>/dev/null | head -50)

        # Check for Claude logo OR [USER TASK] (prompt may scroll logo off screen)
        if echo "$top_output" | grep -q "Claude Code v" || echo "$top_output" | grep -q "\[USER TASK\]"; then
            CLAUDE_STARTED_WITH="logo"
            return 0
        fi

        # Check for permissions screens - indicate Claude started but needs acceptance
        # Workspace trust prompt: "Do you trust the files" + "Enter to confirm"
        # External imports prompt: "Allow external CLAUDE.md" + "Enter to confirm"
        if echo "$top_output" | grep -qi "Enter to confirm"; then
            if echo "$top_output" | grep -qi "trust" || \
               echo "$top_output" | grep -qi "Allow external CLAUDE.md file imports"; then
                CLAUDE_STARTED_WITH="permissions"
                return 0
            fi
        fi
    done

    return 1
}

# Wait for Claude logo only (used after accepting permissions)
# Args: $1 = tmux session name
# Returns: 0 if logo found, 1 if timed out
wait_for_claude_logo() {
    local TMUX_SESSION="$1"
    local max_wait=30  # Max half-seconds to wait (15 seconds total)
    local waited=0

    while [[ $waited -lt $max_wait ]]; do
        sleep 0.5
        waited=$((waited + 1))

        # Capture ALL history and check the top for logo OR [USER TASK]
        local top_output=$(tmux capture-pane -t "$TMUX_SESSION" -p -S - 2>/dev/null | head -50)

        if echo "$top_output" | grep -q "Claude Code v" || echo "$top_output" | grep -q "\[USER TASK\]"; then
            return 0
        fi
    done

    return 1
}

# Wait for and auto-accept workspace trust and external imports dialogs
# Handles both types of permission prompts:
#   - Workspace trust: "Do you trust the files in this folder?"
#   - External imports: "Allow external CLAUDE.md file imports?"
# Both prompts may appear in sequence (trust first, then imports)
# Args: $1 = tmux session name
# Returns: 0 if successful, 1 if timed out
auto_accept_workspace_trust() {
    local TMUX_SESSION="$1"
    local max_attempts=5
    local attempt=0

    # Wait for Claude to start (shows either logo or permissions screen)
    echo "  [ib] Waiting for Claude to initialize..." >&2
    if ! wait_for_claude_start "$TMUX_SESSION"; then
        echo "  [ib] Warning: Claude did not start within timeout" >&2
        return 1
    fi

    # If logo appeared directly, no permissions needed
    if [[ "$CLAUDE_STARTED_WITH" == "logo" ]]; then
        echo "  [ib] Past permissions screen" >&2
        return 0
    fi

    # Permissions screen detected - accept it (may need multiple Enter presses)
    # Both workspace trust AND external imports prompts require Enter to accept
    while [[ $attempt -lt $max_attempts ]]; do
        echo "  [ib] Permissions screen detected, sending Enter (attempt $((attempt + 1))/$max_attempts)..." >&2
        tmux send-keys -t "$TMUX_SESSION" Enter
        attempt=$((attempt + 1))

        # Wait for Claude to process the Enter
        sleep 4

        # Check RECENT output to see if any permissions prompt is still showing
        local recent_output=$(tmux capture-pane -t "$TMUX_SESSION" -p -S -50 2>/dev/null)

        # Check if either type of permission prompt is still active
        local has_permissions=false
        if echo "$recent_output" | grep -qi "Enter to confirm"; then
            if echo "$recent_output" | grep -qi "trust" || \
               echo "$recent_output" | grep -qi "Allow external CLAUDE.md file imports"; then
                has_permissions=true
            fi
        fi

        # If no permissions prompts showing, wait for logo to confirm success
        if [[ "$has_permissions" == "false" ]]; then
            if wait_for_claude_logo "$TMUX_SESSION"; then
                echo "  [ib] Past permissions screen" >&2
                return 0
            fi
        fi
    done

    # Max attempts exceeded
    echo "  [ib] Warning: Permissions screen may still be active after $max_attempts attempts" >&2
    echo "  [ib] Use 'ib look <agent-id>' to check status" >&2
    return 1
}

# =============================================================================
# CLAUDE.md STATUS HELPERS
# =============================================================================

# Generate status block content showing agent tree with status/age/prompt
# Returns: formatted status block text for <ittybitty-status>
generate_status_block() {
    # Check if agents directory exists
    if [[ ! -d "$AGENTS_DIR" ]]; then
        echo "No active agents"
        return
    fi

    # Count agents
    local agent_count=0
    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" && -f "$agent_dir/meta.json" ]] && agent_count=$((agent_count + 1))
    done

    if [[ $agent_count -eq 0 ]]; then
        echo "No active agents"
        return
    fi

    # Build agent data file using shared helper
    local tmpfile=$(mktemp)
    local now=$(date +%s)

    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        [[ -f "$agent_dir/meta.json" ]] || continue

        local id="${agent_dir%/}"; id="${id##*/}"
        local meta="$agent_dir/meta.json"
        local manager="" created="" model="" prompt="" worker="false"

        # Read metadata using simple parsing
        local line key value
        while IFS= read -r line; do
            if [[ "$line" =~ \"([^\"]+)\":\ *\"?([^\",]*)\"? ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
                case "$key" in
                    prompt) prompt="${value//\\n/ }" ;;
                    manager) manager="$value" ;;
                    created_epoch) created="$value" ;;
                    model) model="$value" ;;
                    worker) worker="$value" ;;
                esac
            fi
        done < "$meta"

        # Handle nulls
        [[ "$manager" == "null" ]] && manager=""
        [[ "$model" == "null" || -z "$model" ]] && model="-"
        [[ "$worker" == "null" || -z "$worker" ]] && worker="false"

        # Calculate age
        local age=""
        if [[ -n "$created" ]]; then
            local diff=$((now - created))
            if [[ $diff -lt 60 ]]; then age="${diff}s"
            elif [[ $diff -lt 3600 ]]; then age="$((diff / 60))m"
            elif [[ $diff -lt 86400 ]]; then age="$((diff / 3600))h"
            else age="$((diff / 86400))d"
            fi
        else
            age="-"
        fi

        # Get state
        local state=$(get_state "$id")
        [[ "$state" == "unknown" ]] && state="waiting"

        # Write line: id|manager|state|age|model|prompt|worker
        echo "$id|$manager|$state|$age|$model|$prompt|$worker" >> "$tmpfile"
    done

    # Print header
    echo "## Current Agents ($agent_count active)"
    echo ""

    if [[ ! -s "$tmpfile" ]]; then
        rm -f "$tmpfile"
        return
    fi

    # Use build_tree_lines to format as tree (reuse existing logic)
    # First, transform our data to match expected format: id|manager|state|age|model|prompt|worker
    _BUILD_TREE_LINES=()

    # Load all lines into arrays
    local all_lines=()
    local all_ids=()
    while IFS= read -r line; do
        all_lines+=("$line")
        all_ids+=("${line%%|*}")
    done < "$tmpfile"

    # Helper to check if ID exists
    _status_id_exists() {
        local lookup_id="$1"
        local id
        for id in "${all_ids[@]}"; do
            if [[ "$id" == "$lookup_id" ]]; then
                return 0
            fi
        done
        return 1
    }

    # Recursive function to print tree
    _status_print_node() {
        local id="$1"
        local prefix="$2"
        local is_last="$3"

        # Find the line for this id
        local found_line=""
        for line in "${all_lines[@]}"; do
            if [[ "$line" == "${id}|"* ]]; then
                found_line="$line"
                break
            fi
        done

        [[ -z "$found_line" ]] && return

        # Parse: id|manager|state|age|model|prompt|worker
        local _id _manager state age model prompt worker
        IFS='|' read -r _id _manager state age model prompt worker <<< "$found_line"

        # Truncate prompt to ~40 chars
        if [[ ${#prompt} -gt 40 ]]; then
            prompt="${prompt:0:37}..."
        fi

        # Format tree connector
        local display_id="$id"
        if [[ ${#id} -gt 20 ]]; then
            display_id="${id:0:17}..."
        fi

        local tree_part
        if [[ -z "$prefix" ]]; then
            tree_part="$display_id"
        elif [[ "$prefix" == "." ]]; then
            if [[ "$is_last" == "true" ]]; then
                tree_part="└── $display_id"
            else
                tree_part="├── $display_id"
            fi
        else
            if [[ "$is_last" == "true" ]]; then
                tree_part="${prefix}└── $display_id"
            else
                tree_part="${prefix}├── $display_id"
            fi
        fi

        # Store formatted line: tree_part | state | age | prompt
        _BUILD_TREE_LINES+=("${tree_part}|${state}|${age}|${prompt}")

        # Find and print children
        local children=()
        for line in "${all_lines[@]}"; do
            local child_id="${line%%|*}"
            local rest="${line#*|}"
            local child_manager="${rest%%|*}"
            if [[ "$child_manager" == "$id" ]]; then
                children+=("$child_id")
            fi
        done

        if [[ ${#children[@]} -gt 0 ]]; then
            local child_prefix
            if [[ -z "$prefix" ]]; then
                child_prefix="."
            elif [[ "$prefix" == "." ]]; then
                if [[ "$is_last" == "true" ]]; then
                    child_prefix="    "
                else
                    child_prefix="│   "
                fi
            else
                if [[ "$is_last" == "true" ]]; then
                    child_prefix="${prefix}    "
                else
                    child_prefix="${prefix}│   "
                fi
            fi

            local child_count=${#children[@]}
            local i=0
            for child in "${children[@]}"; do
                i=$((i + 1))
                local child_is_last="false"
                [[ $i -eq $child_count ]] && child_is_last="true"
                _status_print_node "$child" "$child_prefix" "$child_is_last"
            done
        fi
    }

    # Find roots (agents with no parent or missing parent)
    local roots=()
    for line in "${all_lines[@]}"; do
        local id="${line%%|*}"
        local rest="${line#*|}"
        local parent="${rest%%|*}"
        if [[ -z "$parent" ]]; then
            roots+=("$id")
        elif ! _status_id_exists "$parent"; then
            roots+=("$id")
        fi
    done

    # Print each root and its tree
    local root_count=${#roots[@]}
    local i=0
    for root in "${roots[@]}"; do
        i=$((i + 1))
        local is_last="false"
        [[ $i -eq $root_count && $root_count -gt 1 ]] && is_last="true"
        _status_print_node "$root" "" "$is_last"
    done

    # Format and output lines with column alignment
    local max_tree_width=0
    for line in "${_BUILD_TREE_LINES[@]}"; do
        local tree_part="${line%%|*}"
        [[ ${#tree_part} -gt $max_tree_width ]] && max_tree_width=${#tree_part}
    done

    for line in "${_BUILD_TREE_LINES[@]}"; do
        local tree_part="${line%%|*}"
        local rest="${line#*|}"
        local state="${rest%%|*}"
        rest="${rest#*|}"
        local age="${rest%%|*}"
        local prompt="${rest#*|}"

        printf "%-${max_tree_width}s  %-8s  %-5s  %s\n" "$tree_part" "$state" "$age" "$prompt"
    done

    rm -f "$tmpfile"
}

# Generate pending questions block for STATUS.md
# Returns: formatted questions block or empty if no pending questions
generate_questions_block() {
    local questions_file="$ROOT_REPO_PATH/.ittybitty/user-questions.json"

    # Check if questions file exists
    if [[ ! -f "$questions_file" ]]; then
        return
    fi

    # Count pending questions
    local pending_count=$(jq '.questions | map(select(.status == "pending")) | length' "$questions_file" 2>/dev/null)

    if [[ -z "$pending_count" || "$pending_count" -eq 0 ]]; then
        return
    fi

    echo ""
    echo "## Pending Questions ($pending_count)"
    echo ""
    echo "Agents are waiting for your response. Use 'ib acknowledge <id>' then 'ib send <agent> \"answer\"' to respond."
    echo ""

    # Format each pending question
    jq -r '.questions | map(select(.status == "pending")) | .[] | "- **\(.id)** from \(.agent) (\(.timestamp)):\n  \"\(.question)\"\n"' "$questions_file" 2>/dev/null
}

# Update .ittybitty/STATUS.md with current agent status
# This is called from lifecycle events to keep the status current
# CLAUDE.md references this file via @.ittybitty/STATUS.md
update_claude_status() {
    local status_file="$ROOT_REPO_PATH/.ittybitty/STATUS.md"

    # Ensure .ittybitty directory exists
    mkdir -p "$ROOT_REPO_PATH/.ittybitty"

    # Generate status content with wrapper tags
    {
        echo "<ittybitty-status>"
        generate_status_block
        generate_questions_block
        echo "</ittybitty-status>"
    } > "$status_file"
}

# =============================================================================
# TREE HELPERS (shared by cmd_tree and cmd_watch)
# =============================================================================

# Validate all agent meta.json files have required fields
# Exits with error if any agent has invalid metadata
# Required fields: created_epoch (must be numeric)
validate_agent_metadata() {
    [[ ! -d "$AGENTS_DIR" ]] && return 0

    local errors=()
    local agent_dir id meta

    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        [[ -f "$agent_dir/meta.json" ]] || continue

        id="${agent_dir%/}"; id="${id##*/}"
        meta="$agent_dir/meta.json"

        # Check for created_epoch field (required for age calculation)
        local created_epoch
        created_epoch=$(jq -r '.created_epoch // empty' "$meta" 2>/dev/null)

        if [[ -z "$created_epoch" ]]; then
            errors+=("Agent '$id': missing 'created_epoch' field in meta.json")
        elif ! [[ "$created_epoch" =~ ^[0-9]+$ ]]; then
            errors+=("Agent '$id': 'created_epoch' must be numeric (got: $created_epoch)")
        fi
    done

    if [[ ${#errors[@]} -gt 0 ]]; then
        echo "Error: Invalid agent metadata detected" >&2
        echo "" >&2
        for err in "${errors[@]}"; do
            echo "  - $err" >&2
        done
        echo "" >&2
        echo "Fix: Either delete the invalid agent directories or update their meta.json files." >&2
        echo "Agent directories are in: $AGENTS_DIR" >&2
        exit 1
    fi
}

# Global cache for meta.json data (invalidated when meta.json file changes)
# Format: META_CACHE_IDS[i] = agent_id, META_CACHE_DATA[i] = "manager|created_epoch|model|prompt|worker"
# META_CACHE_MTIME[i] = file modification time when cached (for invalidation on agent restart)
META_CACHE_IDS=()
META_CACHE_DATA=()
META_CACHE_MTIME=()

# Global cache for tree order (invalidated when agent set or manager relationships change)
# TREE_ORDER_CACHE = array of agent IDs in tree order
# TREE_ORDER_KEY = "count:id_hash:manager_hash" (for cache invalidation)
TREE_ORDER_CACHE=()
TREE_ORDER_KEY=""

# Global cache for agent state (refreshed round-robin, one per frame)
# STATE_CACHE_IDS[i] = agent_id, STATE_CACHE_DATA[i] = state
STATE_CACHE_IDS=()
STATE_CACHE_DATA=()
STATE_FRAME_COUNT=0

# Cached epoch time (refreshed every 5 frames)
CACHED_NOW=0

# Cached tmux sessions (refreshed every 3 frames, or read from SESSIONS_FILE if available)
CACHED_SESSIONS=""
SESSIONS_FILE=""  # Set by watch to enable async session monitoring
TMUX_CACHE_DIR=""  # Set by watch for async tmux pane capture

# Background log cache (set by watch, used by main loop)
LOG_CACHE_DIR=""      # Directory with pre-wrapped log files
LOG_WIDTH_FILE=""     # File containing wrap width for background process
LOG_WIDTH_PREV=0      # Previous width (only write file when changed)
HEARTBEAT_FILE=""     # Background process heartbeat for health monitoring

# Parsed log cache (avoid re-parsing file into array every frame)
LOG_PARSED_AGENT=""   # Which agent's log is cached
LOG_PARSED_LEN=0      # Byte count of cached content
LOG_PARSED_LINES=()   # Parsed array of lines

# Permission denials pane cache
DENIALS_TIME_FILTER=0            # 0=active only, 1=last 24h, 2=last week
DENIALS_TIME_FILTER_NAMES=("ACTIVE" "24 HOURS" "7 DAYS")
DENIALS_CACHE_LINES=()           # Cached denial lines for display
DENIALS_CACHE_FILE=""            # Path to cache file (set in cmd_watch)
DENIALS_BG_PID=""                # PID of background collector process
DENIALS_CACHE_LOADED=0           # 0=not loaded yet (show loading), 1=loaded
DENIALS_LAST_FILTER=-1           # Track filter changes to trigger reload

# Diff pane cache
DIFF_CACHE_AGENT=""              # Which agent's diff is cached
DIFF_CACHE_LINES=()              # Cached diff lines for display
DIFF_CACHE_FILE=""               # Path to cache file (set in cmd_watch)
DIFF_BG_PID=""                   # PID of background collector process
DIFF_CACHE_LOADED=0              # 0=not loaded yet (show loading), 1=loaded
DIFF_MERGE_STATUS=""             # "ok", "conflicts", or "error"

# =============================================================================
# Debug Timing Infrastructure (global for use by any function)
# Set DEBUG_WATCH_MODE=1 in cmd_watch when --debug flag is passed
# =============================================================================
DEBUG_WATCH_MODE=0               # 0=off, 1=on (set by cmd_watch --debug)

DEBUG_TIMING_NAMES=()            # Names of timing points
DEBUG_TIMING_SUMS=()             # Sum of all measurements (for average)
DEBUG_TIMING_COUNTS=()           # Number of measurements
DEBUG_TIMING_MINS=()             # Minimum measurement
DEBUG_TIMING_MAXES=()            # Maximum measurement
DEBUG_TIMING_IDX=0               # Last looked-up index (avoid subshell)

# Get or create index for a timing point (result in DEBUG_TIMING_IDX)
_debug_timing_get_idx() {
    [[ $DEBUG_WATCH_MODE -eq 0 ]] && return
    local name="$1"
    local i
    for ((i=0; i<${#DEBUG_TIMING_NAMES[@]}; i++)); do
        if [[ "${DEBUG_TIMING_NAMES[$i]}" == "$name" ]]; then
            DEBUG_TIMING_IDX=$i
            return
        fi
    done
    # Not found, create new entry
    DEBUG_TIMING_IDX=${#DEBUG_TIMING_NAMES[@]}
    DEBUG_TIMING_NAMES+=("$name")
    DEBUG_TIMING_SUMS+=(0)
    DEBUG_TIMING_COUNTS+=(0)
    DEBUG_TIMING_MINS+=(999999999)
    DEBUG_TIMING_MAXES+=(0)
}

# Record a timing measurement
# Args: $1 = name, $2 = duration_ms
_debug_timing_record() {
    [[ $DEBUG_WATCH_MODE -eq 0 ]] && return
    local name="$1"
    local duration="$2"

    _debug_timing_get_idx "$name"
    local idx=$DEBUG_TIMING_IDX

    # Update statistics
    DEBUG_TIMING_SUMS[$idx]=$((DEBUG_TIMING_SUMS[$idx] + duration))
    DEBUG_TIMING_COUNTS[$idx]=$((DEBUG_TIMING_COUNTS[$idx] + 1))
    if [[ $duration -lt ${DEBUG_TIMING_MINS[$idx]} ]]; then
        DEBUG_TIMING_MINS[$idx]=$duration
    fi
    if [[ $duration -gt ${DEBUG_TIMING_MAXES[$idx]} ]]; then
        DEBUG_TIMING_MAXES[$idx]=$duration
    fi
}

# Helper to lookup cached meta data (returns index or -1)
_meta_cache_lookup() {
    local lookup_id="$1"
    local i
    for ((i=0; i<${#META_CACHE_IDS[@]}; i++)); do
        if [[ "${META_CACHE_IDS[$i]}" == "$lookup_id" ]]; then
            echo "$i"
            return
        fi
    done
    echo "-1"
}

# Read a field from meta.json with default value
# Usage: read_meta_field <meta_file> <field_name> [default_value]
# Examples:
#   manager=$(read_meta_field "$AGENT_DIR/meta.json" "manager" "")
#   worker=$(read_meta_field "$AGENT_DIR/meta.json" "worker" "false")
read_meta_field() {
    local meta_file="$1"
    local field="$2"
    local default="${3:-}"
    jq -r ".$field // \"$default\"" "$meta_file" 2>/dev/null
}

# Build agent data file for tree operations
# Creates a temp file with format: id|manager|state|age|model|prompt
# OUTPUT IS IN TREE ORDER (line N = tree index N)
# Result is stored in BUILD_AGENT_DATA_RESULT global variable
# The caller is responsible for cleaning up the temp file
# Optional: pass visible_start and visible_end to only capture state for visible tree indices
# Usage: build_agent_data_file                    # all agents get state
#        build_agent_data_file 0 5                # only indices 0-5 get state
#        local tmpfile="$BUILD_AGENT_DATA_RESULT"
#        trap "rm -f '$tmpfile'" RETURN
build_agent_data_file() {
    local visible_start="${1:-0}"
    local visible_end="${2:-999999}"
    local tmpfile=$(mktemp)

    if [[ ! -d "$AGENTS_DIR" ]]; then
        echo "$tmpfile"
        return
    fi

    # Cache epoch time, refresh every 5 frames
    local now
    if [[ $((STATE_FRAME_COUNT % 5)) -eq 0 || $CACHED_NOW -eq 0 ]]; then
        CACHED_NOW=$(date +%s)
    fi
    now=$CACHED_NOW

    # Get active tmux sessions (from background monitor file, or fallback to direct call)
    local active_sessions
    if [[ -n "$SESSIONS_FILE" && -f "$SESSIONS_FILE" ]]; then
        # Read from async background monitor (bash read, no subprocess)
        read -r active_sessions < "$SESSIONS_FILE" 2>/dev/null || true
    elif [[ $((STATE_FRAME_COUNT % 3)) -eq 0 || -z "$CACHED_SESSIONS" ]]; then
        # Fallback: call tmux directly, cache every 3 frames
        local tmux_output
        tmux_output=$(tmux list-sessions -F '#{session_name}' 2>/dev/null) || true
        CACHED_SESSIONS="${tmux_output//$'\n'/|}"
        active_sessions="$CACHED_SESSIONS"
    else
        active_sessions="$CACHED_SESSIONS"
    fi


    # === PASS 1: Get agent data from cache or disk ===
    local all_ids=()
    local all_data=()  # Each element: "manager|age|model|prompt"

    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        [[ -f "$agent_dir/meta.json" ]] || continue

        local id="${agent_dir%/}"; id="${id##*/}"
        local manager="" created_epoch="" model="" prompt="" worker="false"

        # Check cache first (inline lookup to avoid subprocess)
        local cache_idx=-1
        local _ci
        for ((_ci=0; _ci<${#META_CACHE_IDS[@]}; _ci++)); do
            if [[ "${META_CACHE_IDS[$_ci]}" == "$id" ]]; then
                cache_idx=$_ci
                break
            fi
        done

        # Get current meta.json mtime for cache validation
        local meta="$agent_dir/meta.json"
        local current_mtime
        current_mtime=$(stat -f %m "$meta" 2>/dev/null) || current_mtime=0

        # Check if cache is valid (exists and mtime matches)
        local cache_valid=0
        if [[ "$cache_idx" -ge 0 ]]; then
            local cached_mtime="${META_CACHE_MTIME[$cache_idx]}"
            if [[ "$cached_mtime" == "$current_mtime" ]]; then
                cache_valid=1
            fi
        fi

        if [[ "$cache_valid" -eq 1 ]]; then
            # Use cached data: manager|created_epoch|model|prompt|worker
            local cached="${META_CACHE_DATA[$cache_idx]}"
            manager="${cached%%|*}"
            local rest="${cached#*|}"
            created_epoch="${rest%%|*}"
            rest="${rest#*|}"
            model="${rest%%|*}"
            rest="${rest#*|}"
            prompt="${rest%%|*}"
            worker="${rest#*|}"
        else
            # Read from disk and cache (meta variable already set above)
            local line key value
            while IFS= read -r line; do
                if [[ "$line" =~ \"([^\"]+)\":\ *\"?([^\",]*)\"? ]]; then
                    key="${BASH_REMATCH[1]}"
                    value="${BASH_REMATCH[2]}"
                    case "$key" in
                        prompt) prompt="${value//\\n/ }" ;;  # Replace \n with space
                        manager) manager="$value" ;;
                        created_epoch) created_epoch="$value" ;;
                        model) model="$value" ;;
                        worker) worker="$value" ;;
                    esac
                fi
            done < "$meta"

            # Handle nulls before caching
            [[ "$manager" == "null" ]] && manager=""
            [[ "$model" == "null" || -z "$model" ]] && model="-"
            [[ "$worker" == "null" || -z "$worker" ]] && worker="false"

            # Update or add to cache
            if [[ "$cache_idx" -ge 0 ]]; then
                # Update existing cache entry (agent was restarted with same name)
                META_CACHE_DATA[$cache_idx]="$manager|$created_epoch|$model|$prompt|$worker"
                META_CACHE_MTIME[$cache_idx]="$current_mtime"
            else
                # Add new cache entry
                META_CACHE_IDS+=("$id")
                META_CACHE_DATA+=("$manager|$created_epoch|$model|$prompt|$worker")
                META_CACHE_MTIME+=("$current_mtime")
            fi
        fi

        # Calculate age (must be fresh each time)
        local age
        if [[ -n "$created_epoch" ]]; then
            local diff=$((now - created_epoch))
            if [[ $diff -lt 60 ]]; then age="${diff}s"
            elif [[ $diff -lt 3600 ]]; then age="$((diff / 60))m"
            elif [[ $diff -lt 86400 ]]; then age="$((diff / 3600))h"
            else age="$((diff / 86400))d"
            fi
        else
            age="?"
        fi

        # Handle empty manager
        [[ -z "$manager" ]] && manager=""

        # Build data for this frame
        all_ids+=("$id")
        all_data+=("$manager|$age|$model|$prompt|$worker")
    done


    # === Compute tree order (with caching) ===
    # Build cache key from agent IDs and manager relationships
    # This avoids false cache misses from filesystem glob order changes
    # and ensures tree order is recomputed when manager relationships change
    local id_hash=0
    local manager_hash=0
    local _idx
    for ((_idx=0; _idx<${#all_ids[@]}; _idx++)); do
        local _id="${all_ids[$_idx]}"
        local _data="${all_data[$_idx]}"
        local _mgr="${_data%%|*}"
        # Simple hash: sum of first 4 char ASCII values for ID
        local _c1 _c2 _c3 _c4
        printf -v _c1 '%d' "'${_id:0:1}" 2>/dev/null || _c1=0
        printf -v _c2 '%d' "'${_id:1:1}" 2>/dev/null || _c2=0
        printf -v _c3 '%d' "'${_id:2:1}" 2>/dev/null || _c3=0
        printf -v _c4 '%d' "'${_id:3:1}" 2>/dev/null || _c4=0
        ((id_hash += _c1 + _c2 + _c3 + _c4))
        # Also hash manager relationship (first 4 chars of manager)
        if [[ -n "$_mgr" ]]; then
            printf -v _c1 '%d' "'${_mgr:0:1}" 2>/dev/null || _c1=0
            printf -v _c2 '%d' "'${_mgr:1:1}" 2>/dev/null || _c2=0
            printf -v _c3 '%d' "'${_mgr:2:1}" 2>/dev/null || _c3=0
            printf -v _c4 '%d' "'${_mgr:3:1}" 2>/dev/null || _c4=0
            ((manager_hash += _c1 + _c2 + _c3 + _c4))
        fi
    done
    local id_key="${#all_ids[@]}:$id_hash:$manager_hash"

    local tree_ids=()
    if [[ "$id_key" == "$TREE_ORDER_KEY" && ${#TREE_ORDER_CACHE[@]} -gt 0 ]]; then
        # Cache hit - use cached tree order
        tree_ids=("${TREE_ORDER_CACHE[@]}")
    else
        # Cache miss - compute tree order
        # Build minimal id|manager| tmpfile for tree computation
        local tree_tmp=$(mktemp)
        local i
        for ((i=0; i<${#all_ids[@]}; i++)); do
            local id="${all_ids[$i]}"
            local data="${all_data[$i]}"
            local manager="${data%%|*}"
            echo "$id|$manager|" >> "$tree_tmp"
        done

        while IFS= read -r line; do
            [[ -n "$line" ]] && tree_ids+=("$line")
        done < <(get_agent_ids_tree_order "$tree_tmp")
        rm -f "$tree_tmp"

        # Update cache
        TREE_ORDER_CACHE=("${tree_ids[@]}")
        TREE_ORDER_KEY="$id_key"
    fi


    # === PASS 2: Write tmpfile in TREE ORDER ===
    local idx
    for ((idx=0; idx<${#tree_ids[@]}; idx++)); do
        local id="${tree_ids[$idx]}"

        # Find cached data for this ID (linear search - fine for ~10 agents)
        local data=""
        local j
        for ((j=0; j<${#all_ids[@]}; j++)); do
            if [[ "${all_ids[$j]}" == "$id" ]]; then
                data="${all_data[$j]}"
                break
            fi
        done

        # Parse cached data: manager|age|model|prompt|worker
        local manager="${data%%|*}"
        local rest="${data#*|}"
        local age="${rest%%|*}"
        rest="${rest#*|}"
        local model="${rest%%|*}"
        rest="${rest#*|}"
        local prompt="${rest%%|*}"
        local worker="${rest#*|}"

        # Get state only for visible indices (round-robin refresh)
        local state="-"
        if [[ $idx -ge $visible_start && $idx -le $visible_end ]]; then
            local visible_offset=$((idx - visible_start))

            # Check state cache first (inline lookup)
            local state_cache_idx=-1
            local _sci
            for ((_sci=0; _sci<${#STATE_CACHE_IDS[@]}; _sci++)); do
                if [[ "${STATE_CACHE_IDS[$_sci]}" == "$id" ]]; then
                    state_cache_idx=$_sci
                    break
                fi
            done

            local tmux_session=$(session_name "$id")
            # For new agents (not in cache), check tmux directly instead of relying on cached sessions
            local session_exists=false
            if [[ $state_cache_idx -lt 0 ]]; then
                # New agent - check tmux directly to avoid stale session list
                tmux has-session -t "$tmux_session" 2>/dev/null && session_exists=true
            elif [[ "$active_sessions" == *"$tmux_session"* ]]; then
                session_exists=true
            fi
            if [[ "$session_exists" == "true" ]]; then
                # Refresh one agent per frame (round-robin) or if not cached
                if [[ $((STATE_FRAME_COUNT % 5)) -eq $visible_offset || $state_cache_idx -lt 0 ]]; then
                    # Debug timing: duplicates get_ms() because get_ms is defined inside cmd_watch and not accessible here
                    local t_state_start t_state_end
                    [[ $DEBUG_WATCH_MODE -eq 1 ]] && t_state_start=$(perl -MTime::HiRes -e 'printf "%d", Time::HiRes::time * 1000' 2>/dev/null || date +%s000)
                    state=$(get_state "$id")
                    [[ $DEBUG_WATCH_MODE -eq 1 ]] && { t_state_end=$(perl -MTime::HiRes -e 'printf "%d", Time::HiRes::time * 1000' 2>/dev/null || date +%s000); _debug_timing_record "state_detection" $((t_state_end - t_state_start)); }
                    [[ "$state" == "unknown" ]] && state="waiting"
                    # Update cache
                    if [[ $state_cache_idx -ge 0 ]]; then
                        STATE_CACHE_DATA[$state_cache_idx]="$state"
                    else
                        STATE_CACHE_IDS+=("$id")
                        STATE_CACHE_DATA+=("$state")
                    fi
                else
                    # Use cached state
                    state="${STATE_CACHE_DATA[$state_cache_idx]}"
                fi
            else
                state="stopped"
                # Update cache for stopped agents
                if [[ $state_cache_idx -ge 0 ]]; then
                    STATE_CACHE_DATA[$state_cache_idx]="$state"
                else
                    STATE_CACHE_IDS+=("$id")
                    STATE_CACHE_DATA+=("$state")
                fi
            fi
        fi

        echo "$id|$manager|$state|$age|$model|$prompt|$worker" >> "$tmpfile"
    done

    # Increment frame counter for round-robin state refresh
    # Reset after ~24 hours at 30fps to prevent overflow (2592000 = 24*60*60*30)
    ((STATE_FRAME_COUNT++))
    [[ $STATE_FRAME_COUNT -gt 2592000 ]] && STATE_FRAME_COUNT=0

    # Store result in global - callers read BUILD_AGENT_DATA_RESULT
    BUILD_AGENT_DATA_RESULT="$tmpfile"
}

# Get agent IDs in depth-first tree order
# Args: $1 = tmpfile with id|manager| format
# Outputs: one agent ID per line in tree traversal order
# Note: Pure bash implementation - no grep/cut subprocesses
get_agent_ids_tree_order() {
    local tmpfile="$1"

    if [[ ! -s "$tmpfile" ]]; then
        return
    fi

    # Read all data into arrays (one pass)
    local _order_ids=()
    local _order_managers=()
    local _id _manager _rest
    while IFS='|' read -r _id _manager _rest; do
        _order_ids+=("$_id")
        _order_managers+=("$_manager")
    done < "$tmpfile"

    local _count=${#_order_ids[@]}

    # Helper to check if an ID exists (returns 0=found, 1=not found)
    _order_id_exists() {
        local lookup="$1"
        local _i
        for ((_i=0; _i<_count; _i++)); do
            if [[ "${_order_ids[$_i]}" == "$lookup" ]]; then
                return 0
            fi
        done
        return 1
    }

    # Helper to get children - sets _ORDER_CHILDREN array
    _order_get_children() {
        local manager_id="$1"
        _ORDER_CHILDREN=()
        local _i
        for ((_i=0; _i<_count; _i++)); do
            if [[ "${_order_managers[$_i]}" == "$manager_id" ]]; then
                _ORDER_CHILDREN+=("${_order_ids[$_i]}")
            fi
        done
    }

    # Recursive helper to emit agent IDs in tree order
    _order_emit() {
        local id="$1"
        echo "$id"
        _order_get_children "$id"
        local _child
        for _child in "${_ORDER_CHILDREN[@]}"; do
            _order_emit "$_child"
        done
    }

    # Find root agents (no parent OR parent doesn't exist in file)
    local _roots=()
    local _i
    for ((_i=0; _i<_count; _i++)); do
        local _id="${_order_ids[$_i]}"
        local _manager="${_order_managers[$_i]}"
        if [[ -z "$_manager" ]]; then
            _roots+=("$_id")
        elif ! _order_id_exists "$_manager"; then
            _roots+=("$_id")
        fi
    done

    # Emit all trees
    local _root
    for _root in "${_roots[@]}"; do
        _order_emit "$_root"
    done
}

# Build tree lines with formatting (pipe-delimited for column alignment)
# Args: $1 = tmpfile from build_agent_data_file
# Result: sets _BUILD_TREE_LINES array with raw pipe-delimited lines
# Use format_tree_lines to convert to formatted output
_BUILD_TREE_LINES=()
build_tree_lines() {
    local tmpfile="$1"
    _BUILD_TREE_LINES=()

    if [[ ! -s "$tmpfile" ]]; then
        return
    fi

    # Load all lines into indexed array (bash 3.2 compatible)
    local _all_lines=()
    local _all_ids=()
    while IFS= read -r line; do
        _all_lines+=("$line")
        _all_ids+=("${line%%|*}")
    done < "$tmpfile"

    # Function-local "return" variables (avoids script globals)
    local _INFO=""
    local _CHILDREN=""

    # Helper to get agent info - sets _INFO (no subprocess)
    _tree_get_agent_info() {
        _INFO=""
        local lookup_id="$1"
        local line
        for line in "${_all_lines[@]}"; do
            if [[ "$line" == "${lookup_id}|"* ]]; then
                _INFO="$line"
                return
            fi
        done
    }

    # Helper to get children of a manager - sets _CHILDREN (no subprocess)
    _tree_get_children_for_print() {
        _CHILDREN=""
        local manager_id="$1"
        local line id rest manager
        for line in "${_all_lines[@]}"; do
            id="${line%%|*}"
            rest="${line#*|}"
            manager="${rest%%|*}"
            if [[ "$manager" == "$manager_id" ]]; then
                _CHILDREN+="$id "
            fi
        done
        _CHILDREN="${_CHILDREN% }"
    }

    # Helper to check if ID exists - returns 0 if found (no subprocess)
    _tree_id_exists() {
        local lookup_id="$1"
        local id
        for id in "${_all_ids[@]}"; do
            if [[ "$id" == "$lookup_id" ]]; then
                return 0
            fi
        done
        return 1
    }

    # Recursive function to print tree
    _tree_print_node() {
        local id="$1"
        local prefix="$2"
        local is_last="$3"

        # Get agent info and parse with bash
        _tree_get_agent_info "$id"
        local _id _manager state age model prompt worker
        IFS='|' read -r _id _manager state age model prompt worker <<< "$_INFO"

        # Check if this agent is orphaned (worker with missing manager)
        local is_orphan=""
        if [[ "$worker" == "true" && -n "$_manager" && ! -z "$_manager" ]]; then
            # This is a worker with a manager - check if manager exists
            if ! _tree_id_exists "$_manager"; then
                is_orphan="orphan"
            fi
        fi

        # Truncate agent name to 30 chars if needed
        local display_id="$id"
        if [[ ${#id} -gt 30 ]]; then
            display_id="${id:0:27}..."
        fi

        # Print this node with aligned columns
        local connector child_prefix tree_part
        if [[ -z "$prefix" ]]; then
            # Root node - no prefix/connector
            tree_part="$display_id"
            child_prefix="."
        elif [[ "$prefix" == "." ]]; then
            # First level child
            connector="├──"
            child_prefix="│   "
            if [[ "$is_last" == "true" ]]; then
                connector="└──"
                child_prefix="    "
            fi
            tree_part="$connector $display_id"
        else
            # Deeper level
            connector="├──"
            child_prefix="${prefix}│   "
            if [[ "$is_last" == "true" ]]; then
                connector="└──"
                child_prefix="${prefix}    "
            fi
            tree_part="$prefix$connector $display_id"
        fi

        # Format: tree_part | state | age | model | orphan | prompt
        _BUILD_TREE_LINES+=("${tree_part}|${state}|${age}|${model}|${is_orphan}|${prompt}")

        # Print children
        _tree_get_children_for_print "$id"
        if [[ -n "$_CHILDREN" ]]; then
            local child_array=($_CHILDREN)
            local child_count=${#child_array[@]}
            local i=0
            for child in "${child_array[@]}"; do
                i=$((i + 1))
                local child_is_last="false"
                if [[ $i -eq $child_count ]]; then
                    child_is_last="true"
                fi
                _tree_print_node "$child" "$child_prefix" "$child_is_last"
            done
        fi
    }

    # Find roots (agents with no parent or orphaned parent)
    local roots=""
    local id parent _rest
    for line in "${_all_lines[@]}"; do
        id="${line%%|*}"
        _rest="${line#*|}"
        parent="${_rest%%|*}"
        if [[ -z "$parent" ]]; then
            roots+="$id "
        elif ! _tree_id_exists "$parent"; then
            roots+="$id "
        fi
    done
    roots="${roots% }"

    # Print each root and its tree
    local root_array=($roots)
    local root_count=${#root_array[@]}
    local i=0
    for root in "${root_array[@]}"; do
        i=$((i + 1))
        local is_last="false"
        if [[ $i -eq $root_count && $root_count -gt 1 ]]; then
            is_last="true"
        fi
        _tree_print_node "$root" "" "$is_last"
    done
}

# Format tree lines with column alignment (pure bash, no subprocess)
# Uses _BUILD_TREE_LINES set by build_tree_lines
# Result: sets _FORMATTED_TREE_LINES array with aligned output
_FORMATTED_TREE_LINES=()
format_tree_lines() {
    # Optional arg: terminal width for prompt clipping
    local term_width="${1:-0}"
    _FORMATTED_TREE_LINES=()

    [[ ${#_BUILD_TREE_LINES[@]} -eq 0 ]] && return

    # Find max width of tree column (first column)
    local max_tree_width=0
    local line tree_part
    for line in "${_BUILD_TREE_LINES[@]}"; do
        tree_part="${line%%|*}"
        [[ ${#tree_part} -gt $max_tree_width ]] && max_tree_width=${#tree_part}
    done

    # Calculate fixed column widths: tree + 2 + state(8) + 2 + age(5) + 2 + model(10) + 2 = tree + 31
    local fixed_width=$((max_tree_width + 31))
    local max_prompt_width=0
    if [[ $term_width -gt 0 ]]; then
        max_prompt_width=$((term_width - fixed_width))
        [[ $max_prompt_width -lt 10 ]] && max_prompt_width=10
    fi

    # Format each line with aligned columns
    local state age model orphan_status prompt rest
    for line in "${_BUILD_TREE_LINES[@]}"; do
        tree_part="${line%%|*}"
        rest="${line#*|}"
        state="${rest%%|*}"
        rest="${rest#*|}"
        age="${rest%%|*}"
        rest="${rest#*|}"
        model="${rest%%|*}"
        rest="${rest#*|}"
        orphan_status="${rest%%|*}"
        prompt="${rest#*|}"

        # Add warning prefix if orphaned
        if [[ "$orphan_status" == "orphan" ]]; then
            tree_part="⚠️ ${tree_part}"
        fi

        # Clip prompt to terminal width if specified
        if [[ $max_prompt_width -gt 0 && ${#prompt} -gt $max_prompt_width ]]; then
            prompt="${prompt:0:$((max_prompt_width - 1))}…"
        fi

        # Format: tree (dynamic) | state (8) | age (5) | model (10) | prompt
        printf -v formatted "%-${max_tree_width}s  %-8s  %-5s  %-10s  %s" \
            "$tree_part" "$state" "$age" "$model" "$prompt"
        _FORMATTED_TREE_LINES+=("$formatted")
    done
}

# =============================================================================
# COMMAND: new-agent
# =============================================================================

cmd_new_agent() {
    local NAME=""
    local MANAGER=""
    local USE_WORKTREE=true
    local ALLOW_TOOLS=""
    local DENY_TOOLS=""
    local PRINT_MODE=false
    local YOLO_MODE=false
    local WORKER_MODE=false
    local MODEL=""
    local PROMPT=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)        NAME="$2"; shift 2 ;;
            --manager|--parent)      MANAGER="$2"; shift 2 ;;
            --no-worktree) USE_WORKTREE=false; shift ;;
            --allow-tools) ALLOW_TOOLS="$2"; shift 2 ;;
            --deny-tools)  DENY_TOOLS="$2"; shift 2 ;;
            --print)       PRINT_MODE=true; shift ;;
            --yolo)        YOLO_MODE=true; shift ;;
            --worker|--leaf) WORKER_MODE=true; shift ;;
            --model)       MODEL="$2"; shift 2 ;;
            -h|--help)
                cat <<EOF
Usage: ib new-agent [options] "prompt"

Start a new Claude agent with the given prompt.

Must be run from the root of a git repository. By default, each agent gets
its own git worktree and branch for isolated work.

Options:
  --name NAME           Custom agent name (default: auto-generated)
  --manager ID          Manager agent ID (for hierarchy tracking)
  --no-worktree         Work in repo root instead of isolated worktree
  --allow-tools LIST    Only allow these tools (comma-separated)
  --deny-tools LIST     Deny these tools (comma-separated)
  --print               Run in one-shot mode (no interaction)
  --yolo                Skip all permission prompts (full autonomy)
  --worker              Create a worker agent (no sub-agent spawning)
  --model MODEL         Claude model to use (e.g., opus, sonnet, haiku)
  -h, --help            Show this help

Permission modes:
  (default)   Auto-rejects non-allowed tools, auto-accepts workspace trust
  --yolo      Auto-accepts everything (full autonomy, use with caution)

Agent types:
  (default)   Manager agent - can spawn and manage sub-agents via 'ib' commands
  --worker    Worker agent - cannot spawn sub-agents, focused on task execution

Configuration:
  Create .ittybitty.json in your repo root to configure agent permissions:

    {
      "maxAgents": 10,
      "fps": 10,
      "model": "sonnet",
      "allowAgentQuestions": true,
      "permissions": {
        "manager": { "allow": ["Read", "Write", "Edit"], "deny": [] },
        "worker": { "allow": ["Read", "Write"], "deny": [] }
      }
    }

  - maxAgents: Maximum number of concurrent agents (default: 10)
  - fps: Target frame rate for 'ib watch' screen (default: 10)
  - model: Default Claude model for spawned agents (e.g., opus, sonnet, haiku)
           Overridden by --model parameter if provided
  - allowAgentQuestions: Allow root managers to ask user questions via 'ib ask'
                         (default: true). Set to false to disable.
  - permissions.manager: Applied to manager (coordinator) agents
  - permissions.worker: Applied to worker agents
  - Bash(ib:*) is always added for agent coordination
  - Base settings from .claude/settings.local.json are merged in

Examples:
  ib new-agent "verify citations in vs-freeform.md"
  ib new-agent --name checker "research and summarize"
  ib new --yolo "research and update the pricing page"
  ib new --worker --manager coordinator "check link #1"
  ib new --model sonnet "quick task for a faster model"
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                PROMPT="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$PROMPT" ]]; then
        echo "Error: prompt required" >&2
        echo "Usage: ib new-agent [options] \"prompt\"" >&2
        exit 1
    fi

    # Verify we're in a git repo
    if [[ -z "$ROOT_REPO_PATH" ]]; then
        echo "Error: must be run from within a git repository" >&2
        exit 1
    fi

    # Ensure .ittybitty directory structure exists
    ensure_ittybitty_dirs

    # Auto-detect manager if not explicitly set and we're in an agent worktree
    if [[ -z "$MANAGER" ]]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == *"/.ittybitty/agents/"*"/repo"* ]]; then
            # Find the agent directory and read meta.json
            local agent_dir=$(echo "$current_dir" | sed 's|\(.*/.ittybitty/agents/[^/]*\)/repo.*|\1|')
            if [[ -f "$agent_dir/meta.json" ]]; then
                MANAGER=$(read_meta_field "$agent_dir/meta.json" "id" "")
            fi
        fi
    fi

    # Validate manager ID if provided
    if [[ -n "$MANAGER" ]]; then
        # Try to resolve the manager ID (supports partial IDs)
        local RESOLVED_MANAGER=$(resolve_agent_id "$MANAGER" 2>/dev/null)
        if [[ -z "$RESOLVED_MANAGER" ]]; then
            echo "Error: Manager agent '$MANAGER' not found" >&2
            echo "" >&2
            echo "Run 'ib list' to see available agents." >&2
            exit 1
        fi
        MANAGER="$RESOLVED_MANAGER"

        # Check if the manager is a worker agent
        local MANAGER_DIR="$AGENTS_DIR/$MANAGER"
        local is_worker=$(read_meta_field "$MANAGER_DIR/meta.json" "worker" "false")
        if [[ "$is_worker" == "true" ]]; then
            echo "Error: '$MANAGER' is a worker agent and cannot manage sub-agents" >&2
            echo "" >&2
            echo "Worker agents are created with --worker and cannot spawn sub-agents." >&2
            echo "Only manager agents can have children." >&2
            exit 1
        fi
    fi

    # Security check: Prevent yolo escalation from non-yolo agents
    # A non-yolo agent should NOT be able to spawn a yolo child, as this would
    # allow permission escalation attacks where a constrained agent spawns
    # an unconstrained one, bypassing all permission controls.
    if [[ "$YOLO_MODE" == true ]]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == *"/.ittybitty/agents/"*"/repo"* ]]; then
            # We're running as an agent - check if parent is yolo
            local parent_agent_dir=$(echo "$current_dir" | sed 's|\(.*/.ittybitty/agents/[^/]*\)/repo.*|\1|')
            local parent_is_yolo=false

            # First try meta.json (preferred, cleaner)
            if [[ -f "$parent_agent_dir/meta.json" ]]; then
                parent_is_yolo=$(read_meta_field "$parent_agent_dir/meta.json" "yolo" "false")
            fi

            # Fallback: check start.sh for dangerously-skip-permissions flag
            # (for agents created before yolo was stored in meta.json)
            if [[ "$parent_is_yolo" != "true" && -f "$parent_agent_dir/start.sh" ]]; then
                if grep -q "dangerously-skip-permissions" "$parent_agent_dir/start.sh"; then
                    parent_is_yolo=true
                fi
            fi

            if [[ "$parent_is_yolo" != "true" ]]; then
                echo "Error: Yolo mode denied - permission escalation not allowed" >&2
                echo "" >&2
                echo "Your agent is not running in yolo mode, so you cannot spawn sub-agents" >&2
                echo "with --yolo. This would allow bypassing permission controls." >&2
                echo "" >&2
                echo "Either:" >&2
                echo "  1. Remove the --yolo flag from your new-agent command" >&2
                echo "  2. Ask the user to restart your agent with --yolo if appropriate" >&2
                exit 1
            fi
        fi
    fi

    # Load config for PR settings
    load_config

    # Apply model from config if not specified via --model parameter
    if [[ -z "$MODEL" && -n "$CONFIG_MODEL" ]]; then
        MODEL="$CONFIG_MODEL"
    fi

    # Fallback to sonnet if still no model specified
    # This ensures model is never null in meta.json
    if [[ -z "$MODEL" ]]; then
        MODEL="sonnet"
    fi

    # Check max agents limit
    local current_agent_count=$(count_agents)
    if [[ "$current_agent_count" -ge "$CONFIG_MAX_AGENTS" ]]; then
        echo "Error: Maximum agent limit reached ($current_agent_count/$CONFIG_MAX_AGENTS agents)" >&2
        echo "" >&2
        echo "This is a safety limit for the entire repository to prevent runaway agent spawning." >&2
        echo "You can:" >&2
        echo "  1. Check 'ib list' - if you have completed subagents, merge or kill them" >&2
        echo "  2. Wait until agents have completed before trying to create new ones" >&2
        echo "  3. Ask the user to increase the limit in .ittybitty.json (default: $CONFIG_MAX_AGENTS)" >&2
        exit 1
    fi

    # Warn if root-level manager and CLAUDE.md doesn't have STATUS.md integration
    # This warning helps users understand that 'ib ask' won't work without the integration
    if [[ -z "$MANAGER" && "$WORKER_MODE" != true ]]; then
        local claude_md="$ROOT_REPO_PATH/CLAUDE.md"
        if [[ -f "$claude_md" ]]; then
            # Check for either <ittybitty-status> block or @.ittybitty/STATUS.md import
            if ! grep -q '<ittybitty-status>' "$claude_md" && ! grep -q '@\.ittybitty/STATUS\.md' "$claude_md"; then
                echo "Warning: CLAUDE.md does not import .ittybitty/STATUS.md" >&2
                echo "The 'ib ask' feature requires this to show agent questions to the primary Claude." >&2
                echo "Run 'ib init' to set up the integration." >&2
                echo "" >&2
            fi
        else
            echo "Warning: No CLAUDE.md found in repository root" >&2
            echo "The 'ib ask' feature requires CLAUDE.md to import .ittybitty/STATUS.md" >&2
            echo "Run 'ib init' to set up the integration." >&2
            echo "" >&2
        fi
    fi

    # Generate agent ID
    local ID
    if [[ -n "$NAME" ]]; then
        ID="$NAME"
    else
        ID="agent-$(openssl rand -hex 4)"
    fi

    # Check if agent already exists
    local TMUX_SESSION=$(session_name "$ID")
    if [[ -d "$AGENTS_DIR/$ID" ]] || tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        echo "Error: agent '$ID' already exists" >&2
        exit 1
    fi

    # Set up directories in root repo
    local AGENT_DIR="$AGENTS_DIR/$ID"
    mkdir -p "$AGENT_DIR"

    # Set working directory (default to root repo)
    local WORK_PATH="$ROOT_REPO_PATH"

    # Create git worktree if requested
    if [[ "$USE_WORKTREE" == true ]]; then
        local BRANCH_NAME="agent/$ID"

        # Determine which branch to fork from:
        # - If spawned by a manager, branch from the manager's branch (agent/<manager-id>)
        # - Otherwise, branch from main repo's HEAD
        local BASE_REF="HEAD"
        if [[ -n "$MANAGER" ]]; then
            # Manager's branch is always agent/<manager-id>
            BASE_REF="agent/$MANAGER"
        fi

        # Create worktree from root repo, branching from determined base
        git -C "$ROOT_REPO_PATH" worktree add "$AGENT_DIR/repo" -b "$BRANCH_NAME" "$BASE_REF" || {
            echo "Error: could not create worktree" >&2
            rm -rf "$AGENT_DIR"
            exit 1
        }
        WORK_PATH="$AGENT_DIR/repo"

        # Build agent settings with permissions from .ittybitty.json config
        mkdir -p "$AGENT_DIR/repo/.claude"
        local agent_type="manager"
        if [[ "$WORKER_MODE" == true ]]; then
            agent_type="worker"
        fi

        if command -v jq &>/dev/null; then
            # Run build_agent_settings from root repo context
            (cd "$ROOT_REPO_PATH" && build_agent_settings "$agent_type") > "$AGENT_DIR/repo/.claude/settings.local.json"
            # Replace agent ID placeholder in hook configuration
            sed -i '' "s|__AGENT_ID__|$ID|g" "$AGENT_DIR/repo/.claude/settings.local.json"
        else
            # Fallback: minimal settings if jq not available
            if [[ -f "$ROOT_REPO_PATH/.claude/settings.local.json" ]]; then
                cp "$ROOT_REPO_PATH/.claude/settings.local.json" "$AGENT_DIR/repo/.claude/"
            else
                echo '{"permissions":{"allow":["Bash(ib:*)","Bash(./ib:*)"]}}' > "$AGENT_DIR/repo/.claude/settings.local.json"
            fi
        fi
    else
        # Non-worktree mode: ensure ib permissions are in root repo settings
        local ROOT_SETTINGS="$ROOT_REPO_PATH/.claude/settings.local.json"
        if command -v jq &>/dev/null && [[ -f "$ROOT_SETTINGS" ]]; then
            # Check if both patterns are already allowed
            local needs_update=false
            if ! jq -e '.permissions.allow | index("Bash(ib:*)")' "$ROOT_SETTINGS" &>/dev/null; then
                needs_update=true
            fi
            if ! jq -e '.permissions.allow | index("Bash(./ib:*)")' "$ROOT_SETTINGS" &>/dev/null; then
                needs_update=true
            fi
            if [[ "$needs_update" == true ]]; then
                local tmp=$(mktemp)
                jq '.permissions.allow += ["Bash(ib:*)", "Bash(./ib:*)"] | .permissions.allow |= unique' \
                    "$ROOT_SETTINGS" > "$tmp" && mv "$tmp" "$ROOT_SETTINGS"
                echo "Added Bash(ib:*) and Bash(./ib:*) to .claude/settings.local.json" >&2
            fi
        elif [[ ! -f "$ROOT_SETTINGS" ]]; then
            mkdir -p "$ROOT_REPO_PATH/.claude"
            echo '{"permissions":{"allow":["Bash(ib:*)","Bash(./ib:*)"]}}' > "$ROOT_SETTINGS"
            echo "Created .claude/settings.local.json with ib allowed" >&2
        fi
    fi

    # Generate a UUID for the Claude session (enables resume if tmux dies)
    local SESSION_UUID=$(uuidgen | tr '[:upper:]' '[:lower:]')

    # Write metadata
    cat > "$AGENT_DIR/meta.json" <<EOF
{
  "id": "$ID",
  "session_id": "$SESSION_UUID",
  "tmux_session": "$TMUX_SESSION",
  "prompt": $(echo "$PROMPT" | jq -Rs .),
  "manager": $(if [[ -n "$MANAGER" ]]; then echo "\"$MANAGER\""; else echo "null"; fi),
  "created": "$(date -Iseconds)",
  "created_epoch": $(date +%s),
  "worktree": $USE_WORKTREE,
  "worker": $WORKER_MODE,
  "yolo": $YOLO_MODE,
  "model": $(if [[ -n "$MODEL" ]]; then echo "\"$MODEL\""; else echo "null"; fi)
}
EOF

    # Log agent creation
    if [[ -n "$MANAGER" ]]; then
        log_agent "$ID" "Agent created (manager: $MANAGER, prompt: $PROMPT)" --quiet
    else
        log_agent "$ID" "Agent created (prompt: $PROMPT)" --quiet
    fi

    # Build prompt with context prefix
    local MANAGER_INFO=""
    if [[ -n "$MANAGER" ]]; then
        MANAGER_INFO="Your manager agent is: $MANAGER"
    fi

    local WORKTREE_INFO=""
    local PATH_ISOLATION=""
    local GIT_WORKTREE_CONTEXT=""
    local COMPLETION_INSTRUCTIONS=""
    if [[ "$USE_WORKTREE" == true ]]; then
        # Determine parent branch for context
        local PARENT_BRANCH="main"
        if [[ -n "$MANAGER" ]]; then
            PARENT_BRANCH="agent/$MANAGER"
        fi

        WORKTREE_INFO="You are running as agent $ID in a git worktree on branch agent/$ID, forked from $PARENT_BRANCH."

        PATH_ISOLATION="
PATH ISOLATION:
You are isolated to your worktree at: $AGENT_DIR/repo
- You CAN access: Your worktree, ~/.claude, /tmp, and general system paths
- You CANNOT access: The main repo at $ROOT_REPO_PATH, other agents' worktrees
- If you get \"Access denied\" or \"Path violation\" errors, you're trying to access a forbidden path
- Do NOT try to cd into the main repo - work only in your worktree"

        GIT_WORKTREE_CONTEXT="
GIT WORKTREE CONTEXT:
You are in a git worktree, which shares the same repository as the main checkout.
- Your branch: agent/$ID
- Forked from: $PARENT_BRANCH
- All branches are LOCAL - no need for 'git fetch origin'
- To merge latest changes from your parent: 'git merge $PARENT_BRANCH' (not 'git fetch origin; git merge origin/...')
- Other agents' branches are visible as local branches (agent/*)
- Your worktree is a separate checkout, but commits are shared across all worktrees"
        if [[ "$WORKER_MODE" == true ]]; then
            COMPLETION_INSTRUCTIONS="State Management:
- Whenever you stop working and are idle, you must end your message with either:
  - 'WAITING' - if waiting for input or have nothing more to do without further instruction
  - 'I HAVE COMPLETED THE GOAL' - if you have completed your task
- CRITICAL: These phrases MUST be the LAST thing you output. Put any summaries or status updates BEFORE these phrases, never after.

When your task is complete:
1. Commit any changes you made (git add && git commit)
2. FIRST: Write your summary of what you accomplished
3. LAST: Say the exact phrase: \"I HAVE COMPLETED THE GOAL\"
   This phrase MUST be the final line - nothing after it.
   This signals to your manager agent that you are done.
4. Wait for your manager to merge or kill your session."
        else
            # Determine PR instructions based on config and gh availability
            local PR_INSTRUCTIONS=""
            local HAS_GH=$(command -v gh &>/dev/null && echo "true" || echo "false")
            local HAS_REMOTE=$(git remote 2>/dev/null | head -1)

            if [[ "$CONFIG_CREATE_PRS" == "true" && "$HAS_GH" == "true" && -n "$HAS_REMOTE" ]]; then
                PR_INSTRUCTIONS="Once you have completed your primary goal by merging in successful agents, double check that you have completed the goal.
If so:
1. Create a pull request with \`gh pr create --title \"<title>\" --body \"<description>\"\`
2. FIRST: Write any final summary or notes
3. LAST: Say the exact phrase: \"I HAVE COMPLETED THE GOAL\"
   This phrase MUST be the final line - nothing after it."
            else
                PR_INSTRUCTIONS="Once you have completed your primary goal by merging in successful agents, double check that you have completed the goal.
If so:
1. FIRST: Write any final summary or notes
2. LAST: Say the exact phrase: \"I HAVE COMPLETED THE GOAL\"
   This phrase MUST be the final line - nothing after it.
Your work is on branch \`agent/$ID\` for review."
            fi

            COMPLETION_INSTRUCTIONS="State Management:
- Whenever you stop working and are idle, you must end your message with either:
  - 'WAITING' - if waiting for next monitoring cycle or have nothing more to do
  - 'I HAVE COMPLETED THE GOAL' - if you have completed your primary goal
- CRITICAL: These phrases MUST be the LAST thing you output. Put any summaries or status updates BEFORE these phrases, never after.

Your workflow:
1. DEFINE SUCCESS CRITERIA - What does 'done' look like?
   - What files/outputs are required? What conditions prove completion?
   - Track in TodoWrite tool with measurable criteria

2. ASSESS TASK SIZE - Now that you know what success looks like:
   - SMALL: Do it yourself - don't spawn sub-agents unnecessarily
   - MEDIUM/LARGE: Break into independent tasks, each with clear success criteria

3. IF SPAWNING: Create WORKER sub-agents (--worker) for each task
   - Include the task AND its success criteria in the prompt
   - Enter WAITING mode - a watchdog monitors each worker and notifies you when they complete or need help (don't poll)

4. WHEN NOTIFIED - Review against your predefined criteria:
   - \`ib look <id>\` - what the agent reports
   - \`ib status <id>\` / \`ib diff <id>\` - verify actual changes
   - Criteria met: \`ib merge <id>\` or \`ib kill <id>\` (if no changes)
   - Criteria NOT met: \`ib send <id> \"feedback\"\`
   - If \`stopped\`: STOP and notify the user immediately

5. BEFORE COMPLETING: Merge or kill ALL sub-agents (\`ib list\` to verify none remain)

$PR_INSTRUCTIONS"
        fi
    else
        WORKTREE_INFO="You are running as agent $ID in the main repository (no worktree)."
        COMPLETION_INSTRUCTIONS="When your task is complete:
1. Commit any changes you made (git add && git commit)
2. Exit normally"
    fi

    local IB_INSTRUCTIONS=""
    if [[ "$WORKER_MODE" != true ]]; then
        # Build base manager instructions
        local ASK_INSTRUCTION=""
        if [[ -z "$MANAGER" ]]; then
            # Root-level managers can ask questions to the user
            ASK_INSTRUCTION="
  ib ask \"question\"                              Ask the user a question (top-level managers only)"
        fi
        IB_INSTRUCTIONS="
You have access to the 'ib' tool for multi-agent coordination.
IMPORTANT: Always use 'ib' (not './ib') to ensure you use the current version from PATH.

  ib new-agent --manager $ID --worker \"task\"   Spawn a worker sub-agent (focused worker, no sub-agents)
  ib list --manager $ID                          List your sub-agents
  ib look <agent-id>                             Read an agent's output
  ib send <agent-id> \"message\"                  Send input to an agent
  ib status <agent-id>                           Check agent's git commits
  ib merge <agent-id>                            Merge agent's work and close it
  ib kill <agent-id>                             Stop an agent without merging$ASK_INSTRUCTION

WATCHDOGS: Each sub-agent you spawn is monitored. Enter WAITING mode after spawning - you'll be notified when they complete or need help. Don't poll \`ib list\`.

If \`ib merge\` fails due to conflicts, choose the best strategy:
1. Resolve the merge yourself: edit conflicting files, \`git add <files> && git commit\`, then clean up with \`git worktree remove <path> --force && git branch -D agent/<id>\`
2. Spawn a WORKER sub-agent to handle the merge resolution, then monitor it to completion
3. If the merge is no longer needed, skip it and note this in your final report

MERGE CONFLICT RESOLUTION:
- NEVER blindly accept one side (\`git checkout --ours/theirs .\`) - both sides represent real work
- Understand what each side was trying to accomplish, then merge the INTENT
- If unclear, ASK your manager (or \`ib ask\` if top-level)
- After: \`git add <files> && git commit\`, then cleanup: \`git worktree remove <path> --force && git branch -D agent/<id>\`
"
        # Add ib ask guidance for root-level managers
        if [[ -z "$MANAGER" ]]; then
            IB_INSTRUCTIONS+="
ASKING THE USER QUESTIONS:
As a top-level manager, you can ask the user questions using \`ib ask \"question\"\`.
After asking, enter WAITING mode - you'll be notified when the user responds.
Use this when you need clarification on requirements or approval for a decision.
"
        fi
    else
        # Worker agents: simple communication with manager only
        IB_INSTRUCTIONS="
You are a worker agent focused on your specific task.
IMPORTANT: Always use 'ib' (not './ib') to ensure you use the current version from PATH.

To communicate with your manager: ib send $MANAGER \"your message\"

Use this to:
- Report completion or progress
- Ask questions if requirements are unclear
- Share important findings

If you get stuck or encounter a blocker:
1. Describe the specific problem you're facing
2. Send a message to your manager: ib send $MANAGER \"[STUCK] <description of problem>\"
3. Enter WAITING state - a watchdog monitors you and will notify your manager that you need help

SELF-INSPECTION:
Before completing, verify your work:
  ib diff         Check your changes vs base branch
  ib status       See your commits
"
    fi

    # Add role identifier for spawned agents
    local ROLE_MARKER=""
    if [[ "$WORKER_MODE" == true ]]; then
        ROLE_MARKER="<ittybitty>You are an IttyBitty worker agent.</ittybitty>

"
    else
        ROLE_MARKER="<ittybitty>You are an IttyBitty manager agent.</ittybitty>

"
    fi

    local PROMPT_PREFIX="${ROLE_MARKER}[AGENT CONTEXT]
$WORKTREE_INFO
$MANAGER_INFO
$PATH_ISOLATION
$GIT_WORKTREE_CONTEXT
$IB_INSTRUCTIONS
$COMPLETION_INSTRUCTIONS

[USER TASK]
$PROMPT"

    # Save the full prompt (with prefix) for reference
    local PROMPT_FILE="$AGENT_DIR/prompt.txt"
    echo "$PROMPT_PREFIX" > "$PROMPT_FILE"

    # Build claude command arguments
    # Note: We don't use --permission-mode dontAsk because we want the
    # PermissionRequest hook to fire for non-allowed tools (to log and deny)
    local CLAUDE_ARGS=""
    if [[ "$YOLO_MODE" == true ]]; then
        CLAUDE_ARGS="--dangerously-skip-permissions --permission-mode bypassPermissions"
    fi
    if [[ "$PRINT_MODE" == true ]]; then
        CLAUDE_ARGS="$CLAUDE_ARGS --print"
    fi
    if [[ -n "$ALLOW_TOOLS" ]]; then
        CLAUDE_ARGS="$CLAUDE_ARGS --allowedTools $ALLOW_TOOLS"
    fi
    if [[ -n "$DENY_TOOLS" ]]; then
        CLAUDE_ARGS="$CLAUDE_ARGS --disallowedTools $DENY_TOOLS"
    fi
    if [[ -n "$MODEL" ]]; then
        CLAUDE_ARGS="$CLAUDE_ARGS --model $MODEL"
    fi

    # Build exit handler script
    local EXIT_SCRIPT="$AGENT_DIR/exit-check.sh"
    cat > "$EXIT_SCRIPT" <<'EXITSCRIPT'
#!/bin/bash
echo ""
echo "═══════════════════════════════════════════════════════════"
echo "  Agent session ended - checking for uncommitted work..."
echo "═══════════════════════════════════════════════════════════"

# Check for uncommitted changes
if [[ -n $(git status --porcelain 2>/dev/null) ]]; then
    echo ""
    echo "⚠️  UNCOMMITTED CHANGES DETECTED"
    echo ""
    git status --short
    echo ""
    read -p "Commit these changes? [y/N] " commit_confirm
    if [[ "$commit_confirm" == [yY] || "$commit_confirm" == [yY][eE][sS] ]]; then
        read -p "Commit message: " commit_msg
        if [[ -n "$commit_msg" ]]; then
            git add -A && git commit -m "$commit_msg"
        else
            echo "No message provided, skipping commit."
        fi
    fi
fi

# Check for unpushed commits (only if remote exists)
if git remote | grep -q .; then
    local_commits=$(git log @{u}..HEAD --oneline 2>/dev/null | wc -l | tr -d ' ')
    if [[ "$local_commits" -gt 0 ]]; then
        echo ""
        echo "⚠️  UNPUSHED COMMITS: $local_commits commit(s) not pushed to remote"
        echo ""
        git log @{u}..HEAD --oneline
        echo ""
        read -p "Push to remote? [y/N] " push_confirm
        if [[ "$push_confirm" == [yY] || "$push_confirm" == [yY][eE][sS] ]]; then
            git push
        fi
    fi
fi

echo ""
echo "Agent session complete. Branch: $(git branch --show-current)"
echo "To merge this work: git checkout main && git merge $(git branch --show-current)"
echo ""
EXITSCRIPT
    chmod +x "$EXIT_SCRIPT"

    # Write a startup script that handles the prompt properly
    # Use absolute paths since tmux runs from the worktree directory
    local ABS_AGENT_DIR="$(cd "$AGENT_DIR" && pwd)"
    local ABS_PROMPT_FILE="$ABS_AGENT_DIR/prompt.txt"
    local ABS_EXIT_SCRIPT="$ABS_AGENT_DIR/exit-check.sh"
    local GIT_ROOT="$ROOT_REPO_PATH"  # Root repo path (for PATH so 'ib' is available)
    local STARTUP_SCRIPT="$AGENT_DIR/start.sh"
    cat > "$STARTUP_SCRIPT" <<EOF
#!/bin/bash
# Add git repo root to PATH so 'ib' is available
export PATH="$GIT_ROOT:\$PATH"

# Start Claude in background and capture PID
claude --session-id "$SESSION_UUID" $CLAUDE_ARGS "\$(cat '$ABS_PROMPT_FILE')" &
CLAUDE_PID=\$!

# Store PID in meta.json for recovery if needed
if command -v jq &>/dev/null; then
    TMP_FILE="\$(mktemp)"
    jq --arg pid "\$CLAUDE_PID" '. + {claude_pid: \$pid}' "$ABS_AGENT_DIR/meta.json" > "\$TMP_FILE" && mv "\$TMP_FILE" "$ABS_AGENT_DIR/meta.json"
fi

# Wait for Claude to complete
wait \$CLAUDE_PID

# Run exit check
$ABS_EXIT_SCRIPT
EOF
    chmod +x "$STARTUP_SCRIPT"

    # Ensure tmux server is running (start-server is idempotent)
    if ! tmux start-server 2>/dev/null; then
        echo "Error: could not start tmux server" >&2
        echo "Make sure tmux is installed: brew install tmux" >&2
        rm -rf "$AGENT_DIR"
        if [[ "$USE_WORKTREE" == true ]]; then
            git -C "$ROOT_REPO_PATH" worktree remove "$AGENT_DIR/repo" --force 2>/dev/null || true
            git -C "$ROOT_REPO_PATH" branch -D "$BRANCH_NAME" 2>/dev/null || true
        fi
        exit 1
    fi

    # Start tmux session with startup script (use absolute path)
    local ABS_STARTUP_SCRIPT="$ABS_AGENT_DIR/start.sh"
    if ! tmux new-session -d -x "$TMUX_WIDTH" -s "$TMUX_SESSION" -c "$WORK_PATH" "$ABS_STARTUP_SCRIPT"; then
        echo "Error: could not create tmux session '$TMUX_SESSION'" >&2
        echo "Try running: tmux kill-server && tmux start-server" >&2
        rm -rf "$AGENT_DIR"
        if [[ "$USE_WORKTREE" == true ]]; then
            git -C "$ROOT_REPO_PATH" worktree remove "$AGENT_DIR/repo" --force 2>/dev/null || true
            git -C "$ROOT_REPO_PATH" branch -D "$BRANCH_NAME" 2>/dev/null || true
        fi
        exit 1
    fi

    # Verify session was created
    if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        echo "Error: tmux session '$TMUX_SESSION' failed to start" >&2
        rm -rf "$AGENT_DIR"
        if [[ "$USE_WORKTREE" == true ]]; then
            git -C "$ROOT_REPO_PATH" worktree remove "$AGENT_DIR/repo" --force 2>/dev/null || true
            git -C "$ROOT_REPO_PATH" branch -D "$BRANCH_NAME" 2>/dev/null || true
        fi
        exit 1
    fi

    # Output the agent ID immediately so caller isn't blocked
    echo "$ID"

    # For non-yolo mode, auto-accept the workspace trust dialog in background
    # (yolo bypasses this entirely, but default and strict still see it)
    # This runs asynchronously so agent creation returns quickly
    if [[ "$YOLO_MODE" != true ]]; then
        (
            auto_accept_workspace_trust "$TMUX_SESSION"
            # Update status after initialization completes
            update_claude_status
        ) &
    else
        # For yolo mode, just update status immediately
        update_claude_status
    fi

    # Auto-spawn watchdog if agent has a manager
    if [[ -n "$MANAGER" ]]; then
        ib watchdog "$ID" > "$AGENT_DIR/watchdog.log" 2>&1 &
    fi
}

# =============================================================================
# COMMAND: list
# =============================================================================

cmd_list() {
    local MANAGER_FILTER=""
    local JSON_OUTPUT=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --manager|--parent)  MANAGER_FILTER="$2"; shift 2 ;;
            --json)    JSON_OUTPUT=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib list [options]

Show all agents and their state.

Options:
  --manager ID          Only show children of this agent
  --json                Output as JSON
  -h, --help            Show this help

Output columns:
  ID        Agent identifier
  STATE     creating, running, waiting, complete, or stopped
  AGE       Time since spawn
  MODEL     Claude model being used
  MANAGER   Manager agent ID (if any)
  PROMPT    First 40 chars of prompt

States:
  creating  Agent is initializing (Claude starting up)
  running   Agent is actively processing
  waiting   Agent is idle, may need input
  complete  Agent has signaled task completion (merge or kill to close)
  stopped   Session ended unexpectedly, needs user intervention

Orphan Detection:
  This command also checks for orphaned tmux sessions - sessions that exist
  but have no matching agent data. Orphans are shown as warnings.
EOF
                exit 0
                ;;
            *)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
        esac
    done

    # Ensure .ittybitty directory structure exists
    ensure_ittybitty_dirs

    # Check if agents directory exists (should exist after ensure_ittybitty_dirs, but may be empty)
    if [[ ! -d "$AGENTS_DIR" ]]; then
        if [[ "$JSON_OUTPUT" == true ]]; then
            echo "[]"
        else
            echo "No agents found."
        fi
        exit 0
    fi

    # Collect agent data
    local agents=()
    local agent_lines=()
    local found_any=false
    local orphaned_dirs=()

    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue

        # Track orphaned directories (no meta.json)
        if [[ ! -f "$agent_dir/meta.json" ]]; then
            orphaned_dirs+=("$(basename "$agent_dir")")
            continue
        fi

        local id="${agent_dir%/}"; id="${id##*/}"
        local meta="$agent_dir/meta.json"

        # Read metadata
        local prompt=$(read_meta_field "$meta" "prompt" "" | head -1 | cut -c1-40)
        local manager=$(read_meta_field "$meta" "manager" "")
        local created=$(read_meta_field "$meta" "created" "")
        local model=$(read_meta_field "$meta" "model" "")
        if [[ "$model" == "null" || -z "$model" ]]; then
            model="-"
        fi

        # Filter by manager if requested
        if [[ -n "$MANAGER_FILTER" && "$manager" != "$MANAGER_FILTER" ]]; then
            continue
        fi

        # Get state
        local state=$(get_state "$id")

        found_any=true

        # Format age
        local age=$(format_age "$created")

        # Handle null manager for display
        if [[ "$manager" == "null" || -z "$manager" ]]; then
            manager="-"
        fi

        # Display "unknown" as "waiting" for users
        local display_state="$state"
        if [[ "$state" == "unknown" ]]; then
            display_state="waiting"
        fi

        if [[ "$JSON_OUTPUT" == true ]]; then
            agents+=("{\"id\":\"$id\",\"state\":\"$state\",\"age\":\"$age\",\"manager\":\"$manager\",\"model\":\"$model\",\"prompt\":$(echo "$prompt" | jq -Rs .)}")
        else
            # Truncate agent name to 30 chars if needed
            local display_id="$id"
            if [[ ${#id} -gt 30 ]]; then
                display_id="${id:0:27}..."
            fi
            # Store pipe-delimited for column alignment
            agent_lines+=("${display_id}|${display_state}|${age}|${model}|${manager}|${prompt}")
        fi
    done

    # Print aligned table if not JSON
    if [[ "$JSON_OUTPUT" != true && ${#agent_lines[@]} -gt 0 ]]; then
        printf "%s\n" "${agent_lines[@]}" | column -t -s '|'
    fi

    # Check for orphaned tmux sessions (sessions without matching agent directories)
    # Only check sessions with our prefix to avoid warning about unrelated sessions
    local orphans=()
    local known_ids=()

    # Build list of known agent IDs
    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        known_ids+=("$(basename "$agent_dir")")
    done

    # Check our tmux sessions for orphans (only sessions with our prefix)
    while IFS= read -r session; do
        [[ -z "$session" ]] && continue
        # Skip sessions that don't have our prefix
        [[ "$session" != "${SESSION_PREFIX}"* ]] && continue
        # Extract agent ID from session name (strip prefix)
        local agent_id="${session#${SESSION_PREFIX}}"
        # Check if this session has a matching agent directory
        local is_known=false
        for known_id in "${known_ids[@]}"; do
            if [[ "$agent_id" == "$known_id" ]]; then
                is_known=true
                break
            fi
        done
        if [[ "$is_known" == false ]]; then
            orphans+=("$session")
        fi
    done < <(tmux list-sessions -F '#{session_name}' 2>/dev/null || true)

    # Show orphans if any
    if [[ ${#orphans[@]} -gt 0 ]]; then
        if [[ "$JSON_OUTPUT" != true ]]; then
            echo ""
            echo "WARNING: Found ${#orphans[@]} orphaned ib session(s) without agent data:"
            for orphan in "${orphans[@]}"; do
                printf "  %-20s (use 'tmux kill-session -t %s' to remove)\n" "$orphan" "$orphan"
            done
            echo ""
        fi
        found_any=true
    fi

    # Show orphaned directories if any
    if [[ ${#orphaned_dirs[@]} -gt 0 ]]; then
        if [[ "$JSON_OUTPUT" != true ]]; then
            echo ""
            echo "WARNING: Found ${#orphaned_dirs[@]} orphaned agent director(ies) without meta.json:"
            for orphan_dir in "${orphaned_dirs[@]}"; do
                printf "  %-20s (use 'rm -rf %s/%s' to remove)\n" "$orphan_dir" "$AGENTS_DIR" "$orphan_dir"
            done
            echo ""
        fi
        found_any=true
    fi

    if [[ "$JSON_OUTPUT" == true ]]; then
        echo "[$(IFS=,; echo "${agents[*]}")]"
    elif [[ "$found_any" != true ]]; then
        echo "No agents found."
    fi
}

# =============================================================================
# COMMAND: send
# =============================================================================

cmd_send() {
    local FROM_ID=""
    local TARGET_ID=""
    local MESSAGE=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --from)
                FROM_ID="$2"
                shift 2
                ;;
            -h|--help)
                cat <<EOF
Usage: ib send <id> "message"
       ib send <id> < file.txt
       echo "answer" | ib send <id>
       ib send --from <sender-id> <id> "message"

Send input to an agent's stdin.

Arguments:
  id          Agent identifier (recipient)
  message     Text to send (optional if piping)

Options:
  --from ID   Prefix message with "[sent by agent <ID>]: " (auto-detected in agent worktrees)
  -h, --help  Show this help

When run from within an agent's worktree, --from is automatically detected by
reading the agent's meta.json, so messages are prefixed with the sender's identity.

Examples:
  ib send task-a1b2 "Option 2 - just verify links"
  ib send task-a1b2 "yes"
  ib send --from worker-xyz manager-abc "I'm done with my task"
  echo "no" | ib send task-a1b2
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$TARGET_ID" ]]; then
                    TARGET_ID="$1"
                else
                    # Rest is the message
                    MESSAGE="$*"
                    break
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$TARGET_ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib send <id> \"message\"" >&2
        exit 1
    fi

    # Resolve partial ID
    local ID
    ID=$(resolve_agent_id "$TARGET_ID") || exit 1

    # Check if agent is running
    local TMUX_SESSION=$(session_name "$ID")
    if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        echo "Error: agent '$ID' is not running" >&2
        exit 1
    fi

    # Get message from remaining args or stdin
    if [[ -z "$MESSAGE" ]]; then
        if [[ ! -t 0 ]]; then
            MESSAGE=$(cat)
        else
            echo "Error: message required (as argument or via stdin)" >&2
            exit 1
        fi
    fi

    # Auto-detect if we're in an agent worktree (FROM_ID not already set)
    if [[ -z "$FROM_ID" ]]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == *"/.ittybitty/agents/"*"/repo"* ]]; then
            # Find the agent directory and read meta.json
            local agent_dir=$(echo "$current_dir" | sed 's|\(.*/.ittybitty/agents/[^/]*\)/repo.*|\1|')
            if [[ -f "$agent_dir/meta.json" ]]; then
                FROM_ID=$(read_meta_field "$agent_dir/meta.json" "id" "")
            fi
        fi
    fi

    # Prefix message if FROM_ID is set (sent by an agent)
    if [[ -n "$FROM_ID" ]]; then
        MESSAGE="[sent by agent $FROM_ID]: $MESSAGE"
    fi

    # Send to tmux session
    # Send message first, then Enter separately with a tiny delay
    # This helps when the target agent is busy processing
    tmux send-keys -t "$TMUX_SESSION" "$MESSAGE"
    sleep 0.1
    tmux send-keys -t "$TMUX_SESSION" Enter

    # Log to recipient (quiet - goes to their log only)
    if [[ -n "$FROM_ID" ]]; then
        log_agent "$ID" "Received message from $FROM_ID: ${MESSAGE#\[sent by agent $FROM_ID\]: }" --quiet
    else
        log_agent "$ID" "Received message: $MESSAGE" --quiet
    fi

    # Log to sender and print confirmation
    if [[ -n "$FROM_ID" ]]; then
        log_agent "$FROM_ID" "Sent message to $ID: ${MESSAGE#\[sent by agent $FROM_ID\]: }"
    else
        # No sender agent, just print confirmation
        echo "Sent to $ID"
    fi
}

# =============================================================================
# COMMAND: look
# =============================================================================

cmd_look() {
    local ID=""
    local LINES=50
    local FOLLOW=false
    local SHOW_ALL=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --lines)   LINES="$2"; shift 2 ;;
            --all)     SHOW_ALL=true; shift ;;
            --follow)  FOLLOW=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib look <id> [options]

Look at an agent's recent output.

Arguments:
  id              Agent identifier

Options:
  --lines N       Number of lines (default: 50)
  --all           Full scrollback history
  --follow        Watch live (like tail -f)
  -h, --help      Show this help

Examples:
  ib look task-a1b2
  ib look task-a1b2 --lines 200
  ib look task-a1b2 --follow
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib look <id> [options]" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1
    local TMUX_SESSION=$(session_name "$ID")

    # Check if agent session exists
    if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        # Try to read from log if agent is done
        if [[ -f "$AGENTS_DIR/$ID/output.log" ]]; then
            echo "=== Agent finished, showing saved output ===" >&2
            if [[ "$SHOW_ALL" == true ]]; then
                cat "$AGENTS_DIR/$ID/output.log"
            else
                tail -n "$LINES" "$AGENTS_DIR/$ID/output.log"
            fi
            exit 0
        fi
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    if [[ "$FOLLOW" == true ]]; then
        echo "Attaching to $ID (Ctrl+b d to detach)..." >&2
        tmux attach -t "$TMUX_SESSION" -r
    else
        if [[ "$SHOW_ALL" == true ]]; then
            tmux capture-pane -t "$TMUX_SESSION" -p -S -
        else
            tmux capture-pane -t "$TMUX_SESSION" -p -S -"$LINES"
        fi
    fi
}

# =============================================================================
# COMMAND: status
# =============================================================================

cmd_status() {
    local ID=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib status <id>

Show git status of an agent's work compared to main branch.

Displays:
- Commits made by the agent (hash + message)
- Uncommitted changes in worktree
- Files changed summary

Arguments:
  id              Agent identifier

Examples:
  ib status task-a1b2
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib status <id>" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"
    local BRANCH_NAME="agent/$ID"

    # Check if agent exists
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Determine target branch for comparison
    local TARGET_BRANCH=""
    if git show-ref --verify --quiet refs/heads/main; then
        TARGET_BRANCH="main"
    elif git show-ref --verify --quiet refs/heads/master; then
        TARGET_BRANCH="master"
    else
        TARGET_BRANCH="HEAD"
    fi

    # Check if worktree exists
    local WORKTREE_PATH="$AGENT_DIR/repo"
    if [[ ! -d "$WORKTREE_PATH" ]]; then
        echo "Agent '$ID' has no worktree (created with --no-worktree)"
        echo ""
        # Show branch commits if branch exists
        if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
            # Use merge-base to compare only agent's changes
            local MERGE_BASE
            MERGE_BASE=$(git merge-base "$TARGET_BRANCH" "$BRANCH_NAME")
            local commit_count=$(git log "$MERGE_BASE..$BRANCH_NAME" --oneline 2>/dev/null | wc -l | tr -d ' ')
            if [[ "$commit_count" -gt 0 ]]; then
                echo "Commits on $BRANCH_NAME (vs $TARGET_BRANCH):"
                git log "$MERGE_BASE..$BRANCH_NAME" --oneline
            else
                echo "No commits on $BRANCH_NAME relative to $TARGET_BRANCH"
            fi
        fi
        exit 0
    fi

    echo "Agent: $ID"
    echo "Branch: $BRANCH_NAME"
    echo "Worktree: $WORKTREE_PATH"
    echo ""

    # Find merge-base to avoid showing unrelated changes from target branch
    local MERGE_BASE=""
    if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        MERGE_BASE=$(git merge-base "$TARGET_BRANCH" "$BRANCH_NAME")
    fi

    # Show commits
    if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        local commit_count=$(git log "$MERGE_BASE..$BRANCH_NAME" --oneline 2>/dev/null | wc -l | tr -d ' ')
        if [[ "$commit_count" -gt 0 ]]; then
            echo "═══ Commits ($commit_count) vs $TARGET_BRANCH ═══"
            git log "$MERGE_BASE..$BRANCH_NAME" --format="  %h %s"
            echo ""
        else
            echo "═══ No commits vs $TARGET_BRANCH ═══"
            echo ""
        fi
    fi

    # Show uncommitted changes
    local uncommitted=$(git -C "$WORKTREE_PATH" status --porcelain 2>/dev/null)
    if [[ -n "$uncommitted" ]]; then
        echo "═══ Uncommitted Changes ═══"
        git -C "$WORKTREE_PATH" status --short
        echo ""
    fi

    # Show file change summary
    if [[ -n "$MERGE_BASE" ]]; then
        local files_changed=$(git diff --stat "$MERGE_BASE..$BRANCH_NAME" 2>/dev/null | tail -1)
        if [[ -n "$files_changed" && "$files_changed" != *"0 files changed"* ]]; then
            echo "═══ Files Changed ═══"
            echo "  $files_changed"
        fi
    fi
}

# =============================================================================
# COMMAND: diff
# =============================================================================

cmd_diff() {
    local ID=""
    local STAT_ONLY=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --stat)    STAT_ONLY=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib diff <id> [options]

Show the full diff of an agent's work compared to the merge-base with main.
This shows only the agent's changes, not unrelated changes from main branch.

Arguments:
  id              Agent identifier

Options:
  --stat          Show diffstat summary only
  -h, --help      Show this help

Examples:
  ib diff task-a1b2
  ib diff task-a1b2 --stat
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib diff <id>" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"
    local BRANCH_NAME="agent/$ID"

    # Check if agent exists
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Determine target branch for comparison
    local TARGET_BRANCH=""
    if git show-ref --verify --quiet refs/heads/main; then
        TARGET_BRANCH="main"
    elif git show-ref --verify --quiet refs/heads/master; then
        TARGET_BRANCH="master"
    else
        TARGET_BRANCH="HEAD"
    fi

    # Check if branch exists
    if ! git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        echo "Error: branch '$BRANCH_NAME' does not exist" >&2
        exit 1
    fi

    # Find merge-base to avoid showing unrelated changes from target branch
    local MERGE_BASE
    MERGE_BASE=$(git merge-base "$TARGET_BRANCH" "$BRANCH_NAME")

    if [[ "$STAT_ONLY" == true ]]; then
        git diff --stat "$MERGE_BASE..$BRANCH_NAME"
    else
        git diff "$MERGE_BASE..$BRANCH_NAME"
    fi
}

# =============================================================================
# COMMAND: info
# =============================================================================

cmd_info() {
    local ID=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib info <id>

Display the meta.json contents for an agent.

Shows agent metadata including:
- Agent name and session ID
- Manager relationship
- Model configuration
- Creation timestamp
- Prompt and other configuration

Arguments:
  id              Agent identifier

Examples:
  ib info task-a1b2
  ib info myagent
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib info <id>" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"
    local META_FILE="$AGENT_DIR/meta.json"

    # Check if agent exists
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Check if meta.json exists
    if [[ ! -f "$META_FILE" ]]; then
        echo "Error: meta.json not found for agent '$ID'" >&2
        exit 1
    fi

    # Output the meta.json contents
    cat "$META_FILE"
}

# =============================================================================
# COMMAND: kill
# =============================================================================

cmd_kill() {
    local ID=""
    local FORCE=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)   FORCE=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib kill <id> [options]

Close an agent without merging its work. Removes the agent's session,
worktree, branch, and data directory.

Arguments:
  id              Agent identifier

Options:
  --force         Don't ask for confirmation
  -h, --help      Show this help

Examples:
  ib kill task-a1b2
  ib kill task-a1b2 --force
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib kill <id> [options]" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"
    local TMUX_SESSION=$(session_name "$ID")

    # Check if agent exists at all
    if [[ ! -d "$AGENT_DIR" ]] && ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Confirm if not forced
    if [[ "$FORCE" != true ]]; then
        # If running as an agent, error instead of blocking on interactive prompt
        if is_running_as_agent; then
            echo "Error: Cannot use interactive confirmation in agent mode." >&2
            echo "Use: ib kill $ID --force" >&2
            exit 1
        fi
        local confirm
        read -p "Kill agent '$ID' and remove all data? [y/N] " confirm
        if [[ "$confirm" != [yY] && "$confirm" != [yY][eE][sS] ]]; then
            echo "Cancelled."
            exit 0
        fi
    fi

    # Teardown the agent (logs, kills, archives, removes)
    teardown_agent "$ID" "" "Agent killed"
    echo "Closed agent: $ID"

    # Update .ittybitty/STATUS.md for CLAUDE.md status display
    update_claude_status

    # Scan for any orphaned Claude processes after cleanup
    scan_and_kill_orphans
}

# =============================================================================
# COMMAND: nuke (undocumented safety switch)
# =============================================================================

cmd_nuke() {
    local FORCE=false
    local TARGET_ID=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)   FORCE=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib nuke [<id>] [options]

EMERGENCY STOP: Kill agents without merging.

Without ID: Kills ALL active agents immediately.
With ID:    Kills the specified agent and ALL its descendants recursively.

Arguments:
  id              Agent ID to nuke (along with all its children)

Options:
  --force         Don't ask for confirmation
  -h, --help      Show this help

Examples:
  ib nuke                    # Kill ALL agents
  ib nuke manager-agent      # Kill manager-agent and all its children/grandchildren
  ib nuke manager-agent --force
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$TARGET_ID" ]]; then
                    TARGET_ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    # Ensure .ittybitty directory structure exists
    ensure_ittybitty_dirs

    # Check if agents directory exists (should exist after ensure_ittybitty_dirs, but may be empty)
    if [[ ! -d "$AGENTS_DIR" ]]; then
        echo "No agents found."
        exit 0
    fi

    # If TARGET_ID specified, resolve it and find all descendants
    local agents_to_kill=()
    if [[ -n "$TARGET_ID" ]]; then
        # Resolve partial ID
        TARGET_ID=$(resolve_agent_id "$TARGET_ID") || exit 1

        # Check if this is a worker agent (has no children)
        local AGENT_DIR="$AGENTS_DIR/$TARGET_ID"
        local is_worker=$(read_meta_field "$AGENT_DIR/meta.json" "worker" "false")

        # Count children using get_children helper
        local children_list=$(get_children "$TARGET_ID" "all")
        local child_count=$(echo "$children_list" | wc -w | tr -d ' ')

        # Reject if this is a worker with no children
        if [[ "$is_worker" == "true" && $child_count -eq 0 ]]; then
            echo "Error: '$TARGET_ID' is a worker agent with no descendants." >&2
            echo "Use 'ib kill $TARGET_ID' instead to close a single agent." >&2
            echo "" >&2
            echo "The 'nuke' command is for killing manager agents along with all their descendants." >&2
            exit 1
        fi

        # Get all descendants using helper function
        agents_to_kill=($(get_descendants_recursive "$TARGET_ID"))
        local agent_count=${#agents_to_kill[@]}

        if [[ $agent_count -eq 0 ]]; then
            echo "No agents found to kill."
            exit 0
        fi
    else
        # No TARGET_ID - kill all agents
        local agent_count=0
        for agent_dir in "$AGENTS_DIR"/*/; do
            [[ -d "$agent_dir" ]] || continue
            [[ -f "$agent_dir/meta.json" ]] || continue
            agents_to_kill+=($(basename "$agent_dir"))
            ((agent_count++))
        done

        # Note: Don't exit early if no agents found - continue to check for orphaned sessions
    fi

    # Confirm if not forced and there are agents to kill
    if [[ "$FORCE" != true && ${#agents_to_kill[@]} -gt 0 ]]; then
        # If running as an agent, error instead of blocking on interactive prompt
        if is_running_as_agent; then
            echo "Error: Cannot use interactive confirmation in agent mode." >&2
            echo "Use: ib nuke --force" >&2
            exit 1
        fi
        local confirm
        if [[ -n "$TARGET_ID" ]]; then
            echo "WARNING: This will kill agent '$TARGET_ID' and ${#agents_to_kill[@]} total agent(s) (including descendants) without merging!"
            echo "Agents to be killed:"
            for id in "${agents_to_kill[@]}"; do
                echo "  - $id"
            done
        else
            echo "WARNING: This will kill ALL ${#agents_to_kill[@]} agent(s) without merging!"
        fi
        read -p "Are you sure? [y/N] " confirm
        if [[ "$confirm" != [yY] && "$confirm" != [yY][eE][sS] ]]; then
            echo "Cancelled."
            exit 0
        fi
    fi

    # Kill agents if any found
    if [[ ${#agents_to_kill[@]} -gt 0 ]]; then
        echo "Killing ${#agents_to_kill[@]} agent(s)..."
    fi
    local killed=0
    local failed=0

    # Kill each agent in the list
    for id in "${agents_to_kill[@]}"; do
        [[ -d "$AGENTS_DIR/$id" ]] || continue

        echo -n "  Killing $id... "

        # Teardown the agent (quiet mode for batch)
        if teardown_agent "$id" "--quiet" "Agent nuked"; then
            echo "✓"
            ((killed++))
        else
            echo "✗"
            ((failed++))
        fi
    done

    # Clean up orphaned tmux sessions (sessions without agent directories)
    local orphans=()
    local known_ids=()

    # Build list of remaining known agent IDs
    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        known_ids+=("$(basename "$agent_dir")")
    done

    # Check our tmux sessions for orphans (only sessions with our prefix)
    while IFS= read -r session; do
        [[ -z "$session" ]] && continue
        # Skip sessions that don't have our prefix
        [[ "$session" != "${SESSION_PREFIX}"* ]] && continue
        # Extract agent ID from session name (strip prefix)
        local agent_id="${session#${SESSION_PREFIX}}"
        # Check if this session has a matching agent directory
        local is_known=false
        for known_id in "${known_ids[@]}"; do
            if [[ "$agent_id" == "$known_id" ]]; then
                is_known=true
                break
            fi
        done
        if [[ "$is_known" == false ]]; then
            orphans+=("$session")
        fi
    done < <(tmux list-sessions -F '#{session_name}' 2>/dev/null || true)

    # Kill orphaned sessions if any found
    local orphans_killed=0
    if [[ ${#orphans[@]} -gt 0 ]]; then
        echo ""
        echo "Cleaning up ${#orphans[@]} orphaned tmux session(s)..."
        for orphan in "${orphans[@]}"; do
            echo -n "  Killing $orphan... "
            if tmux kill-session -t "$orphan" 2>/dev/null; then
                echo "✓"
                ((orphans_killed++))
            else
                echo "✗"
            fi
        done
    fi

    # Scan for any orphaned Claude processes after all cleanup
    if [[ $killed -gt 0 || $orphans_killed -gt 0 ]]; then
        echo ""
        echo "Scanning for orphaned Claude processes..."
        scan_and_kill_orphans
    fi

    # Print results
    if [[ $killed -eq 0 && $orphans_killed -eq 0 ]]; then
        echo "No agents or orphaned sessions found."
    else
        echo ""
        if [[ $killed -gt 0 && $orphans_killed -gt 0 ]]; then
            echo "Results: $killed agent(s) killed, $orphans_killed orphaned session(s) cleaned up, $failed failed"
        elif [[ $killed -gt 0 ]]; then
            echo "Results: $killed agent(s) killed, $failed failed"
        elif [[ $orphans_killed -gt 0 ]]; then
            echo "Results: $orphans_killed orphaned session(s) cleaned up"
        fi
    fi

    if [[ $failed -gt 0 ]]; then
        exit 1
    fi
}

# =============================================================================
# COMMAND: resume
# =============================================================================

cmd_resume() {
    local ID=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib resume <id>

Resume a stopped agent session.

When an agent's tmux session ends unexpectedly (crash, reboot, etc.),
the Claude conversation history is preserved. This command restarts
the tmux session and resumes the Claude conversation where it left off.

Arguments:
  id              Agent identifier

Requirements:
  - Agent must exist (directory in .ittybitty/agents/)
  - Agent must be stopped (no active tmux session)
  - Agent must have a session_id in meta.json

Examples:
  ib resume task-a1b2
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib resume <id>" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"

    # Check if agent exists
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Check agent state - must be stopped
    local state=$(get_state "$ID")
    if [[ "$state" != "stopped" ]]; then
        echo "Error: agent '$ID' is not stopped (current state: $state)" >&2
        case "$state" in
            creating)
                echo "Agent is still initializing. Wait a moment for Claude to start." >&2
                ;;
            running)
                echo "Agent is actively processing. Use 'ib look $ID' to view output." >&2
                ;;
            waiting)
                echo "Agent is waiting for input. Use 'ib send $ID \"message\"' to continue." >&2
                ;;
            complete)
                echo "Agent has completed. Use 'ib merge $ID' or 'ib kill $ID' to close it." >&2
                ;;
        esac
        exit 1
    fi

    # Read session ID from meta.json
    local META_FILE="$AGENT_DIR/meta.json"
    if [[ ! -f "$META_FILE" ]]; then
        echo "Error: meta.json not found for agent '$ID'" >&2
        exit 1
    fi

    local SESSION_UUID=$(read_meta_field "$META_FILE" "session_id" "")
    if [[ -z "$SESSION_UUID" || "$SESSION_UUID" == "null" ]]; then
        echo "Error: no session_id found in meta.json" >&2
        echo "This agent was created before resume support was added." >&2
        exit 1
    fi

    # Read model from meta.json if set
    local MODEL=$(read_meta_field "$META_FILE" "model" "")
    if [[ "$MODEL" == "null" ]]; then
        MODEL=""
    fi

    # Determine working directory
    local WORK_PATH="$AGENT_DIR/repo"
    if [[ ! -d "$WORK_PATH" ]]; then
        # No worktree, use git root
        WORK_PATH="$(pwd)"
    fi

    # Read yolo mode from original start.sh to preserve settings
    local YOLO_MODE=false
    if [[ -f "$AGENT_DIR/start.sh" ]] && grep -q "dangerously-skip-permissions" "$AGENT_DIR/start.sh"; then
        YOLO_MODE=true
    fi

    # Build claude args for resume
    # Note: We don't use --permission-mode dontAsk because we want the
    # PermissionRequest hook to fire for non-allowed tools (to log and deny)
    local CLAUDE_ARGS=""
    if [[ "$YOLO_MODE" == true ]]; then
        CLAUDE_ARGS="--dangerously-skip-permissions --permission-mode bypassPermissions"
    fi
    if [[ -n "$MODEL" ]]; then
        CLAUDE_ARGS="$CLAUDE_ARGS --model $MODEL"
    fi

    # Get git root for PATH
    local GIT_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"

    # Write a resume script
    local RESUME_SCRIPT="$AGENT_DIR/resume.sh"
    local ABS_AGENT_DIR="$(cd "$AGENT_DIR" && pwd)"
    local ABS_EXIT_SCRIPT="$ABS_AGENT_DIR/exit-check.sh"
    cat > "$RESUME_SCRIPT" <<EOF
#!/bin/bash
# Add git repo root to PATH so 'ib' is available
export PATH="$GIT_ROOT:\$PATH"

# Start Claude in background and capture PID
claude --resume "$SESSION_UUID" $CLAUDE_ARGS &
CLAUDE_PID=\$!

# Store PID in meta.json for recovery if needed
if command -v jq &>/dev/null; then
    TMP_FILE="\$(mktemp)"
    jq --arg pid "\$CLAUDE_PID" '. + {claude_pid: \$pid}' "$ABS_AGENT_DIR/meta.json" > "\$TMP_FILE" && mv "\$TMP_FILE" "$ABS_AGENT_DIR/meta.json"
fi

# Wait for Claude to complete
wait \$CLAUDE_PID

# Run exit check
$ABS_EXIT_SCRIPT
EOF
    chmod +x "$RESUME_SCRIPT"

    # Ensure tmux server is running
    if ! tmux start-server 2>/dev/null; then
        echo "Error: could not start tmux server" >&2
        exit 1
    fi

    # Start tmux session with resume script
    local ABS_RESUME_SCRIPT="$(cd "$AGENT_DIR" && pwd)/resume.sh"
    local TMUX_SESSION=$(session_name "$ID")
    if ! tmux new-session -d -x "$TMUX_WIDTH" -s "$TMUX_SESSION" -c "$WORK_PATH" "$ABS_RESUME_SCRIPT"; then
        echo "Error: could not create tmux session '$TMUX_SESSION'" >&2
        exit 1
    fi

    # For non-yolo mode, auto-accept the workspace trust dialog
    if [[ "$YOLO_MODE" != true ]]; then
        auto_accept_workspace_trust "$TMUX_SESSION"
    fi

    # Log and print the resume
    log_agent "$ID" "Agent resumed"
    echo "Use 'ib look $ID' to view output"
}

# =============================================================================
# COMMAND: merge
# =============================================================================

cmd_merge() {
    local ID=""
    local TARGET_BRANCH=""
    local FORCE=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --into)    TARGET_BRANCH="$2"; shift 2 ;;
            --force)   FORCE=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib merge <id> [options]

Merge an agent's work and close the agent.
Removes the agent's session, worktree, branch, and data directory.

When run by an agent (manager merging worker), merges into current branch.
When run from root repo, merges into main/master.

Arguments:
  id              Agent identifier

Options:
  --into BRANCH   Target branch to merge into (default: current branch if agent, main/master if root)
  --force         Don't ask for confirmation
  -h, --help      Show this help

The merge command:
1. Checks for uncommitted changes in the agent's worktree
2. Merges the agent's branch into target
3. Kills the agent's Claude process and tmux session
4. Cleans up the worktree, branch, and agent data

Examples:
  ib merge task-a1b2
  ib merge task-a1b2 --into develop
  ib merge task-a1b2 --force
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib merge <id> [options]" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"
    local BRANCH_NAME="agent/$ID"
    local TMUX_SESSION=$(session_name "$ID")

    # Check if agent exists
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Load config and warn about PR settings
    load_config
    if [[ "$CONFIG_CREATE_PRS" == "true" ]]; then
        if ! command -v gh &>/dev/null; then
            echo "Warning: createPullRequests is enabled but 'gh' CLI is not installed" >&2
        fi
        if [[ -z $(git remote 2>/dev/null | head -1) ]]; then
            echo "Warning: createPullRequests is enabled but no git remote is configured" >&2
        fi
    fi

    # Check if worktree exists
    local WORKTREE_PATH="$AGENT_DIR/repo"
    if [[ ! -d "$WORKTREE_PATH" ]]; then
        echo "Error: agent '$ID' has no worktree (was created with --no-worktree?)" >&2
        exit 1
    fi

    # Check if we're trying to merge from within the agent's own worktree
    local CURRENT_DIR=$(pwd)
    if [[ "$CURRENT_DIR" == "$WORKTREE_PATH"* ]]; then
        echo "Error: Cannot merge agent from within its own worktree. The merge will delete the directory you are currently in. Please run this command from outside the agent worktree." >&2
        exit 1
    fi

    # Check for uncommitted changes in the worktree
    if [[ -n $(git -C "$WORKTREE_PATH" status --porcelain 2>/dev/null) ]]; then
        echo "Error: agent '$ID' has uncommitted changes:" >&2
        git -C "$WORKTREE_PATH" status --short >&2
        echo "" >&2
        echo "Please commit or discard changes first, or use 'ib send $ID' to ask the agent to commit." >&2
        exit 1
    fi

    # Determine target branch
    if [[ -z "$TARGET_BRANCH" ]]; then
        # Try to use current branch first (works for both agents and user-level Claude)
        TARGET_BRANCH=$(git branch --show-current 2>/dev/null) || true

        if [[ -z "$TARGET_BRANCH" ]]; then
            # Detached HEAD or couldn't determine branch - fall back to main/master
            if git show-ref --verify --quiet refs/heads/main; then
                TARGET_BRANCH="main"
            elif git show-ref --verify --quiet refs/heads/master; then
                TARGET_BRANCH="master"
            else
                echo "Error: could not determine target branch" >&2
                echo "You appear to be in detached HEAD state with no main or master branch." >&2
                echo "Use --into BRANCH to specify target branch" >&2
                exit 1
            fi
        fi
    fi

    # Check if agent branch exists
    if ! git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        echo "Error: branch '$BRANCH_NAME' does not exist" >&2
        exit 1
    fi

    # Pre-merge conflict check: detect conflicts BEFORE attempting merge
    # This allows managers to ask workers to resolve conflicts themselves
    local conflict_files
    if ! conflict_files=$(check_merge_conflicts "$TARGET_BRANCH" "$BRANCH_NAME"); then
        echo "Error: Merge conflict detected!" >&2
        echo "" >&2
        echo "The agent's branch '$BRANCH_NAME' has conflicts with '$TARGET_BRANCH'." >&2
        if [[ -n "$conflict_files" ]]; then
            echo "" >&2
            echo "Conflicting files:" >&2
            echo "$conflict_files" | sed 's/^/  - /' >&2
        fi
        echo "" >&2
        echo "Ask the agent to resolve conflicts:" >&2
        echo "  ib send $ID \"Please merge $TARGET_BRANCH into your branch and resolve any conflicts, then say I HAVE COMPLETED THE GOAL\"" >&2
        echo "" >&2
        echo "The agent should run these commands in their worktree:" >&2
        echo "  git fetch origin $TARGET_BRANCH" >&2
        echo "  git merge origin/$TARGET_BRANCH  # or: git merge $TARGET_BRANCH" >&2
        echo "  # ... resolve conflicts ..." >&2
        echo "  git add . && git commit" >&2
        echo "" >&2
        echo "After the agent resolves conflicts, retry: ib merge $ID --force" >&2
        log_agent "$ID" "Pre-merge conflict check failed - conflicts detected with $TARGET_BRANCH"
        exit 1
    fi

    # Show what will be merged
    local commit_count=$(git log "$TARGET_BRANCH..$BRANCH_NAME" --oneline 2>/dev/null | wc -l | tr -d ' ')
    if [[ "$commit_count" -eq 0 ]]; then
        echo "Nothing to merge: $BRANCH_NAME has no new commits relative to $TARGET_BRANCH"
        echo "Proceeding with cleanup..."
    else
        echo "Will merge $commit_count commit(s) from $BRANCH_NAME into $TARGET_BRANCH:"
        git log "$TARGET_BRANCH..$BRANCH_NAME" --oneline
        echo ""
    fi

    # Confirm if not forced
    if [[ "$FORCE" != true && "$commit_count" -gt 0 ]]; then
        # If running as an agent, error instead of blocking on interactive prompt
        if is_running_as_agent; then
            echo "Error: Cannot use interactive confirmation in agent mode." >&2
            echo "Use: ib merge $ID --force" >&2
            exit 1
        fi
        local confirm
        read -p "Proceed with merge? [y/N] " confirm
        if [[ "$confirm" != [yY] && "$confirm" != [yY][eE][sS] ]]; then
            echo "Cancelled."
            exit 0
        fi
    fi

    # Log the start of merge
    log_agent "$ID" "Starting merge of $BRANCH_NAME into $TARGET_BRANCH ($commit_count commits)"

    # Perform the merge FIRST (before killing anything)
    # This ensures we don't leave agents in limbo if merge fails
    if [[ "$commit_count" -gt 0 ]]; then
        log_agent "$ID" "Checking out $TARGET_BRANCH..."
        local checkout_error
        checkout_error=$(git checkout "$TARGET_BRANCH" 2>&1) || {
            echo "Error: could not checkout $TARGET_BRANCH" >&2
            echo "$checkout_error" >&2
            log_agent "$ID" "ERROR: Failed to checkout $TARGET_BRANCH - $checkout_error"
            if [[ "$checkout_error" == *"already used by worktree"* ]]; then
                echo "Hint: Branch is checked out in another worktree. Try merging from the root repo." >&2
                log_agent "$ID" "HINT: Branch is checked out elsewhere - merge from root repo or use --into"
            fi
            exit 1
        }
        log_agent "$ID" "Merging $BRANCH_NAME..."
        local merge_error
        merge_error=$(git merge "$BRANCH_NAME" -m "Merge agent $ID work" 2>&1) || {
            echo "Error: merge failed" >&2
            echo "$merge_error" >&2
            log_agent "$ID" "ERROR: Merge failed - $merge_error"
            if [[ "$merge_error" == *"CONFLICT"* ]]; then
                echo "Hint: Resolve conflicts manually, then run: git add . && git commit" >&2
                log_agent "$ID" "HINT: Merge conflicts detected - resolve manually"
            fi
            exit 1
        }
        log_agent "$ID" "Merge completed successfully"
    fi

    # Capture tmux output BEFORE killing session (so archive has it)
    log_agent "$ID" "Capturing tmux output..."
    if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        tmux capture-pane -t "$TMUX_SESSION" -p -S - > "$AGENT_DIR/output.log" 2>/dev/null || true
    fi

    # Kill Claude process gracefully before killing tmux session
    log_agent "$ID" "Terminating Claude process..."
    if kill_agent_process "$ID"; then
        log_agent "$ID" "Claude process terminated"
    else
        log_agent "$ID" "No Claude process found (already stopped?)"
    fi

    # Kill the agent session if still running
    log_agent "$ID" "Stopping tmux session..."
    if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        tmux kill-session -t "$TMUX_SESSION"
        log_agent "$ID" "Tmux session stopped"
    else
        log_agent "$ID" "No tmux session found (already stopped?)"
    fi

    # Cleanup worktree
    log_agent "$ID" "Removing worktree..."
    git worktree remove "$WORKTREE_PATH" --force 2>/dev/null || {
        log_agent "$ID" "Warning: could not remove worktree cleanly, removing directory manually"
        rm -rf "$WORKTREE_PATH"
    }
    log_agent "$ID" "Worktree removed"

    # Delete the branch
    log_agent "$ID" "Deleting branch $BRANCH_NAME..."
    if git branch -D "$BRANCH_NAME" 2>/dev/null; then
        log_agent "$ID" "Branch deleted: $BRANCH_NAME"
    else
        log_agent "$ID" "Warning: could not delete branch $BRANCH_NAME"
    fi

    # Final log before archive (this is the last log that will be captured)
    log_agent "$ID" "Merge complete - archiving and closing agent"

    # Archive output (captures complete log including the message above)
    archive_agent_output "$ID"

    # Remove agent directory last (no more logging possible after this)
    rm -rf "$AGENT_DIR"

    echo "Closed agent: $ID"

    # Update .ittybitty/STATUS.md for CLAUDE.md status display
    update_claude_status

    # Scan for any orphaned Claude processes after cleanup
    scan_and_kill_orphans
}

# =============================================================================
# COMMAND: merge-check
# =============================================================================

cmd_merge_check() {
    local ID=""
    local TARGET_BRANCH=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --into)    TARGET_BRANCH="$2"; shift 2 ;;
            -h|--help)
                cat <<EOF
Usage: ib merge-check <id> [options]

Check if merging an agent's branch would succeed without conflicts.
Does NOT perform the actual merge.

Arguments:
  id              Agent identifier

Options:
  --into BRANCH   Target branch to check merge against (default: current branch if agent, main/master if root)
  -h, --help      Show this help

Exit codes:
  0  Merge would succeed (no conflicts)
  1  Merge would have conflicts

Examples:
  ib merge-check task-a1b2
  ib merge-check task-a1b2 --into develop
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib merge-check <id> [options]" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"
    local BRANCH_NAME="agent/$ID"

    # Check if agent exists
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Determine target branch (same logic as cmd_merge)
    if [[ -z "$TARGET_BRANCH" ]]; then
        # Try to use current branch first (works for both agents and user-level Claude)
        TARGET_BRANCH=$(git branch --show-current 2>/dev/null) || true

        if [[ -z "$TARGET_BRANCH" ]]; then
            # Detached HEAD or couldn't determine branch - fall back to main/master
            if git show-ref --verify --quiet refs/heads/main; then
                TARGET_BRANCH="main"
            elif git show-ref --verify --quiet refs/heads/master; then
                TARGET_BRANCH="master"
            else
                echo "Error: could not determine target branch" >&2
                echo "You appear to be in detached HEAD state with no main or master branch." >&2
                echo "Use --into BRANCH to specify target branch" >&2
                exit 1
            fi
        fi
    fi

    # Check if agent branch exists
    if ! git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        echo "Error: branch '$BRANCH_NAME' does not exist" >&2
        exit 1
    fi

    # Check for merge conflicts
    local conflict_files
    if conflict_files=$(check_merge_conflicts "$TARGET_BRANCH" "$BRANCH_NAME"); then
        echo "Merge would succeed: '$BRANCH_NAME' into '$TARGET_BRANCH'"
        exit 0
    else
        echo "Merge would have conflicts: '$BRANCH_NAME' into '$TARGET_BRANCH'"
        if [[ -n "$conflict_files" ]]; then
            echo ""
            echo "Conflicting files:"
            echo "$conflict_files" | sed 's/^/  - /'
        fi
        exit 1
    fi
}

# =============================================================================
# COMMAND: hooks (dispatcher)
# =============================================================================

cmd_hooks() {
    local SUBCMD="$1"
    shift 2>/dev/null || true

    case "$SUBCMD" in
        agent-status)
            cmd_hooks_agent_status "$@"
            ;;
        agent-path)
            cmd_hooks_agent_path "$@"
            ;;
        main-path)
            cmd_hooks_main_path "$@"
            ;;
        status)
            cmd_hooks_status "$@"
            ;;
        install)
            cmd_hooks_install "$@"
            ;;
        uninstall)
            cmd_hooks_uninstall "$@"
            ;;
        -h|--help|"")
            cat <<EOF
Usage: ib hooks <subcommand> [options]

Subcommands:
  status       Check if main repo hooks are installed
  install      Install PreToolUse hook to main repo
  uninstall    Remove hook from main repo

Agent hooks (internal, used by spawned agents):
  agent-status <id>   Stop hook - nudges agent, notifies managers
  agent-path <id>     PreToolUse - blocks agent file access outside worktree
  main-path           PreToolUse - blocks main Claude from cd into worktrees

Run 'ib hooks <subcommand> --help' for subcommand-specific help.
EOF
            exit 0
            ;;
        *)
            echo "Error: Unknown hooks subcommand: $SUBCMD" >&2
            echo "Run 'ib hooks --help' for usage." >&2
            exit 1
            ;;
    esac
}

# =============================================================================
# COMMAND: hooks agent-status (formerly hook-status)
# =============================================================================

cmd_hooks_agent_status() {
    local ID="$1"

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        exit 1
    fi

    # Resolve partial ID
    local RESOLVED_ID
    if ! RESOLVED_ID=$(resolve_agent_id "$ID" 2>&1); then
        echo "[hook] Resolution failed for '$ID': $RESOLVED_ID" >&2
        exit 1
    fi
    ID="$RESOLVED_ID"

    local state=$(get_state "$ID")
    log_agent "$ID" "[hook] Stop hook triggered, state=$state" --quiet

    local TMUX_SESSION=$(session_name "$ID")

    # Get agent's manager (if any) for worker notifications
    local AGENT_DIR="$AGENTS_DIR/$ID"
    local manager=""
    if [[ -f "$AGENT_DIR/meta.json" ]]; then
        manager=$(read_meta_field "$AGENT_DIR/meta.json" "manager" "")
        [[ "$manager" == "null" ]] && manager=""
    fi

    if [[ "$state" == "unknown" ]]; then
        log_agent "$ID" "[hook] State unknown, sending nudge prompt" --quiet
        local prompt="When you stop working, you must always end your message with either 'WAITING' or 'I HAVE COMPLETED THE GOAL'. IMPORTANT: Write your summary or status update FIRST, then put the status phrase as your FINAL line - nothing should come after it. If you are waiting for input or have nothing more to do without further instruction, say 'WAITING'. If you have completed your goal, say 'I HAVE COMPLETED THE GOAL'. If you have neither completed your goal nor are waiting, then please resume your work."

        tmux send-keys -t "$TMUX_SESSION" "$prompt"
        sleep 0.1
        tmux send-keys -t "$TMUX_SESSION" Enter
    elif [[ "$state" == "complete" ]]; then
        # Check for uncommitted changes in the agent's worktree
        local worktree_path="$AGENT_DIR/repo"
        if [[ -d "$worktree_path" ]]; then
            local uncommitted_changes
            uncommitted_changes=$(git -C "$worktree_path" status --porcelain 2>/dev/null)
            if [[ -n "$uncommitted_changes" ]]; then
                log_agent "$ID" "[hook] Agent has uncommitted changes, sending reminder" --quiet
                local commit_prompt="You have uncommitted changes. Please commit your work using git add && git commit before completing."
                tmux send-keys -t "$TMUX_SESSION" "$commit_prompt"
                sleep 0.1
                tmux send-keys -t "$TMUX_SESSION" Enter
                # Don't proceed with other checks - let agent commit first
                update_claude_status
                echo "$state"
                return
            fi
        fi

        # For workers: notify manager immediately
        if [[ -n "$manager" ]]; then
            log_agent "$ID" "[hook] Notifying manager $manager: just completed"
            ib send "$manager" "[hook]: Your subtask $ID just completed"
        else
            # For managers: check for unfinished children
            local unfinished=$(get_unfinished_children "$ID")
            if [[ -n "$unfinished" ]]; then
                local child_count=$(echo "$unfinished" | wc -w | tr -d ' ')
                local child_list=$(echo "$unfinished" | tr ' ' ', ')
                log_agent "$ID" "[hook] Complete but has $child_count unfinished children ($child_list), sending reminder" --quiet
                local prompt="You have $child_count unfinished sub-agent(s) that need attention: $child_list. Before you can complete, you must merge or kill each sub-agent using 'ib merge <id>' or 'ib kill <id>'. Use 'ib list' to check their status, 'ib look <id>' to see their output, 'ib status <id>' for their commits, and 'ib diff <id>' to review their changes."

                tmux send-keys -t "$TMUX_SESSION" "$prompt"
                sleep 0.1
                tmux send-keys -t "$TMUX_SESSION" Enter
            else
                log_agent "$ID" "[hook] Complete with no manager and no unfinished children, no action" --quiet
            fi
        fi
    elif [[ "$state" == "waiting" ]]; then
        # For workers: notify manager immediately
        if [[ -n "$manager" ]]; then
            log_agent "$ID" "[hook] Notifying manager $manager: now waiting"
            ib send "$manager" "[hook]: Your subtask $ID is now waiting for input"
        else
            log_agent "$ID" "[hook] Waiting with no manager, no action" --quiet
        fi
    else
        # State is running, stopped, or other - no action needed
        log_agent "$ID" "[hook] State is $state, no action needed" --quiet
    fi

    # Update .ittybitty/STATUS.md for CLAUDE.md status display
    update_claude_status

    # Always print the state for debugging
    echo "$state"
}

# =============================================================================
# COMMAND: hooks agent-path (formerly hook-check-path)
# =============================================================================

# PreToolUse hook to enforce agent path isolation
# Blocks file access outside the agent's worktree
cmd_hooks_agent_path() {
    local ID="$1"

    # Helper to output JSON with permissionDecision
    output_decision() {
        local decision="$1"
        local reason="$2"
        echo "{\"hookSpecificOutput\":{\"hookEventName\":\"PreToolUse\",\"permissionDecision\":\"$decision\",\"permissionDecisionReason\":\"$reason\"}}"
    }

    # Helper to log a denial with [PreToolUse] prefix for clear attribution
    log_denial() {
        local tool="$1"
        local input_json="$2"
        local params
        params=$(echo "$input_json" | jq -r 'to_entries | map(.key + ": " + (.value | tostring)) | join(", ")' 2>/dev/null || echo "")
        if [[ -n "$params" ]]; then
            log_agent "$ID" "[PreToolUse] Permission denied: $tool ($params)" --quiet
        else
            log_agent "$ID" "[PreToolUse] Permission denied: $tool" --quiet
        fi
    }

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        exit 1
    fi

    # Read JSON input from stdin
    local json_input
    json_input=$(cat)

    # Extract tool name and tool_input from input
    local tool_name
    local tool_input
    tool_name=$(echo "$json_input" | jq -r '.tool_name // ""')
    tool_input=$(echo "$json_input" | jq -c '.tool_input // {}')

    # Resolve AGENTS_DIR to absolute path for proper comparison
    local ABS_AGENTS_DIR
    if [[ -d "$AGENTS_DIR" ]]; then
        ABS_AGENTS_DIR=$(cd "$AGENTS_DIR" && pwd)
    else
        ABS_AGENTS_DIR="$AGENTS_DIR"
    fi

    # Get agent's worktree path (absolute)
    local AGENT_DIR="$ABS_AGENTS_DIR/$ID"
    local WORKTREE_PATH="$AGENT_DIR/repo"
    local SETTINGS_FILE="$WORKTREE_PATH/.claude/settings.local.json"

    # Resolve worktree to absolute path
    if [[ -d "$WORKTREE_PATH" ]]; then
        WORKTREE_PATH=$(cd "$WORKTREE_PATH" && pwd)
    fi

    # Check if tool is in allow list
    if ! tool_in_allow_list "$tool_name" "$tool_input" "$SETTINGS_FILE"; then
        # Tool not in allow list - deny and log
        log_denial "$tool_name" "$tool_input"
        output_decision "deny" "Tool not in allow list"
        exit 0
    fi

    # Tool is in allow list - now check path isolation

    # Extract file path from input
    local file_path
    file_path=$(echo "$json_input" | jq -r '.tool_input.file_path // .tool_input.path // ""')

    # Special handling for Bash tool - check for cd commands
    if [[ "$tool_name" == "Bash" ]]; then
        local bash_command
        bash_command=$(echo "$json_input" | jq -r '.tool_input.command // ""')

        # Check if command is a cd command (handle various forms: cd, cd dir, cd "dir", cd 'dir')
        if [[ "$bash_command" =~ ^cd[[:space:]]+ ]]; then
            # Extract the target directory from cd command
            # Remove 'cd ' prefix and handle quotes
            local cd_target="${bash_command#cd }"
            cd_target="${cd_target#"${cd_target%%[![:space:]]*}"}"  # trim leading whitespace

            # Remove quotes if present
            cd_target="${cd_target#\"}"
            cd_target="${cd_target%\"}"
            cd_target="${cd_target#\'}"
            cd_target="${cd_target%\'}"

            # If cd target is empty or just whitespace, allow (cd to home)
            if [[ -z "$cd_target" || "$cd_target" =~ ^[[:space:]]*$ ]]; then
                output_decision "allow" "Tool in allow list, cd to home"
                exit 0
            fi

            # Use cd_target as the file_path for further checks
            file_path="$cd_target"
        else
            # Not a cd command - allowed by allow list, no path check needed for non-cd
            output_decision "allow" "Tool in allow list"
            exit 0
        fi
    fi

    # If no file path found, allow (might be a non-file tool or tool with no path param)
    if [[ -z "$file_path" ]]; then
        output_decision "allow" "Tool in allow list"
        exit 0
    fi

    # Resolve to absolute path
    if [[ "$file_path" != /* ]]; then
        local cwd
        cwd=$(echo "$json_input" | jq -r '.cwd // ""')
        if [[ -n "$cwd" ]]; then
            file_path="$cwd/$file_path"
        fi
    fi

    # Normalize path (resolve . and ..) - only if directory exists
    local dir_part
    dir_part=$(dirname "$file_path")
    if [[ -d "$dir_part" ]]; then
        file_path="$(cd "$dir_part" && pwd)/$(basename "$file_path")"
    fi
    # If directory doesn't exist, keep the original path for pattern matching

    # Check 1: Allow access within agent's own worktree
    if [[ "$file_path" == "$WORKTREE_PATH"* ]]; then
        output_decision "allow" "Tool in allow list, path in worktree"
        exit 0
    fi

    # Check 2: Allow access to agent's own log file
    if [[ "$file_path" == "$AGENT_DIR/agent.log" ]]; then
        output_decision "allow" "Tool in allow list, accessing own log"
        exit 0
    fi

    # Check 3: Block access to other agents' directories
    if [[ "$file_path" == "$ABS_AGENTS_DIR/"* ]]; then
        if [[ "$tool_name" == "Bash" ]]; then
            log_agent "$ID" "[PreToolUse] Path violation: Bash cd command tried to enter other agent's worktree: $file_path" --quiet
            output_decision "deny" "Access denied: cannot cd into other agents' worktrees"
        else
            log_agent "$ID" "[PreToolUse] Path violation: $tool_name tried to access other agent's data: $file_path" --quiet
            output_decision "deny" "Access denied: cannot access other agents' files"
        fi
        exit 0
    fi

    # Check 4: Block access to main repo (outside worktree)
    # Use git worktree list to find the main repo path
    local ROOT_REPO
    ROOT_REPO=$(git -C "$WORKTREE_PATH" worktree list --porcelain 2>/dev/null | grep -m1 '^worktree ' | sed 's/^worktree //')

    if [[ -n "$ROOT_REPO" && "$file_path" == "$ROOT_REPO"* && "$file_path" != "$WORKTREE_PATH"* ]]; then
        log_agent "$ID" "[PreToolUse] Path violation: $tool_name tried to access main repo: $file_path" --quiet
        output_decision "deny" "Access denied: work in your worktree, not the main repo"
        exit 0
    fi

    # All other paths: allow (system files, etc. - tool is in allow list)
    output_decision "allow" "Tool in allow list"
    exit 0
}

# =============================================================================
# COMMAND: parse-state
# =============================================================================

# Parse state from text input (stdin or file)
# This command exposes parse_state() for testing and debugging
cmd_parse_state() {
    local input_file=""
    local verbose=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib parse-state [options] [file]

Parse agent state from tmux output text.

Reads from stdin if no file is provided, or from the specified file.
Outputs one of: running, waiting, complete, unknown

This command is primarily for testing state detection logic.

Options:
  -v, --verbose  Show which pattern matched
  -h, --help     Show this help

States (in priority order):
  complete  - "I HAVE COMPLETED THE GOAL" found in last 15 lines
  waiting   - "WAITING" found as standalone word in last 15 lines
  running   - Active tool execution indicators present
  unknown   - No clear state indicators

Examples:
  echo "⏺ I HAVE COMPLETED THE GOAL" | ib parse-state
  ib parse-state tests/fixtures/complete.txt
  cat /path/to/output.log | ib parse-state -v
EOF
                exit 0
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                input_file="$1"
                shift
                ;;
        esac
    done

    local input
    if [[ -n "$input_file" ]]; then
        if [[ ! -f "$input_file" ]]; then
            echo "Error: file not found: $input_file" >&2
            exit 1
        fi
        input=$(cat "$input_file")
    else
        # Check if stdin is a terminal (no data piped)
        if [[ -t 0 ]]; then
            echo "Error: no input provided. Use a file argument or pipe input." >&2
            echo "Usage: ib parse-state [file] or echo 'text' | ib parse-state" >&2
            exit 1
        fi
        input=$(cat)
    fi

    if $verbose; then
        # Check for 'creating' state - Claude permission screens before fully started
        # Only detect as creating if Claude logo/[USER TASK] is NOT present
        if [[ "$input" != *"Claude Code v"* ]] && [[ "$input" != *"[USER TASK]"* ]]; then
            if [[ "$input" == *"Enter to confirm"* ]]; then
                if [[ "$input" == *"Do you trust the files"* ]]; then
                    echo "creating (matched: workspace trust prompt)"
                    return
                fi
                if [[ "$input" == *"Allow external CLAUDE.md file imports"* ]]; then
                    echo "creating (matched: external imports prompt)"
                    return
                fi
            fi
        fi

        # Get last 5 lines for active execution detection (very recent window)
        local very_recent
        very_recent=$(echo "$input" | tail -5)

        # Get last 15 lines for broader state detection
        local last_lines
        last_lines=$(echo "$input" | tail -15)

        # Check for ACTIVE running indicators FIRST in very recent output
        # Note: We require parentheses around interrupt phrases to distinguish from discussion text
        if [[ "$very_recent" =~ \(esc\ to\ interrupt\) ]]; then
            echo "running (matched: (esc to interrupt) in last 5 lines)"
            return
        fi

        if [[ "$very_recent" =~ \(ctrl\+c\ to\ interrupt\) ]]; then
            echo "running (matched: (ctrl+c to interrupt) in last 5 lines)"
            return
        fi

        if [[ "$very_recent" =~ ⎿\ \ Running ]]; then
            echo "running (matched: ⎿  Running in last 5 lines)"
            return
        fi

        # Check completion/waiting in last 15 lines
        if [[ "$last_lines" == *'I HAVE COMPLETED THE GOAL'* ]]; then
            echo "complete (matched: I HAVE COMPLETED THE GOAL)"
            return
        fi

        if [[ "$last_lines" =~ (^|$'\n')[[:space:]]*WAITING[[:space:]]*($|$'\n') ]]; then
            echo "waiting (matched: standalone WAITING)"
            return
        fi

        if [[ "$last_lines" =~ ⏺.*WAITING ]]; then
            echo "waiting (matched: ⏺...WAITING)"
            return
        fi

        # Other running indicators in last 15 lines
        if [[ "$last_lines" =~ ctrl\+b\ ctrl\+b ]]; then
            echo "running (matched: ctrl+b ctrl+b)"
            return
        fi

        if [[ "$last_lines" =~ thinking\) ]]; then
            echo "running (matched: thinking))"
            return
        fi

        # Check for thinking spinners at start of line
        if [[ "$last_lines" =~ (^|$'\n')[✽✶✢·✻✳][[:space:]] ]]; then
            echo "running (matched: thinking spinner at line start)"
            return
        fi

        # Weak running indicator (tool invocation without strong indicator)
        if [[ "$last_lines" =~ ⏺[[:space:]]*(Bash|Read|Write|Edit|Grep|Glob|Task|WebFetch|WebSearch|TodoWrite|NotebookEdit|LSP|AskUserQuestion)\( ]]; then
            echo "running (matched: ⏺ ToolName()"
            return
        fi

        echo "unknown (no patterns matched)"
    else
        parse_state "$input"
    fi
}

# =============================================================================
# COMMAND: test-tool-match
# =============================================================================

# Test tool_matches_pattern() with a JSON fixture file or stdin
# This command allows testing the pattern matching logic in isolation
# Input JSON format:
# {
#   "tool_name": "Bash",
#   "tool_input": {"command": "git status"},
#   "pattern": "Bash(git:*)"
# }
# For testing against multiple patterns (returns first match):
# {
#   "tool_name": "Bash",
#   "tool_input": {"command": "ib list"},
#   "patterns": ["Bash(git:*)", "Bash(ib:*)"]
# }
# Output: 'match' or 'no-match'
# Verbose output shows why the match succeeded/failed
cmd_test_tool_match() {
    local input_file=""
    local verbose=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib test-tool-match [options] [file]

Test tool permission pattern matching logic.

Reads from stdin if no file is provided, or from the specified file.
Outputs 'match' or 'no-match'.

This command is primarily for testing the tool_matches_pattern() function.

Options:
  -v, --verbose  Show why the match succeeded or failed
  -h, --help     Show this help

Input JSON format (single pattern):
  {
    "tool_name": "Bash",
    "tool_input": {"command": "git status"},
    "pattern": "Bash(git:*)"
  }

Input JSON format (multiple patterns - returns first match):
  {
    "tool_name": "Bash",
    "tool_input": {"command": "ib list"},
    "patterns": ["Bash(git:*)", "Bash(ib:*)"]
  }

Pattern formats:
  - "Read"         Exact tool name match
  - "Bash(git:*)"  Bash tool where command starts with "git"
  - "Bash(ib:*)"   Bash tool where command starts with "ib"

Examples:
  echo '{"tool_name": "Read", "tool_input": {}, "pattern": "Read"}' | ib test-tool-match
  ib test-tool-match tests/fixtures/tool-match/match-exact-tool.json
  echo '{"tool_name": "Bash", "tool_input": {"command": "git status"}, "pattern": "Bash(git:*)"}' | ib test-tool-match -v
EOF
                exit 0
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                input_file="$1"
                shift
                ;;
        esac
    done

    local input
    if [[ -n "$input_file" ]]; then
        if [[ ! -f "$input_file" ]]; then
            echo "Error: file not found: $input_file" >&2
            exit 1
        fi
        input=$(cat "$input_file")
    else
        # Check if stdin is a terminal (no data piped)
        if [[ -t 0 ]]; then
            echo "Error: no input provided. Use a file argument or pipe input." >&2
            echo "Usage: ib test-tool-match [file] or echo '{...}' | ib test-tool-match" >&2
            exit 1
        fi
        input=$(cat)
    fi

    # Extract test parameters
    local tool_name tool_input pattern patterns
    tool_name=$(echo "$input" | jq -r '.tool_name // ""')
    tool_input=$(echo "$input" | jq -c '.tool_input // {}')
    pattern=$(echo "$input" | jq -r '.pattern // ""')
    patterns=$(echo "$input" | jq -c '.patterns // []')

    # Validate required fields
    if [[ -z "$tool_name" ]]; then
        echo "Error: tool_name is required in JSON input" >&2
        exit 1
    fi

    # Build list of patterns to test
    local patterns_to_test=()
    if [[ -n "$pattern" ]]; then
        patterns_to_test+=("$pattern")
    fi

    # Add patterns from array if present
    local patterns_len
    patterns_len=$(echo "$patterns" | jq 'length')
    if [[ "$patterns_len" -gt 0 ]]; then
        while IFS= read -r p; do
            [[ -n "$p" ]] && patterns_to_test+=("$p")
        done < <(echo "$patterns" | jq -r '.[]')
    fi

    if [[ ${#patterns_to_test[@]} -eq 0 ]]; then
        echo "Error: either pattern or patterns is required in JSON input" >&2
        exit 1
    fi

    # Test each pattern
    for p in "${patterns_to_test[@]}"; do
        # Check for Bash(prefix:*) pattern
        if [[ "$p" =~ ^Bash\(([^:]+):\*\)$ ]]; then
            local prefix="${BASH_REMATCH[1]}"
            if [[ "$tool_name" == "Bash" ]]; then
                local command
                command=$(echo "$tool_input" | jq -r '.command // ""')
                # Check if command starts with prefix (with space or end of string)
                if [[ "$command" == "$prefix" || "$command" == "$prefix "* ]]; then
                    if $verbose; then
                        echo "match (pattern: $p, command: $command, prefix match: $prefix)"
                    else
                        echo "match"
                    fi
                    return 0
                else
                    if $verbose && [[ ${#patterns_to_test[@]} -eq 1 ]]; then
                        echo "no-match (pattern: $p, tool: $tool_name, command: $command, expected prefix: $prefix)"
                        return 0
                    fi
                fi
            else
                if $verbose && [[ ${#patterns_to_test[@]} -eq 1 ]]; then
                    echo "no-match (pattern: $p, tool: $tool_name, pattern requires Bash tool)"
                    return 0
                fi
            fi
        # Exact tool name match
        elif [[ "$p" == "$tool_name" ]]; then
            if $verbose; then
                echo "match (pattern: $p, exact tool match)"
            else
                echo "match"
            fi
            return 0
        else
            if $verbose && [[ ${#patterns_to_test[@]} -eq 1 ]]; then
                echo "no-match (pattern: $p, tool: $tool_name)"
                return 0
            fi
        fi
    done

    # No pattern matched
    if $verbose; then
        local patterns_str
        patterns_str=$(printf '%s, ' "${patterns_to_test[@]}")
        patterns_str="${patterns_str%, }"  # Remove trailing comma and space
        echo "no-match (tool: $tool_name, tested patterns: $patterns_str)"
    else
        echo "no-match"
    fi
}

# =============================================================================
# COMMAND: test-pretooluse
# =============================================================================

# Test PreToolUse hook logic with a JSON fixture file
# This command allows testing the PreToolUse decision logic without a real agent
# Fixture JSON format:
# {
#   "tool_name": "Bash",
#   "tool_input": {"command": "cat file.txt"},
#   "cwd": "/path/to/cwd",
#   "allow_list": ["Bash(cat:*)", "Edit"],
#   "worktree_path": "/path/to/worktree",
#   "agents_dir": "/path/to/agents",
#   "root_repo": "/path/to/root"
# }
cmd_test_pretooluse() {
    local fixture_file="$1"

    if [[ -z "$fixture_file" ]]; then
        echo "Usage: ib test-pretooluse <fixture.json>" >&2
        exit 1
    fi

    if [[ ! -f "$fixture_file" ]]; then
        echo "Error: fixture file not found: $fixture_file" >&2
        exit 1
    fi

    # Read fixture
    local fixture
    fixture=$(cat "$fixture_file")

    # Extract test parameters
    local tool_name tool_input cwd allow_list worktree_path agent_dir agents_dir root_repo
    tool_name=$(echo "$fixture" | jq -r '.tool_name // ""')
    tool_input=$(echo "$fixture" | jq -c '.tool_input // {}')
    cwd=$(echo "$fixture" | jq -r '.cwd // ""')
    allow_list=$(echo "$fixture" | jq -r '.allow_list // []')
    worktree_path=$(echo "$fixture" | jq -r '.worktree_path // ""')
    agent_dir=$(echo "$fixture" | jq -r '.agent_dir // ""')
    agents_dir=$(echo "$fixture" | jq -r '.agents_dir // ""')
    root_repo=$(echo "$fixture" | jq -r '.root_repo // ""')

    # Helper to check if tool matches a pattern (same logic as tool_matches_pattern)
    test_tool_matches_pattern() {
        local t_name="$1"
        local t_input="$2"
        local pattern="$3"

        # Check for Bash(prefix:*) pattern
        if [[ "$pattern" =~ ^Bash\(([^:]+):\*\)$ ]]; then
            local prefix="${BASH_REMATCH[1]}"
            if [[ "$t_name" == "Bash" ]]; then
                local command
                command=$(echo "$t_input" | jq -r '.command // ""')
                if [[ "$command" == "$prefix" || "$command" == "$prefix "* ]]; then
                    return 0
                fi
            fi
            return 1
        fi

        # Exact tool name match
        if [[ "$pattern" == "$t_name" ]]; then
            return 0
        fi

        return 1
    }

    # Check if tool is in allow list
    local in_allow_list=false
    while IFS= read -r pattern; do
        [[ -z "$pattern" ]] && continue
        if test_tool_matches_pattern "$tool_name" "$tool_input" "$pattern"; then
            in_allow_list=true
            break
        fi
    done < <(echo "$allow_list" | jq -r '.[]')

    if [[ "$in_allow_list" == "false" ]]; then
        echo "deny"
        exit 0
    fi

    # Tool is in allow list - now check path isolation

    # Extract file path from input
    local file_path
    file_path=$(echo "$tool_input" | jq -r '.file_path // .path // ""')

    # Special handling for Bash tool - check for cd commands
    if [[ "$tool_name" == "Bash" ]]; then
        local bash_command
        bash_command=$(echo "$tool_input" | jq -r '.command // ""')

        # Check if command is a cd command
        if [[ "$bash_command" =~ ^cd[[:space:]]+ ]]; then
            # Extract the target directory from cd command
            local cd_target="${bash_command#cd }"
            cd_target="${cd_target#"${cd_target%%[![:space:]]*}"}"  # trim leading whitespace

            # Remove quotes if present
            cd_target="${cd_target#\"}"
            cd_target="${cd_target%\"}"
            cd_target="${cd_target#\'}"
            cd_target="${cd_target%\'}"

            # If cd target is empty or just whitespace, allow (cd to home)
            if [[ -z "$cd_target" || "$cd_target" =~ ^[[:space:]]*$ ]]; then
                echo "allow"
                exit 0
            fi

            # Use cd_target as the file_path for further checks
            file_path="$cd_target"
        else
            # Not a cd command - allowed by allow list, no path check needed for non-cd
            echo "allow"
            exit 0
        fi
    fi

    # If no file path found, allow (might be a non-file tool or tool with no path param)
    if [[ -z "$file_path" ]]; then
        echo "allow"
        exit 0
    fi

    # Resolve to absolute path if relative
    if [[ "$file_path" != /* ]]; then
        if [[ -n "$cwd" ]]; then
            file_path="$cwd/$file_path"
        fi
    fi

    # Normalize path (handle . and .. without needing real filesystem)
    # Simple normalization: remove trailing slashes, collapse multiple slashes
    file_path=$(echo "$file_path" | sed 's|//*|/|g; s|/$||')

    # Check 1: Allow access within agent's own worktree
    if [[ -n "$worktree_path" && "$file_path" == "$worktree_path"* ]]; then
        echo "allow"
        exit 0
    fi

    # Check 2: Allow access to agent's own log file
    if [[ -n "$agent_dir" && "$file_path" == "$agent_dir/agent.log" ]]; then
        echo "allow"
        exit 0
    fi

    # Check 3: Block access to other agents' directories
    if [[ -n "$agents_dir" && "$file_path" == "$agents_dir/"* ]]; then
        # It's in agents_dir but not in worktree_path (which would have matched above)
        echo "deny"
        exit 0
    fi

    # Check 4: Block access to main repo (outside worktree)
    if [[ -n "$root_repo" && "$file_path" == "$root_repo"* ]]; then
        # Check if it's NOT in the worktree (worktree check already passed if it was)
        if [[ -z "$worktree_path" || "$file_path" != "$worktree_path"* ]]; then
            echo "deny"
            exit 0
        fi
    fi

    # All other paths: allow (system files, etc. - tool is in allow list)
    echo "allow"
    exit 0
}

# =============================================================================
# COMMAND: test-validate-meta
# =============================================================================

# Test validate_agent_metadata() logic with a single meta.json file
# Input: meta.json file path
# Output: "valid" or "invalid" followed by error message
cmd_test_validate_meta() {
    local fixture_file="$1"

    if [[ -z "$fixture_file" ]]; then
        echo "Usage: ib test-validate-meta <meta.json>" >&2
        exit 1
    fi

    if [[ ! -f "$fixture_file" ]]; then
        echo "Error: file not found: $fixture_file" >&2
        exit 1
    fi

    # Check for created_epoch field (required for age calculation)
    local created_epoch
    created_epoch=$(jq -r '.created_epoch // empty' "$fixture_file" 2>/dev/null)

    if [[ -z "$created_epoch" ]]; then
        echo "invalid"
        echo "missing 'created_epoch' field"
        exit 0
    fi

    if ! [[ "$created_epoch" =~ ^[0-9]+$ ]]; then
        echo "invalid"
        echo "'created_epoch' must be numeric (got: $created_epoch)"
        exit 0
    fi

    echo "valid"
    exit 0
}

# =============================================================================
# COMMAND: test-format-age
# =============================================================================

# Test format_age() function with deterministic timestamps
# Input format: '<timestamp> [<now_timestamp>]' (two timestamps, space-separated; second is optional)
# If only one timestamp provided, uses current time as 'now'
# Output: formatted age string (e.g., '5s', '5m', '2h', '1d')
cmd_test_format_age() {
    local input_file=""
    local verbose=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib test-format-age [options] [file]

Test the format_age() function with deterministic timestamps.

Reads from stdin if no file is provided, or from the specified file.
Input format: '<timestamp> [<now_timestamp>]'
  - First timestamp: the "created" time to format
  - Second timestamp (optional): the "now" reference time
  - If only one timestamp, uses current time as "now"

Timestamps should be Unix epoch seconds.

Output: Formatted age string (e.g., '5s', '5m', '2h', '1d')

Options:
  -v, --verbose  Show diff in seconds and both timestamps
  -h, --help     Show this help

Examples:
  # Using explicit now timestamp for deterministic testing
  echo "1704067200 1704067205" | ib test-format-age
  # Output: 5s

  # From file
  ib test-format-age tests/fixtures/format-age/5s-basic.txt

  # Verbose output
  echo "1704067200 1704067260" | ib test-format-age -v
  # Output: 1m (diff: 60 seconds, from: 1704067200, to: 1704067260)
EOF
                exit 0
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                input_file="$1"
                shift
                ;;
        esac
    done

    local input
    if [[ -n "$input_file" ]]; then
        if [[ ! -f "$input_file" ]]; then
            echo "Error: file not found: $input_file" >&2
            exit 1
        fi
        input=$(cat "$input_file")
    else
        # Check if stdin is a terminal (no data piped)
        if [[ -t 0 ]]; then
            echo "Error: no input provided. Use a file argument or pipe input." >&2
            echo "Usage: ib test-format-age [file] or echo 'timestamp [now]' | ib test-format-age" >&2
            exit 1
        fi
        input=$(cat)
    fi

    # Parse the input - expect "timestamp [now_timestamp]"
    # Trim whitespace and handle both single and double values
    input=$(echo "$input" | tr -s ' ' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

    local created_ts now_ts
    if [[ "$input" =~ ^([0-9]+)[[:space:]]+([0-9]+)$ ]]; then
        # Two timestamps provided
        created_ts="${BASH_REMATCH[1]}"
        now_ts="${BASH_REMATCH[2]}"
    elif [[ "$input" =~ ^([0-9]+)$ ]]; then
        # Single timestamp - use current time
        created_ts="${BASH_REMATCH[1]}"
        now_ts=$(date +%s)
    else
        echo "Error: invalid input format. Expected 'timestamp [now_timestamp]'" >&2
        echo "Got: $input" >&2
        exit 1
    fi

    # Calculate the diff
    local diff=$((now_ts - created_ts))

    # Format the age (same logic as format_age but without ISO parsing)
    local result
    if [[ $diff -lt 60 ]]; then
        result="${diff}s"
    elif [[ $diff -lt 3600 ]]; then
        result="$((diff / 60))m"
    elif [[ $diff -lt 86400 ]]; then
        result="$((diff / 3600))h"
    else
        result="$((diff / 86400))d"
    fi

    if $verbose; then
        echo "$result (diff: $diff seconds, from: $created_ts, to: $now_ts)"
    else
        echo "$result"
    fi
}

# =============================================================================
# COMMAND: test-tool-allowed
# =============================================================================

# Test tool_in_allow_list() logic directly
# This is for testing only - blocked from running inside agents
# Input format (JSON via stdin or file):
# {
#   "tool_name": "Bash",
#   "tool_input": {"command": "ib list"},
#   "settings": {"permissions": {"allow": ["Bash(ib:*)"]}}
# }
cmd_test_tool_allowed() {
    local input_file=""
    local verbose=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib test-tool-allowed [options] [file]

Test tool permission checking against allow list patterns.

Reads JSON from stdin if no file is provided, or from the specified file.
Outputs 'allowed' or 'denied' based on whether the tool matches the allow list.

This command is primarily for testing the tool_in_allow_list() logic.

Options:
  -v, --verbose  Show which pattern matched (if any)
  -h, --help     Show this help

Input format:
  {
    "tool_name": "Bash",
    "tool_input": {"command": "ib list"},
    "settings": {"permissions": {"allow": ["Bash(ib:*)"]}}
  }

Pattern types:
  - Exact tool name: "Read", "Edit", "Write"
  - Bash prefix: "Bash(git:*)" matches git commands
  - Bash prefix: "Bash(ib:*)" matches ib commands

Examples:
  echo '{"tool_name": "Read", "tool_input": {}, "settings": {"permissions": {"allow": ["Read"]}}}' | ib test-tool-allowed
  ib test-tool-allowed tests/fixtures/tool-allowed/allowed-exact-tool.json
  ib test-tool-allowed -v tests/fixtures/tool-allowed/allowed-bash-prefix.json
EOF
                exit 0
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                input_file="$1"
                shift
                ;;
        esac
    done

    local input
    if [[ -n "$input_file" ]]; then
        if [[ ! -f "$input_file" ]]; then
            echo "Error: file not found: $input_file" >&2
            exit 1
        fi
        input=$(cat "$input_file")
    else
        # Check if stdin is a terminal (no data piped)
        if [[ -t 0 ]]; then
            echo "Error: no input provided. Use a file argument or pipe input." >&2
            echo "Usage: ib test-tool-allowed [file] or echo '{...}' | ib test-tool-allowed" >&2
            exit 1
        fi
        input=$(cat)
    fi

    # Extract test parameters from JSON
    local tool_name tool_input allow_list
    tool_name=$(echo "$input" | jq -r '.tool_name // ""')
    tool_input=$(echo "$input" | jq -c '.tool_input // {}')
    allow_list=$(echo "$input" | jq -r '.settings.permissions.allow // []')

    if [[ -z "$tool_name" ]]; then
        echo "Error: tool_name is required in input" >&2
        exit 1
    fi

    # Helper to check if tool matches a pattern (same logic as tool_matches_pattern)
    test_tool_matches_pattern() {
        local t_name="$1"
        local t_input="$2"
        local pattern="$3"

        # Check for Bash(prefix:*) pattern
        if [[ "$pattern" =~ ^Bash\(([^:]+):\*\)$ ]]; then
            local prefix="${BASH_REMATCH[1]}"
            if [[ "$t_name" == "Bash" ]]; then
                local command
                command=$(echo "$t_input" | jq -r '.command // ""')
                if [[ "$command" == "$prefix" || "$command" == "$prefix "* ]]; then
                    return 0
                fi
            fi
            return 1
        fi

        # Exact tool name match
        if [[ "$pattern" == "$t_name" ]]; then
            return 0
        fi

        return 1
    }

    # Check if tool is in allow list
    local matched_pattern=""
    while IFS= read -r pattern; do
        [[ -z "$pattern" ]] && continue
        if test_tool_matches_pattern "$tool_name" "$tool_input" "$pattern"; then
            matched_pattern="$pattern"
            break
        fi
    done < <(echo "$allow_list" | jq -r '.[]')

    if [[ -n "$matched_pattern" ]]; then
        if $verbose; then
            if [[ "$tool_name" == "Bash" ]]; then
                local command
                command=$(echo "$tool_input" | jq -r '.command // ""')
                echo "allowed (matched pattern: $matched_pattern, tool: $tool_name, command: $command)"
            else
                echo "allowed (matched pattern: $matched_pattern, tool: $tool_name)"
            fi
        else
            echo "allowed"
        fi
    else
        if $verbose; then
            local allow_list_str
            allow_list_str=$(echo "$allow_list" | jq -r '. | join(", ")')
            echo "denied (tool: $tool_name, allow list: [$allow_list_str])"
        else
            echo "denied"
        fi
    fi
}

# =============================================================================
# COMMAND: test-build-settings
# =============================================================================

# Test build_agent_settings() function output and validation
# This is for testing only - blocked from running inside agents
# Input: agent type (manager/worker) via stdin or file
cmd_test_build_settings() {
    local input_file=""
    local verbose=false
    local validate=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib test-build-settings [options] [file]

Test agent settings generation for manager or worker agents.

Reads agent type from stdin if no file is provided, or from the specified file.
With --validate, outputs 'valid' or 'invalid' based on whether the type is recognized.
Without --validate, outputs the generated JSON settings.

This command is primarily for testing the build_agent_settings() logic.

Options:
  --validate   Only validate the agent type, output 'valid' or 'invalid'
  -v, --verbose  Show additional details
  -h, --help     Show this help

Input format:
  A single word: 'manager' or 'worker'

Examples:
  echo "manager" | ib test-build-settings
  echo "worker" | ib test-build-settings --validate
  ib test-build-settings tests/fixtures/build-settings/valid-manager.txt
EOF
                exit 0
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            --validate)
                validate=true
                shift
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                input_file="$1"
                shift
                ;;
        esac
    done

    local input
    if [[ -n "$input_file" ]]; then
        if [[ ! -f "$input_file" ]]; then
            echo "Error: file not found: $input_file" >&2
            exit 1
        fi
        input=$(cat "$input_file")
    else
        # Check if stdin is a terminal (no data piped)
        if [[ -t 0 ]]; then
            echo "Error: no input provided. Use a file argument or pipe input." >&2
            echo "Usage: ib test-build-settings [file] or echo 'manager' | ib test-build-settings" >&2
            exit 1
        fi
        input=$(cat)
    fi

    # Trim whitespace
    input=$(echo "$input" | tr -d '[:space:]')

    # Validate agent type
    if [[ "$input" != "manager" && "$input" != "worker" ]]; then
        if $validate; then
            echo "invalid"
        else
            echo "Error: invalid agent type '$input'. Must be 'manager' or 'worker'" >&2
            exit 1
        fi
        return
    fi

    if $validate; then
        echo "valid"
    else
        # Generate settings using the actual function
        build_agent_settings "$input"
    fi
}

# =============================================================================
# COMMAND: test-load-config
# =============================================================================

# Test load_config() function output
# This is for testing only - blocked from running inside agents
# Input: JSON config via stdin or file
cmd_test_load_config() {
    local input_file=""
    local verbose=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib test-load-config [options] [file]

Test config file parsing and output the parsed values.

Reads JSON from stdin if no file is provided, or from the specified file.
Outputs the parsed configuration values in a key: value format.

This command is primarily for testing the load_config() logic.

Options:
  -v, --verbose  Show additional details
  -h, --help     Show this help

Input format:
  JSON object matching .ittybitty.json format

Examples:
  echo '{"maxAgents": 5}' | ib test-load-config
  ib test-load-config tests/fixtures/load-config/minimal.json
EOF
                exit 0
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                input_file="$1"
                shift
                ;;
        esac
    done

    local input
    if [[ -n "$input_file" ]]; then
        if [[ ! -f "$input_file" ]]; then
            echo "Error: file not found: $input_file" >&2
            exit 1
        fi
        input=$(cat "$input_file")
    else
        # Check if stdin is a terminal (no data piped)
        if [[ -t 0 ]]; then
            echo "Error: no input provided. Use a file argument or pipe input." >&2
            echo "Usage: ib test-load-config [file] or echo '{...}' | ib test-load-config" >&2
            exit 1
        fi
        input=$(cat)
    fi

    # Parse config values using jq (similar to load_config but from input instead of file)
    local manager_allow manager_deny worker_allow worker_deny
    local create_prs max_agents model fps

    manager_allow=$(echo "$input" | jq -r '.permissions.manager.allow // [] | @json' 2>/dev/null || echo "[]")
    manager_deny=$(echo "$input" | jq -r '.permissions.manager.deny // [] | @json' 2>/dev/null || echo "[]")
    worker_allow=$(echo "$input" | jq -r '.permissions.worker.allow // [] | @json' 2>/dev/null || echo "[]")
    worker_deny=$(echo "$input" | jq -r '.permissions.worker.deny // [] | @json' 2>/dev/null || echo "[]")
    create_prs=$(echo "$input" | jq -r '.createPullRequests // false' 2>/dev/null || echo "false")
    max_agents=$(echo "$input" | jq -r '.maxAgents // 10' 2>/dev/null || echo "10")
    model=$(echo "$input" | jq -r '.model // ""' 2>/dev/null || echo "")
    fps=$(echo "$input" | jq -r '.fps // 10' 2>/dev/null || echo "10")

    # Handle null model
    if [[ "$model" == "null" ]]; then
        model=""
    fi

    # Output in expected format
    echo "manager_allow: $manager_allow"
    echo "manager_deny: $manager_deny"
    echo "worker_allow: $worker_allow"
    echo "worker_deny: $worker_deny"
    echo "create_prs: $create_prs"
    echo "max_agents: $max_agents"
    echo "model: $model"
    echo "fps: $fps"
}

# =============================================================================
# COMMAND: test-resolve-id
# =============================================================================

# Test resolve_agent_id() logic with mock agent list
# This is for testing only - blocked from running inside agents
# Input format (JSON):
# {
#   "partial": "abc",
#   "agents": ["abc123", "def456", "abc789"]
# }
cmd_test_resolve_id() {
    local input_file=""
    local verbose=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib test-resolve-id [options] [file]

Test partial agent ID matching logic with a mock agent list.

Reads JSON from stdin if no file is provided, or from the specified file.
Outputs the resolved ID, or an error message for ambiguous/missing matches.

This command is primarily for testing the resolve_agent_id() logic.

Options:
  -v, --verbose  Show matching details
  -h, --help     Show this help

Input format:
  {
    "partial": "abc",
    "agents": ["abc123", "def456", "abc789"]
  }

Examples:
  echo '{"partial": "def", "agents": ["abc123", "def456"]}' | ib test-resolve-id
  # Output: def456

  echo '{"partial": "abc", "agents": ["abc123", "abc789"]}' | ib test-resolve-id
  # Output: error (ambiguous match)
EOF
                exit 0
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                input_file="$1"
                shift
                ;;
        esac
    done

    local input
    if [[ -n "$input_file" ]]; then
        if [[ ! -f "$input_file" ]]; then
            echo "Error: file not found: $input_file" >&2
            exit 1
        fi
        input=$(cat "$input_file")
    else
        # Check if stdin is a terminal (no data piped)
        if [[ -t 0 ]]; then
            echo "Error: no input provided. Use a file argument or pipe input." >&2
            echo "Usage: ib test-resolve-id [file] or echo '{...}' | ib test-resolve-id" >&2
            exit 1
        fi
        input=$(cat)
    fi

    # Extract test parameters from JSON
    local partial agents_json
    partial=$(echo "$input" | jq -r '.partial // ""')
    agents_json=$(echo "$input" | jq -r '.agents // []')

    if [[ -z "$partial" ]]; then
        echo "Error: partial is required in input" >&2
        exit 1
    fi

    # Convert agents array to bash array
    local matches=()
    while IFS= read -r agent; do
        [[ -z "$agent" ]] && continue

        # Check for exact match first
        if [[ "$agent" == "$partial" ]]; then
            if $verbose; then
                echo "exact match: $agent"
            else
                echo "$agent"
            fi
            return 0
        fi

        # Check for partial match
        if [[ "$agent" == *"$partial"* ]]; then
            matches+=("$agent")
        fi
    done < <(echo "$agents_json" | jq -r '.[]')

    case ${#matches[@]} in
        0)
            echo "error"
            ;;
        1)
            if $verbose; then
                echo "partial match: ${matches[0]}"
            else
                echo "${matches[0]}"
            fi
            ;;
        *)
            echo "error"
            ;;
    esac
}

# =============================================================================
# COMMAND: test-relationships
# =============================================================================

# Test parent-child relationship detection with mock metadata
# This is for testing only - blocked from running inside agents
# Input format (JSON):
# {
#   "agents": [
#     {"id": "manager1", "manager": null},
#     {"id": "worker1", "manager": "manager1"},
#     {"id": "worker2", "manager": "manager1"}
#   ],
#   "query": {"manager": "manager1"}
# }
cmd_test_relationships() {
    local input_file=""
    local verbose=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib test-relationships [options] [file]

Test parent-child relationship detection with mock agent metadata.

Reads JSON from stdin if no file is provided, or from the specified file.
Outputs the list of agents matching the query criteria.

This command is primarily for testing the get_children() logic.

Options:
  -v, --verbose  Show matching details
  -h, --help     Show this help

Input format:
  {
    "agents": [
      {"id": "manager1", "manager": null},
      {"id": "worker1", "manager": "manager1"},
      {"id": "worker2", "manager": "manager1"}
    ],
    "query": {"manager": "manager1"}
  }

Examples:
  echo '{"agents": [{"id": "w1", "manager": "m1"}, {"id": "w2", "manager": "m1"}], "query": {"manager": "m1"}}' | ib test-relationships
  # Output: w1 w2
EOF
                exit 0
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                input_file="$1"
                shift
                ;;
        esac
    done

    local input
    if [[ -n "$input_file" ]]; then
        if [[ ! -f "$input_file" ]]; then
            echo "Error: file not found: $input_file" >&2
            exit 1
        fi
        input=$(cat "$input_file")
    else
        # Check if stdin is a terminal (no data piped)
        if [[ -t 0 ]]; then
            echo "Error: no input provided. Use a file argument or pipe input." >&2
            echo "Usage: ib test-relationships [file] or echo '{...}' | ib test-relationships" >&2
            exit 1
        fi
        input=$(cat)
    fi

    # Extract test parameters from JSON
    local query_manager
    query_manager=$(echo "$input" | jq -r '.query.manager // ""')

    if [[ -z "$query_manager" ]]; then
        echo "Error: query.manager is required in input" >&2
        exit 1
    fi

    # Find all agents whose manager matches the query
    local children=""
    while IFS= read -r agent_json; do
        [[ -z "$agent_json" ]] && continue
        local agent_id agent_manager
        agent_id=$(echo "$agent_json" | jq -r '.id // ""')
        agent_manager=$(echo "$agent_json" | jq -r '.manager // ""')

        if [[ "$agent_manager" == "$query_manager" ]]; then
            if [[ -n "$children" ]]; then
                children="$children $agent_id"
            else
                children="$agent_id"
            fi
        fi
    done < <(echo "$input" | jq -c '.agents[]')

    if [[ -n "$children" ]]; then
        echo "$children"
    fi
}

# =============================================================================
# COMMAND: test-log-format
# =============================================================================

# Test log message formatting
# This is for testing only - blocked from running inside agents
# Input: message string via stdin or file
cmd_test_log_format() {
    local input_file=""
    local verbose=false
    local timestamp=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib test-log-format [options] [file]

Test log message formatting.

Reads message from stdin if no file is provided, or from the specified file.
Outputs the formatted log entry with timestamp.

This command is primarily for testing the log_agent() format.

Options:
  --timestamp TS  Use specific timestamp instead of current time
  -v, --verbose   Show additional details
  -h, --help      Show this help

Input format:
  Plain text message

Examples:
  echo "Agent started successfully" | ib test-log-format
  echo "Agent started" | ib test-log-format --timestamp "2026-01-12 10:30:45"
EOF
                exit 0
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            --timestamp)
                shift
                timestamp="$1"
                shift
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                input_file="$1"
                shift
                ;;
        esac
    done

    local input
    if [[ -n "$input_file" ]]; then
        if [[ ! -f "$input_file" ]]; then
            echo "Error: file not found: $input_file" >&2
            exit 1
        fi
        input=$(cat "$input_file")
    else
        # Check if stdin is a terminal (no data piped)
        if [[ -t 0 ]]; then
            echo "Error: no input provided. Use a file argument or pipe input." >&2
            echo "Usage: ib test-log-format [file] or echo 'message' | ib test-log-format" >&2
            exit 1
        fi
        input=$(cat)
    fi

    # Use provided timestamp or generate current one
    if [[ -z "$timestamp" ]]; then
        timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    fi

    # Output in log format (same as log_agent)
    echo "[$timestamp] $input"
}

# =============================================================================
# COMMAND: test-display-width
# =============================================================================

# Test display width calculation for UTF-8 strings
# This is for testing only - blocked from running inside agents
# Input: string via stdin or file
cmd_test_display_width() {
    local input_file=""
    local verbose=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib test-display-width [options] [file]

Test display width calculation for strings with UTF-8 characters.

Reads a string from stdin if no file is provided, or from the specified file.
Outputs the display width (number of terminal columns).

This is used to test alignment of tree view with UTF-8 box-drawing characters
(│, ├, └, ─) which are 3 bytes each but display as 1 column.

Options:
  -v, --verbose   Show additional details (byte length vs display width)
  -h, --help      Show this help

Examples:
  echo "├── agent-1" | ib test-display-width
  echo "│   └── worker" | ib test-display-width
  ib test-display-width tests/fixtures/display-width/simple-ascii.txt
EOF
                exit 0
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                input_file="$1"
                shift
                ;;
        esac
    done

    local input
    if [[ -n "$input_file" ]]; then
        if [[ ! -f "$input_file" ]]; then
            echo "Error: file not found: $input_file" >&2
            exit 1
        fi
        input=$(cat "$input_file")
    else
        # Check if stdin is a terminal (no data piped)
        if [[ -t 0 ]]; then
            echo "Error: no input provided. Use a file argument or pipe input." >&2
            echo "Usage: ib test-display-width [file] or echo 'string' | ib test-display-width" >&2
            exit 1
        fi
        input=$(cat)
    fi

    # Remove trailing newline for consistent calculation
    input="${input%$'\n'}"

    local width
    width=$(display_width "$input")

    if [[ "$verbose" == true ]]; then
        echo "input: $input"
        echo "byte_length: ${#input}"
        echo "display_width: $width"
    else
        echo "$width"
    fi
}

# =============================================================================
# COMMAND: test-parse-denial
# =============================================================================

# Pure function to parse a denial log line
# Input: A log line like "[2026-01-10 15:05:06] [PreToolUse] Permission denied: Bash (command: curl)"
# Output: JSON with parsed fields: timestamp, hook_type, denial_type, tool_name, params
# Args: $1=log_line
parse_denial_line() {
    local log_line="$1"

    # Extract timestamp: everything between first [ and ]
    local timestamp=""
    if [[ "$log_line" =~ ^\[([^\]]+)\] ]]; then
        timestamp="${BASH_REMATCH[1]}"
    fi

    # Remove timestamp prefix to get the rest
    local rest="${log_line#*] }"

    # Extract hook type: [PreToolUse] or [PermissionRequest]
    local hook_type=""
    if [[ "$rest" =~ ^\[([^\]]+)\] ]]; then
        hook_type="${BASH_REMATCH[1]}"
        rest="${rest#*] }"
    fi

    # Determine denial type and extract tool info
    local denial_type=""
    local tool_name=""
    local params=""

    if [[ "$rest" == "Permission denied: "* ]]; then
        denial_type="permission_denied"
        rest="${rest#Permission denied: }"

        # Extract tool name (everything before first space or paren)
        if [[ "$rest" =~ ^([^\ \(]+) ]]; then
            tool_name="${BASH_REMATCH[1]}"
        fi

        # Extract params if present (inside parentheses)
        if [[ "$rest" =~ \(([^\)]+)\) ]]; then
            params="${BASH_REMATCH[1]}"
        fi

    elif [[ "$rest" == "Path violation: "* ]]; then
        denial_type="path_violation"
        rest="${rest#Path violation: }"

        # Format: "ToolName tried to access..." or "Bash cd command tried to..."
        if [[ "$rest" =~ ^([^\ ]+)\ (tried|cd) ]]; then
            tool_name="${BASH_REMATCH[1]}"
        fi

        # The rest is the path info
        params="$rest"
    fi

    # Output as JSON
    printf '{"timestamp":"%s","hook_type":"%s","denial_type":"%s","tool_name":"%s","params":"%s"}\n' \
        "$timestamp" "$hook_type" "$denial_type" "$tool_name" "$params"
}

# Test command for parse_denial_line
cmd_test_parse_denial() {
    local input_file=""
    local output_field=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib test-parse-denial [options] [file]

Parse a denial log line and extract structured fields.

Reads from stdin if no file is provided, or from the specified file.

Options:
  --field NAME  Output only the specified field (timestamp, hook_type, denial_type, tool_name, params)
  -h, --help    Show this help

Input format (log line):
  [TIMESTAMP] [HOOK_TYPE] Permission denied: TOOL (params)
  [TIMESTAMP] [HOOK_TYPE] Path violation: TOOL tried to access...

Output format (JSON):
  {"timestamp":"...","hook_type":"...","denial_type":"...","tool_name":"...","params":"..."}

Examples:
  echo '[2026-01-10 15:05:06] [PreToolUse] Permission denied: Bash (command: curl)' | ib test-parse-denial
  ib test-parse-denial --field tool_name tests/fixtures/parse-denial/permission-denied-bash.txt
EOF
                exit 0
                ;;
            --field)
                shift
                output_field="$1"
                shift
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                input_file="$1"
                shift
                ;;
        esac
    done

    local input
    if [[ -n "$input_file" ]]; then
        if [[ ! -f "$input_file" ]]; then
            echo "Error: file not found: $input_file" >&2
            exit 1
        fi
        input=$(cat "$input_file")
    else
        # Check if stdin is a terminal (no data piped)
        if [[ -t 0 ]]; then
            echo "Error: no input provided. Use a file argument or pipe input." >&2
            exit 1
        fi
        input=$(cat)
    fi

    local result
    result=$(parse_denial_line "$input")

    if [[ -n "$output_field" ]]; then
        # Extract specific field using parameter expansion (avoid jq dependency in tests)
        case "$output_field" in
            timestamp)
                echo "$result" | sed 's/.*"timestamp":"\([^"]*\)".*/\1/'
                ;;
            hook_type)
                echo "$result" | sed 's/.*"hook_type":"\([^"]*\)".*/\1/'
                ;;
            denial_type)
                echo "$result" | sed 's/.*"denial_type":"\([^"]*\)".*/\1/'
                ;;
            tool_name)
                echo "$result" | sed 's/.*"tool_name":"\([^"]*\)".*/\1/'
                ;;
            params)
                echo "$result" | sed 's/.*"params":"\([^"]*\)".*/\1/'
                ;;
            *)
                echo "Unknown field: $output_field" >&2
                exit 1
                ;;
        esac
    else
        echo "$result"
    fi
}

# =============================================================================
# COMMAND: test-setup-check
# =============================================================================

# Pure function to filter out .ittybitty lines from gitignore content
# This is the SINGLE SOURCE OF TRUTH for the gitignore pattern matching.
# Args: $1=content
# Output: content with .ittybitty lines removed
#
# Pattern matches:
# - .ittybitty or .ittybitty/ at start of line
# - /.ittybitty or /.ittybitty/ at start of line (leading slash variant)
# - Can have trailing slash or not
# - Line can have trailing whitespace but nothing else after
#
# Using basic grep (not extended) for Bash 3.2 compatibility
# In basic grep: \? means zero or one
filter_gitignore_ittybitty_lines() {
    local content="$1"
    # Filter out both pattern variants using piped greps
    # Note: grep returns exit code 1 when no lines match, so we use || true
    # to handle the case where all lines are filtered out
    echo "$content" | grep -v '^\.ittybitty/\?[[:space:]]*$' | grep -v '^/\.ittybitty/\?[[:space:]]*$' || true
}

# Pure function to check if .gitignore content contains the .ittybitty pattern
# Returns: 0 if pattern found (checkbox should be checked), 1 if not found
# Args: $1=content
check_gitignore_has_ittybitty() {
    local content="$1"
    local filtered
    # Use the shared filter function - if output differs, lines were found
    filtered=$(filter_gitignore_ittybitty_lines "$content")
    if [[ "$filtered" != "$content" ]]; then
        return 0  # found (lines were filtered out)
    fi
    return 1  # not found
}

# Pure function to check if CLAUDE.md content contains <ittybitty> tags
# Returns: 0 if both tags found on their own lines, 1 if not
# Note: Matches only standalone tags to avoid false positives from inline examples
# Args: $1=content
check_claude_md_has_ittybitty_block() {
    local content="$1"
    if echo "$content" | grep -q '^<ittybitty>$' 2>/dev/null && \
       echo "$content" | grep -q '^</ittybitty>$' 2>/dev/null; then
        return 0
    fi
    return 1
}

# Pure function to check if CLAUDE.md content contains @.ittybitty/STATUS.md import
# Returns: 1 if import found, 0 if not
# Args: $1=content
check_claude_md_has_status_import() {
    local content="$1"
    if echo "$content" | grep -q '@\.ittybitty/STATUS\.md' 2>/dev/null; then
        return 0
    fi
    return 1
}

# Test setup check functions with fixture files
# This is for testing only - blocked from running inside agents
# Fixture JSON format:
# {
#   "check_type": "gitignore" | "ittybitty_block" | "status_import",
#   "content": "the content to check"
# }
cmd_test_setup_check() {
    local input_file=""
    local verbose=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib test-setup-check [options] [file]

Test setup dialog checkbox state detection.

Reads JSON from stdin if no file is provided, or from the specified file.
Outputs "1" if the check passes (checkbox should be checked) or "0" if not.

This command tests the logic that determines checkbox states in the setup dialog.

Options:
  -v, --verbose   Show additional details
  -h, --help      Show this help

Input JSON format:
{
  "check_type": "gitignore" | "ittybitty_block" | "status_import",
  "content": "the file content to check"
}

Check types:
  gitignore        - Check if .ittybitty is in .gitignore content
  ittybitty_block  - Check if <ittybitty>...</ittybitty> is in CLAUDE.md
  status_import    - Check if @.ittybitty/STATUS.md is in CLAUDE.md

Examples:
  echo '{"check_type": "gitignore", "content": ".ittybitty/"}' | ib test-setup-check
  ib test-setup-check tests/fixtures/setup-check/1-gitignore-start.json
EOF
                exit 0
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                input_file="$1"
                shift
                ;;
        esac
    done

    local input
    if [[ -n "$input_file" ]]; then
        if [[ ! -f "$input_file" ]]; then
            echo "Error: file not found: $input_file" >&2
            exit 1
        fi
        input=$(cat "$input_file")
    else
        # Check if stdin is a terminal (no data piped)
        if [[ -t 0 ]]; then
            echo "Error: no input provided. Use a file argument or pipe input." >&2
            echo "Usage: ib test-setup-check [file] or echo '{...}' | ib test-setup-check" >&2
            exit 1
        fi
        input=$(cat)
    fi

    # Parse JSON
    local check_type content
    check_type=$(echo "$input" | jq -r '.check_type // ""')
    content=$(echo "$input" | jq -r '.content // ""')

    if [[ -z "$check_type" ]]; then
        echo "Error: check_type is required" >&2
        exit 1
    fi

    local result=0
    case "$check_type" in
        gitignore)
            if check_gitignore_has_ittybitty "$content"; then
                result=1
            fi
            ;;
        ittybitty_block)
            if check_claude_md_has_ittybitty_block "$content"; then
                result=1
            fi
            ;;
        status_import)
            if check_claude_md_has_status_import "$content"; then
                result=1
            fi
            ;;
        *)
            echo "Error: unknown check_type: $check_type" >&2
            echo "Valid types: gitignore, ittybitty_block, status_import" >&2
            exit 1
            ;;
    esac

    if [[ "$verbose" == "true" ]]; then
        echo "Check type: $check_type"
        echo "Result: $result"
    else
        echo "$result"
    fi
}

# =============================================================================
# COMMAND: test-gitignore-filter
# =============================================================================

# Test the gitignore filter function with fixture files
# This is for testing only - blocked from running inside agents
# Fixture JSON format:
# {
#   "input": "the gitignore content to filter",
#   "expected": "the expected output after filtering"
# }
cmd_test_gitignore_filter() {
    local input_file=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib test-gitignore-filter [file]

Test the gitignore filter function that removes .ittybitty lines.

Reads JSON from stdin if no file is provided, or from the specified file.
Outputs "pass" if the filter produces expected output, "fail" otherwise.

This command tests filter_gitignore_ittybitty_lines() which is the single
source of truth for gitignore pattern matching used by both detection and removal.

Input JSON format:
{
  "input": "the gitignore content to filter",
  "expected": "the expected output after filtering"
}

Examples:
  echo '{"input": ".ittybitty/\nnode_modules/", "expected": "node_modules/"}' | ib test-gitignore-filter
  ib test-gitignore-filter tests/fixtures/gitignore-filter/removes-basic.json
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                input_file="$1"
                shift
                ;;
        esac
    done

    local input
    if [[ -n "$input_file" ]]; then
        if [[ ! -f "$input_file" ]]; then
            echo "Error: file not found: $input_file" >&2
            exit 1
        fi
        input=$(cat "$input_file")
    else
        # Check if stdin is a terminal (no data piped)
        if [[ -t 0 ]]; then
            echo "Error: no input provided. Use a file argument or pipe input." >&2
            echo "Usage: ib test-gitignore-filter [file] or echo '{...}' | ib test-gitignore-filter" >&2
            exit 1
        fi
        input=$(cat)
    fi

    # Parse JSON - use -r to get raw strings with actual newlines
    local content expected
    content=$(echo "$input" | jq -r '.input // ""')
    expected=$(echo "$input" | jq -r '.expected // ""')

    # Run the filter
    local actual
    actual=$(filter_gitignore_ittybitty_lines "$content")

    # Compare
    if [[ "$actual" == "$expected" ]]; then
        echo "pass"
    else
        echo "fail"
    fi
}

# =============================================================================
# COMMAND: test-main-path
# =============================================================================

# Test the main-path hook logic with fixture files
# This is for testing only - blocked from running inside agents
# Fixture JSON format: same as PreToolUse hook input
# {
#   "tool_name": "Bash",
#   "tool_input": { "command": "cd /path" },
#   "cwd": "/current/dir"
# }
cmd_test_main_path() {
    local input_file=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib test-main-path [file]

Test the main-path hook logic that prevents cd into agent worktrees.

Reads JSON from stdin if no file is provided, or from the specified file.
Outputs "allow" if the command should be allowed, "deny" if it should be blocked.

This tests the logic in 'ib hooks main-path' without needing actual hook setup.

Input JSON format (same as Claude's PreToolUse hook):
{
  "tool_name": "Bash",
  "tool_input": { "command": "cd /path/to/somewhere" },
  "cwd": "/current/working/dir"
}

Examples:
  echo '{"tool_name": "Bash", "tool_input": {"command": "cd /tmp"}}' | ib test-main-path
  ib test-main-path tests/fixtures/main-path/deny-cd-agent-worktree.json
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                input_file="$1"
                shift
                ;;
        esac
    done

    local input
    if [[ -n "$input_file" ]]; then
        if [[ ! -f "$input_file" ]]; then
            echo "Error: file not found: $input_file" >&2
            exit 1
        fi
        input=$(cat "$input_file")
    else
        # Check if stdin is a terminal (no data piped)
        if [[ -t 0 ]]; then
            echo "Error: no input provided. Use a file argument or pipe input." >&2
            echo "Usage: ib test-main-path [file] or echo '{...}' | ib test-main-path" >&2
            exit 1
        fi
        input=$(cat)
    fi

    # Run the main-path hook logic and capture exit code
    # cmd_hooks_main_path exits with 0 for allow, 2 for deny
    # Temporarily disable set -e to capture non-zero exit codes
    set +e
    echo "$input" | cmd_hooks_main_path > /dev/null 2>&1
    local exit_code=$?
    set -e

    if [[ $exit_code -eq 0 ]]; then
        echo "allow"
    elif [[ $exit_code -eq 2 ]]; then
        echo "deny"
    else
        echo "error"
    fi
}

# Test command for enforce_command_access logic
# Input JSON format:
# {
#   "is_agent": true,
#   "cmd": "watch",
#   "subcmd": ""
# }
cmd_test_enforce_access() {
    # Note: Agent blocking is handled by enforce_command_access() before dispatch
    local input_file=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib test-enforce-access [file]

Test the command access restriction logic for agents.

Reads JSON from stdin if no file is provided, or from the specified file.
Outputs "allow" if the command is allowed, "deny" if blocked for agents.

Input JSON format:
{
  "is_agent": true,
  "cmd": "watch",
  "subcmd": ""
}

Fields:
  is_agent  - true if simulating agent context, false for user/primary Claude
  cmd       - the ib command (e.g., "watch", "hooks", "list")
  subcmd    - optional subcommand (e.g., "install" for "hooks install")

Examples:
  echo '{"is_agent": true, "cmd": "watch"}' | ib test-enforce-access
  ib test-enforce-access tests/fixtures/enforce-access/deny-watch-agent.json
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                input_file="$1"
                shift
                ;;
        esac
    done

    local input
    if [[ -n "$input_file" ]]; then
        if [[ ! -f "$input_file" ]]; then
            echo "Error: file not found: $input_file" >&2
            exit 1
        fi
        input=$(cat "$input_file")
    else
        # Check if stdin is a terminal (no data piped)
        if [[ -t 0 ]]; then
            echo "Error: no input provided. Use a file argument or pipe input." >&2
            echo "Usage: ib test-enforce-access [file] or echo '{...}' | ib test-enforce-access" >&2
            exit 1
        fi
        input=$(cat)
    fi

    # Extract test parameters
    local is_agent cmd subcmd
    is_agent=$(echo "$input" | jq -r '.is_agent // false')
    cmd=$(echo "$input" | jq -r '.cmd // ""')
    subcmd=$(echo "$input" | jq -r '.subcmd // ""')

    # If not simulating agent context, always allow
    if [[ "$is_agent" != "true" ]]; then
        echo "allow"
        return 0
    fi

    # Simulate agent context - apply the same logic as enforce_command_access
    case "$cmd" in
        # Test commands - development only, not for agents
        parse-state|test-*)
            echo "deny"
            return 0
            ;;
        # Interactive commands - don't make sense for agents (except watch --debug)
        watch)
            # Allow watch --debug for performance testing from agents
            if [[ "$subcmd" == "--debug" ]]; then
                echo "allow"
                return 0
            fi
            echo "deny"
            return 0
            ;;
        # Hooks subcommands - agents can use agent-* hooks but not install/uninstall
        hooks)
            case "$subcmd" in
                install|uninstall)
                    echo "deny"
                    return 0
                    ;;
            esac
            ;;
    esac

    echo "allow"
    return 0
}

# =============================================================================
# COMMAND: hooks main-path
# =============================================================================

# PreToolUse hook to prevent main repo Claude from cd-ing into agent worktrees
# Only blocks Bash cd commands - allows Read/Write/Edit to worktree paths
cmd_hooks_main_path() {
    # Read JSON input from stdin
    local json_input
    json_input=$(cat)

    # Extract tool name
    local tool_name
    tool_name=$(echo "$json_input" | jq -r '.tool_name // ""')

    # Only check Bash commands - allow all other tools
    if [[ "$tool_name" != "Bash" ]]; then
        exit 0
    fi

    # Extract bash command
    local bash_command
    bash_command=$(echo "$json_input" | jq -r '.tool_input.command // ""')

    # Only check cd commands - allow all other Bash commands
    if [[ ! "$bash_command" =~ ^cd[[:space:]]+ ]]; then
        exit 0
    fi

    # Extract cd target - strip everything after 'cd '
    local cd_target="${bash_command#cd }"
    cd_target="${cd_target#"${cd_target%%[![:space:]]*}"}"  # trim leading whitespace

    # Stop at command separators (&&, ||, ;, |, #)
    # This handles compound commands like: cd /path && other_command
    cd_target="${cd_target%% &&*}"  # stop at &&
    cd_target="${cd_target%% ||*}"  # stop at ||
    cd_target="${cd_target%%;*}"    # stop at ;
    cd_target="${cd_target%% |*}"   # stop at | (space before to avoid matching paths with |)
    cd_target="${cd_target%% #*}"   # stop at # (comment)

    # Trim trailing whitespace
    cd_target="${cd_target%"${cd_target##*[![:space:]]}"}"

    # Remove quotes if present (handle both "path" and 'path')
    if [[ "$cd_target" == \"*\" ]]; then
        cd_target="${cd_target#\"}"
        cd_target="${cd_target%\"}"
    elif [[ "$cd_target" == \'*\' ]]; then
        cd_target="${cd_target#\'}"
        cd_target="${cd_target%\'}"
    fi

    # If cd target is empty (cd to home), allow
    if [[ -z "$cd_target" || "$cd_target" =~ ^[[:space:]]*$ ]]; then
        exit 0
    fi

    # Resolve to absolute path using cwd from JSON
    local file_path="$cd_target"
    if [[ "$file_path" != /* ]]; then
        local cwd
        cwd=$(echo "$json_input" | jq -r '.cwd // ""')
        if [[ -n "$cwd" ]]; then
            file_path="$cwd/$file_path"
        fi
    fi

    # Normalize path (resolve . and ..) - only if directory exists
    local dir_part
    dir_part=$(dirname "$file_path")
    if [[ -d "$dir_part" ]]; then
        file_path="$(cd "$dir_part" && pwd)/$(basename "$file_path")"
    fi
    # If directory doesn't exist, keep the original path for pattern matching

    # Check if path matches .ittybitty/agents/*/repo pattern
    if [[ "$file_path" == *"/.ittybitty/agents/"*"/repo"* || "$file_path" == *"/.ittybitty/agents/"*"/repo" ]]; then
        echo "Access denied: cannot cd into agent worktrees. Use 'ib look/diff/status <agent>' or git show agent/<name>:path/file instead." >&2
        exit 2  # Block
    fi

    # Allow all other paths
    exit 0
}

# =============================================================================
# COMMAND: hooks status
# =============================================================================

# Check if main repo hooks are installed
cmd_hooks_status() {
    local SETTINGS_FILE=".claude/settings.local.json"

    if [[ ! -f "$SETTINGS_FILE" ]]; then
        echo "not-installed"
        exit 0
    fi

    # Check if our hook exists in the file
    # Correct format: .hooks.PreToolUse[].hooks[].command contains "ib hooks main-path"
    if jq -e '.hooks.PreToolUse[]?.hooks[]? | select(.command != null and (.command | contains("ib hooks main-path")))' "$SETTINGS_FILE" >/dev/null 2>&1; then
        echo "installed"
    else
        echo "not-installed"
    fi
}

# =============================================================================
# COMMAND: hooks install
# =============================================================================

# Install PreToolUse hook to main repo
cmd_hooks_install() {
    local SETTINGS_FILE=".claude/settings.local.json"
    local CLAUDE_DIR=".claude"

    # Create .claude directory if needed
    if [[ ! -d "$CLAUDE_DIR" ]]; then
        mkdir -p "$CLAUDE_DIR"
    fi

    # Start with existing settings or empty object
    local settings="{}"
    if [[ -f "$SETTINGS_FILE" ]]; then
        settings=$(cat "$SETTINGS_FILE")
    fi

    # Check if hook already exists
    # Correct format: .hooks.PreToolUse[].hooks[].command contains "ib hooks main-path"
    if echo "$settings" | jq -e '.hooks.PreToolUse[]?.hooks[]? | select(.command != null and (.command | contains("ib hooks main-path")))' >/dev/null 2>&1; then
        echo "Hook already installed"
        exit 0
    fi

    # Define our hook using correct Claude Code format:
    # Each PreToolUse entry has a "matcher" and a "hooks" array of hook objects
    local our_hook='{"matcher":"Bash","hooks":[{"type":"command","command":"ib hooks main-path"}]}'

    # Add the hook to settings, preserving existing content
    settings=$(echo "$settings" | jq --argjson hook "$our_hook" '
        .hooks //= {} |
        .hooks.PreToolUse //= [] |
        .hooks.PreToolUse += [$hook]
    ')

    # Write settings
    echo "$settings" | jq '.' > "$SETTINGS_FILE"
    echo "Hook installed to $SETTINGS_FILE"
}

# =============================================================================
# COMMAND: hooks uninstall
# =============================================================================

# Remove hook from main repo
cmd_hooks_uninstall() {
    local SETTINGS_FILE=".claude/settings.local.json"

    if [[ ! -f "$SETTINGS_FILE" ]]; then
        echo "No settings file found, nothing to uninstall"
        exit 0
    fi

    local settings
    settings=$(cat "$SETTINGS_FILE")

    # Remove our hook from PreToolUse array
    # Correct format: filter out entries where .hooks[].command contains "ib hooks main-path"
    settings=$(echo "$settings" | jq '
        if .hooks.PreToolUse then
            .hooks.PreToolUse = [.hooks.PreToolUse[] | select(
                (.hooks // []) | all(.command == null or (.command | contains("ib hooks main-path") | not))
            )]
        else
            .
        end
    ')

    # Clean up empty arrays/objects
    settings=$(echo "$settings" | jq '
        if .hooks.PreToolUse == [] then del(.hooks.PreToolUse) else . end |
        if .hooks == {} then del(.hooks) else . end
    ')

    # Write settings (or delete file if empty)
    if [[ $(echo "$settings" | jq 'keys | length') -eq 0 ]]; then
        rm -f "$SETTINGS_FILE"
        echo "Hook uninstalled, removed empty settings file"
    else
        echo "$settings" | jq '.' > "$SETTINGS_FILE"
        echo "Hook uninstalled from $SETTINGS_FILE"
    fi
}

# =============================================================================
# COMMAND: setup ib-instructions install
# =============================================================================

# The ittybitty instructions content to add to CLAUDE.md
get_ittybitty_instructions() {
    cat << 'ITTYBITTY_CONTENT'
<ittybitty>
## Multi-Agent Orchestration (ittybitty)

`ib` spawns persistent Claude agents in isolated git worktrees. Check your role marker at conversation start:

| Marker | Role | Action |
|--------|------|--------|
| `<ittybitty>You are an IttyBitty manager agent.</ittybitty>` | Manager | See [AGENT CONTEXT] above |
| `<ittybitty>You are an IttyBitty worker agent.</ittybitty>` | Worker | See [AGENT CONTEXT] above |
| No marker | Primary Claude | Read below |

### Primary Claude

Spawn agents for complex/parallel tasks. **No auto-notifications** - tell user to run `ib watch`.
Always spawn **manager** agents (not `--worker`). Managers assess the task and spawn their own workers if needed.

| Command | Description |
|---------|-------------|
| `ib new-agent "goal"` | Spawn agent (returns ID) |
| `ib look <id>` | View agent output |
| `ib send <id> "msg"` | Send input to agent |
| `ib diff <id>` | Review agent's changes |
| `ib merge <id> --force` | Merge and close agent |
| `ib kill <id> --force` | Close without merging |
| `ib questions` | Check agent questions |
| `ib acknowledge <qid>` | Mark question handled |

**Agent questions:** Agents ask via `ib ask`. Check `ib questions` periodically (STATUS.md import doesn't update mid-conversation).

### Agent States

| State | Meaning |
|-------|---------|
| `creating` | Starting up |
| `running` | Actively working |
| `waiting` | Idle, may need input |
| `complete` | Signaled done |
| `stopped` | Session ended |

@.ittybitty/STATUS.md

</ittybitty>
ITTYBITTY_CONTENT
}

# Install <ittybitty> block to CLAUDE.md
cmd_setup_ib_instructions_install() {
    local claude_md="CLAUDE.md"

    # Check if already installed (match standalone tags only)
    if [[ -f "$claude_md" ]]; then
        if grep -q '^<ittybitty>$' "$claude_md" && grep -q '^</ittybitty>$' "$claude_md"; then
            echo "ib instructions already installed in $claude_md"
            return 0
        fi
    fi

    # Get the instructions content
    local instructions
    instructions=$(get_ittybitty_instructions)

    if [[ -f "$claude_md" ]]; then
        # Append to existing file
        echo "" >> "$claude_md"
        echo "$instructions" >> "$claude_md"
        echo "ib instructions added to $claude_md"
    else
        # Create new file
        echo "# CLAUDE.md" > "$claude_md"
        echo "" >> "$claude_md"
        echo "$instructions" >> "$claude_md"
        echo "Created $claude_md with ib instructions"
    fi
}

# Uninstall <ittybitty> block from CLAUDE.md
cmd_setup_ib_instructions_uninstall() {
    local claude_md="CLAUDE.md"

    if [[ ! -f "$claude_md" ]]; then
        echo "No CLAUDE.md file found"
        return 0
    fi

    # Check if installed (match standalone tags only)
    if ! grep -q '^<ittybitty>$' "$claude_md"; then
        echo "ib instructions not found in $claude_md"
        return 0
    fi

    # Remove the <ittybitty>...</ittybitty> block
    # Match only standalone tags to avoid removing inline examples
    local tmpfile
    tmpfile=$(mktemp)

    # Use awk to remove the block (handles multi-line properly)
    # Only match tags on their own line (^...$)
    awk '
        /^<ittybitty>$/ { in_block=1; next }
        /^<\/ittybitty>$/ { in_block=0; next }
        !in_block { print }
    ' "$claude_md" > "$tmpfile"

    # Remove trailing blank lines
    sed -i.bak -e :a -e '/^\s*$/{ $d; N; ba' -e '}' "$tmpfile" 2>/dev/null || \
        sed -e :a -e '/^\s*$/{ $d; N; ba' -e '}' "$tmpfile" > "${tmpfile}.clean" && mv "${tmpfile}.clean" "$tmpfile"

    mv "$tmpfile" "$claude_md"
    rm -f "${tmpfile}.bak"

    echo "ib instructions removed from $claude_md"
}

# =============================================================================
# COMMAND: setup status-import install
# =============================================================================

# Install @.ittybitty/STATUS.md import inside <ittybitty> block
cmd_setup_status_import_install() {
    local claude_md="CLAUDE.md"

    # Check if <ittybitty> block exists (match standalone tags only)
    if [[ ! -f "$claude_md" ]] || ! grep -q '^<ittybitty>$' "$claude_md"; then
        echo "Error: ib instructions must be installed first"
        return 1
    fi

    # Check if already installed
    if grep -q '@\.ittybitty/STATUS\.md' "$claude_md"; then
        echo "Status import already installed in $claude_md"
        return 0
    fi

    # Insert @.ittybitty/STATUS.md right before </ittybitty>
    local tmpfile
    tmpfile=$(mktemp)

    awk '
        /^<\/ittybitty>$/ {
            print ""
            print "@.ittybitty/STATUS.md"
            print ""
        }
        { print }
    ' "$claude_md" > "$tmpfile"

    mv "$tmpfile" "$claude_md"
    echo "Status import added to $claude_md"
}

# Uninstall @.ittybitty/STATUS.md import from CLAUDE.md
cmd_setup_status_import_uninstall() {
    local claude_md="CLAUDE.md"

    if [[ ! -f "$claude_md" ]]; then
        echo "No CLAUDE.md file found"
        return 0
    fi

    # Check if installed
    if ! grep -q '@\.ittybitty/STATUS\.md' "$claude_md"; then
        echo "Status import not found in $claude_md"
        return 0
    fi

    # Remove the @.ittybitty/STATUS.md line
    local tmpfile
    tmpfile=$(mktemp)

    grep -v '@\.ittybitty/STATUS\.md' "$claude_md" > "$tmpfile"

    mv "$tmpfile" "$claude_md"
    echo "Status import removed from $claude_md"
}

# =============================================================================
# COMMAND: setup gitignore install
# =============================================================================

# Add .ittybitty to .gitignore
cmd_setup_gitignore_install() {
    local gitignore=".gitignore"

    # Check if already installed
    # Note: In basic grep, \? means "zero or one" (not ?)
    if [[ -f "$gitignore" ]] && grep -q '^\.ittybitty/\?$\|^/\.ittybitty/\?$' "$gitignore" 2>/dev/null; then
        echo ".ittybitty already in $gitignore"
        return 0
    fi

    # Append .ittybitty to .gitignore (create file if needed)
    # Add a newline before if file exists and doesn't end with newline
    if [[ -f "$gitignore" ]]; then
        # Check if file ends with newline
        if [[ -s "$gitignore" ]] && [[ "$(tail -c 1 "$gitignore" | wc -l)" -eq 0 ]]; then
            echo "" >> "$gitignore"
        fi
    fi

    echo ".ittybitty/" >> "$gitignore"
    echo ".ittybitty/ added to $gitignore"
}

# Remove .ittybitty from .gitignore
cmd_setup_gitignore_uninstall() {
    local gitignore=".gitignore"

    if [[ ! -f "$gitignore" ]]; then
        echo "No $gitignore file found"
        return 0
    fi

    # Read content and check if installed using the shared check function
    local content
    content=$(cat "$gitignore")

    if ! check_gitignore_has_ittybitty "$content"; then
        echo ".ittybitty not found in $gitignore"
        return 0
    fi

    # Remove using the shared filter function (single source of truth for patterns)
    filter_gitignore_ittybitty_lines "$content" > "$gitignore"
    echo ".ittybitty removed from $gitignore"
}

# =============================================================================
# COMMAND: log
# =============================================================================

cmd_log() {
    local AGENT_ID=""
    local MESSAGE=""
    local QUIET=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --id)
                AGENT_ID="$2"
                shift 2
                ;;
            --quiet|-q)
                QUIET="--quiet"
                shift
                ;;
            -h|--help)
                cat <<EOF
Usage: ib log [--id <agent-id>] [--quiet] "message"

Write a timestamped message to the agent's log file and echo to stdout.

The agent ID is auto-detected when run from an agent worktree.
Log file location: .ittybitty/agents/<id>/agent.log

Options:
  --id ID     Specify agent ID (auto-detected in agent worktrees)
  --quiet,-q  Write to log file only, don't echo to stdout
  -h, --help  Show this help

Examples:
  ib log "Starting task analysis"
  ib log "Found 5 files to process"
  ib log --id my-agent "External log entry"
  ib log --quiet "Silent log entry"
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                MESSAGE="$1"
                shift
                ;;
        esac
    done

    # Auto-detect agent ID if not specified
    if [[ -z "$AGENT_ID" ]]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == *"/.ittybitty/agents/"*"/repo"* ]]; then
            # Extract agent ID from path
            local agent_dir=$(echo "$current_dir" | sed 's|\(.*/.ittybitty/agents/[^/]*\)/repo.*|\1|')
            if [[ -f "$agent_dir/meta.json" ]]; then
                AGENT_ID=$(read_meta_field "$agent_dir/meta.json" "id" "")
            fi
        elif [[ "$current_dir" == *"/.ittybitty/agents/"*"/repo"* ]]; then
            # Legacy path format
            local agent_dir=$(echo "$current_dir" | sed 's|\(.*/.ittybitty/agents/[^/]*\)/repo.*|\1|')
            if [[ -f "$agent_dir/meta.json" ]]; then
                AGENT_ID=$(read_meta_field "$agent_dir/meta.json" "id" "")
            fi
        fi
    fi

    if [[ -z "$AGENT_ID" ]]; then
        echo "Error: Could not detect agent ID. Run from an agent worktree or use --id." >&2
        exit 1
    fi

    if [[ -z "$MESSAGE" ]]; then
        echo "Error: Message required" >&2
        echo "Usage: ib log \"message\"" >&2
        exit 1
    fi

    # Resolve partial ID if needed
    AGENT_ID=$(resolve_agent_id "$AGENT_ID") || exit 1

    # Use the log_agent helper
    log_agent "$AGENT_ID" "$MESSAGE" "$QUIET"
}

# =============================================================================
# COMMAND: ask (for agents to ask questions of the user-level Claude)
# =============================================================================

cmd_ask() {
    local AGENT_ID=""
    local QUESTION=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --id)
                AGENT_ID="$2"
                shift 2
                ;;
            -h|--help)
                cat <<EOF
Usage: ib ask [--id <agent-id>] "question"

Ask a question of the user-level Claude agent.

Only top-level manager agents (agents with no manager) can ask the user
questions directly. Workers and sub-managers must ask their manager, who
can then decide whether to escalate to the user.

Questions are stored in .ittybitty/user-questions.json and appear in the
STATUS.md file that the user-level Claude sees via @import.

The user-level Claude should use 'ib acknowledge <question-id>' to mark
a question as handled, then 'ib send <agent-id> "answer"' to respond.

Configuration:
  This feature can be disabled in .ittybitty.json:
    { "allowAgentQuestions": false }
  Default is true (questions are allowed).

Options:
  --id ID     Specify agent ID (auto-detected in agent worktrees)
  -h, --help  Show this help

Examples:
  ib ask "Should I proceed with refactoring the auth module?"
  ib ask "I found 3 approaches - which do you prefer: A, B, or C?"
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                QUESTION="$1"
                shift
                ;;
        esac
    done

    # Auto-detect agent ID if not specified
    if [[ -z "$AGENT_ID" ]]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == *"/.ittybitty/agents/"*"/repo"* ]]; then
            local agent_dir=$(echo "$current_dir" | sed 's|\(.*/.ittybitty/agents/[^/]*\)/repo.*|\1|')
            if [[ -f "$agent_dir/meta.json" ]]; then
                AGENT_ID=$(read_meta_field "$agent_dir/meta.json" "id" "")
            fi
        fi
    fi

    if [[ -z "$AGENT_ID" ]]; then
        echo "Error: Could not detect agent ID. Run from an agent worktree or use --id." >&2
        exit 1
    fi

    if [[ -z "$QUESTION" ]]; then
        echo "Error: Question required" >&2
        echo "Usage: ib ask \"question\"" >&2
        exit 1
    fi

    # Resolve partial ID
    AGENT_ID=$(resolve_agent_id "$AGENT_ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$AGENT_ID"
    if [[ ! -f "$AGENT_DIR/meta.json" ]]; then
        echo "Error: Agent '$AGENT_ID' not found" >&2
        exit 1
    fi

    # Check if this is a top-level manager (no manager of its own)
    local manager=$(read_meta_field "$AGENT_DIR/meta.json" "manager" "")
    if [[ -n "$manager" && "$manager" != "null" ]]; then
        # Check if the manager agent still exists (may have been merged/killed)
        local manager_dir="$AGENTS_DIR/$manager"
        if [[ -d "$manager_dir" ]]; then
            # Manager still exists - reject and point to manager
            echo "Error: Only top-level managers can ask the user questions directly." >&2
            echo "You should ask your manager '$manager' instead:" >&2
            echo "  ib send $manager \"$QUESTION\"" >&2
            exit 1
        else
            # Manager was merged/killed - allow asking user directly
            echo "Note: Your manager '$manager' is no longer active. Escalating to user." >&2
        fi
    fi

    # Check if agent questions are allowed in config
    if [[ "$CONFIG_ALLOW_AGENT_QUESTIONS" == "false" ]]; then
        echo "Error: Agent questions are disabled in .ittybitty.json" >&2
        echo "Set 'allowAgentQuestions: true' to enable this feature." >&2
        exit 1
    fi

    # Generate question ID (timestamp + short hash)
    local timestamp=$(date +%s)
    local hash_input="$AGENT_ID-$QUESTION"
    local short_hash
    if command -v md5sum &>/dev/null; then
        short_hash=$(echo "$hash_input" | md5sum | cut -c1-6)
    else
        # macOS uses md5 instead of md5sum
        short_hash=$(echo "$hash_input" | md5 | cut -c1-6)
    fi
    local question_id="q-${timestamp}-${short_hash}"
    local questions_file="$ROOT_REPO_PATH/.ittybitty/user-questions.json"

    # Ensure .ittybitty directory exists
    mkdir -p "$ROOT_REPO_PATH/.ittybitty"

    # Initialize or load existing questions file
    if [[ ! -f "$questions_file" ]]; then
        echo '{"questions":[]}' > "$questions_file"
    fi

    # Add the question
    local iso_timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local new_question=$(jq -n \
        --arg id "$question_id" \
        --arg agent "$AGENT_ID" \
        --arg question "$QUESTION" \
        --arg timestamp "$iso_timestamp" \
        --arg status "pending" \
        '{id: $id, agent: $agent, question: $question, timestamp: $timestamp, status: $status}')

    # Append to questions array
    jq --argjson q "$new_question" '.questions += [$q]' "$questions_file" > "$questions_file.tmp" \
        && mv "$questions_file.tmp" "$questions_file"

    # Log the question
    log_agent "$AGENT_ID" "Asked user question ($question_id): $QUESTION"

    # Update STATUS.md so user-level Claude sees the question
    update_claude_status

    echo "Question submitted (ID: $question_id)"
    echo "The user-level Claude will see this in their next interaction."
}

# =============================================================================
# COMMAND: acknowledge (for user-level Claude to mark a question as handled)
# =============================================================================

cmd_acknowledge() {
    local QUESTION_ID=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib acknowledge <question-id>

Mark a user question as acknowledged/handled.

This command is for the PRIMARY (user-level) Claude agent only.
Background agents cannot acknowledge questions - they should ask
their manager or use 'ib ask' if they are top-level managers.

After acknowledging, use 'ib send <agent-id> "answer"' to respond to
the agent that asked the question.

Options:
  -h, --help  Show this help

Examples:
  ib acknowledge q-1704825600-abc123
  ib acknowledge q-1704825600-abc123 && ib send my-agent "yes, proceed"
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                QUESTION_ID="$1"
                shift
                ;;
        esac
    done

    # Prevent agents from using this command - only user-level Claude should acknowledge
    if is_running_as_agent; then
        echo "Error: Only the primary (user-level) Claude can acknowledge questions." >&2
        echo "Background agents should communicate via 'ib send' to their manager," >&2
        echo "or use 'ib ask' if they are top-level managers needing user input." >&2
        exit 1
    fi

    if [[ -z "$QUESTION_ID" ]]; then
        echo "Error: Question ID required" >&2
        echo "Usage: ib acknowledge <question-id>" >&2
        exit 1
    fi

    local questions_file="$ROOT_REPO_PATH/.ittybitty/user-questions.json"

    if [[ ! -f "$questions_file" ]]; then
        echo "Error: No questions file found" >&2
        exit 1
    fi

    # Check if question exists
    local question_exists=$(jq --arg id "$QUESTION_ID" '.questions | map(select(.id == $id)) | length' "$questions_file")
    if [[ "$question_exists" -eq 0 ]]; then
        echo "Error: Question '$QUESTION_ID' not found" >&2
        echo "Use 'ib questions' to list pending questions." >&2
        exit 1
    fi

    # Get the agent ID for the response hint
    local agent_id=$(jq -r --arg id "$QUESTION_ID" '.questions[] | select(.id == $id) | .agent' "$questions_file")

    # Mark as acknowledged
    local iso_timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    jq --arg id "$QUESTION_ID" --arg ts "$iso_timestamp" \
        '(.questions[] | select(.id == $id)) |= . + {status: "acknowledged", acknowledged_at: $ts}' \
        "$questions_file" > "$questions_file.tmp" \
        && mv "$questions_file.tmp" "$questions_file"

    # Update STATUS.md
    update_claude_status

    echo "Question acknowledged."
    echo "To respond to the agent, use:"
    echo "  ib send $agent_id \"your answer\""
}

# =============================================================================
# COMMAND: questions (list pending user questions)
# =============================================================================

cmd_questions() {
    local SHOW_ALL=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --all|-a)
                SHOW_ALL=true
                shift
                ;;
            -h|--help)
                cat <<EOF
Usage: ib questions [--all]

List questions from agents that need user attention.

By default, shows only pending questions. Use --all to include
acknowledged questions.

Options:
  --all, -a   Show all questions (including acknowledged)
  -h, --help  Show this help

Examples:
  ib questions          # Show pending questions
  ib questions --all    # Show all questions
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                shift
                ;;
        esac
    done

    local questions_file="$ROOT_REPO_PATH/.ittybitty/user-questions.json"

    if [[ ! -f "$questions_file" ]]; then
        echo "No questions yet."
        exit 0
    fi

    local filter='.questions | map(select(.status == "pending"))'
    if [[ "$SHOW_ALL" == true ]]; then
        filter='.questions'
    fi

    local count=$(jq "$filter | length" "$questions_file")

    if [[ "$count" -eq 0 ]]; then
        if [[ "$SHOW_ALL" == true ]]; then
            echo "No questions yet."
        else
            echo "No pending questions."
        fi
        exit 0
    fi

    echo "Questions ($count):"
    echo ""

    # Format output
    jq -r "$filter | .[] | \"[\(.status)] \(.id)\n  From: \(.agent)\n  Time: \(.timestamp)\n  Question: \(.question)\n\"" "$questions_file"
}

cmd_watchdog() {
    local AGENT_ID=""
    local QUIET=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --quiet)
                QUIET=true
                shift
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$AGENT_ID" ]]; then
                    AGENT_ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    # Validate argument
    if [[ -z "$AGENT_ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib watchdog <agent-id> [--quiet]" >&2
        exit 1
    fi

    # Resolve partial ID
    AGENT_ID=$(resolve_agent_id "$AGENT_ID") || exit 1

    # Get agent directory
    local AGENT_DIR="$AGENTS_DIR/$AGENT_ID"
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo "Error: Agent $AGENT_ID not found" >&2
        exit 1
    fi

    # Load manager from meta.json
    local manager=$(read_meta_field "$AGENT_DIR/meta.json" "manager" "")

    # Check if agent has a manager (skip check in quiet mode)
    if [[ "$QUIET" != "true" ]]; then
        if [[ -z "$manager" || "$manager" == "null" ]]; then
            echo "Agent $AGENT_ID has no manager, exiting" >&2
            echo "Hint: Use --quiet to monitor agents without managers" >&2
            exit 1
        fi
    else
        # In quiet mode, set manager to "none" if it doesn't exist
        if [[ -z "$manager" || "$manager" == "null" ]]; then
            manager="(none)"
        fi
    fi

    # Set up Ctrl+C trap for clean exit
    trap 'echo ""; echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] Stopped monitoring $AGENT_ID"; log_agent "$AGENT_ID" "[watchdog] Stopped monitoring" --quiet; exit 0' INT

    echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] Monitoring agent $AGENT_ID (manager: $manager)"
    log_agent "$AGENT_ID" "[watchdog] Started monitoring (manager: $manager)" --quiet

    # Initialize counters and flags
    local waiting_counter=0
    local notified_complete=false
    local notify_interval=6  # Start at 30 seconds (6 * 5s), doubles after each notification
    local max_notify_interval=768  # Cap at 64 minutes (768 * 5s = 3840s)
    local prev_state=""

    # Main monitoring loop - runs while agent's worktree exists
    while [[ -d "$AGENT_DIR/repo" ]]; do
        state=$(get_state "$AGENT_ID")

        case "$state" in
            waiting)
                waiting_counter=$((waiting_counter + 1))

                # Only log state change or when counter increments (to show progress)
                if [[ "$prev_state" != "waiting" ]]; then
                    echo "[watchdog] Agent state: waiting (counter: $waiting_counter, next notify at: $notify_interval)"
                    log_agent "$AGENT_ID" "[watchdog] State changed to: waiting" --quiet
                fi

                # Check if we've reached the notification threshold
                if [[ $waiting_counter -ge $notify_interval ]]; then
                    local wait_time=$((notify_interval * 5))
                    echo "[watchdog] THRESHOLD REACHED: Agent has been waiting for ${wait_time}+ seconds"
                    if [[ "$QUIET" == "true" ]]; then
                        echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] QUIET MODE: Would notify manager $manager: agent recently started waiting"
                    else
                        echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] Notifying manager $manager: agent recently started waiting"
                        log_agent "$AGENT_ID" "[watchdog] Notified manager $manager: recently waiting" --quiet
                        ib send "$manager" "[watchdog]: Your subtask $AGENT_ID recently started waiting for input"
                    fi

                    # Reset counter and double the interval (exponential backoff: 30s, 1m, 2m, 4m, 8m, 16m, 32m, 64m)
                    waiting_counter=0
                    notify_interval=$((notify_interval * 2))

                    # Cap at max interval (64 minutes)
                    if [[ $notify_interval -gt $max_notify_interval ]]; then
                        notify_interval=$max_notify_interval
                    fi

                    local next_seconds=$((notify_interval * 5))
                    echo "[watchdog] Next notification in ${next_seconds} seconds"
                    log_agent "$AGENT_ID" "[watchdog] Backoff increased: next notify in ${next_seconds}s" --quiet
                fi
                ;;

            complete)
                waiting_counter=0
                notify_interval=6  # Reset to initial interval when completing
                if [[ "$notified_complete" != "true" ]]; then
                    echo "[watchdog] Agent state: complete"
                    log_agent "$AGENT_ID" "[watchdog] State changed to: complete" --quiet
                    if [[ "$QUIET" == "true" ]]; then
                        echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] QUIET MODE: Would notify manager $manager: agent recently completed"
                    else
                        echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] Notifying manager $manager: agent recently completed"
                        log_agent "$AGENT_ID" "[watchdog] Notified manager $manager: recently completed" --quiet
                        ib send "$manager" "[watchdog]: Your subtask $AGENT_ID recently completed"
                    fi
                    notified_complete=true
                fi
                # No logging if already notified - silence
                ;;

            creating)
                # Agent still initializing - treat like running
                if [[ "$prev_state" != "creating" ]]; then
                    echo "[watchdog] Agent state: creating (Claude starting up)"
                    log_agent "$AGENT_ID" "[watchdog] State: creating" --quiet
                fi
                waiting_counter=0
                notify_interval=6  # Reset to initial interval
                ;;

            running)
                # Only log on state change or if clearing flags
                if [[ "$prev_state" != "running" ]]; then
                    if [[ $waiting_counter -gt 0 ]]; then
                        echo "[watchdog] Agent state: running (reset waiting counter and interval)"
                    else
                        echo "[watchdog] Agent state: running"
                    fi
                    log_agent "$AGENT_ID" "[watchdog] State changed to: running" --quiet
                fi
                waiting_counter=0
                notify_interval=6  # Reset to initial interval when resuming work

                # If agent resumed from complete, allow re-notification
                if [[ "$notified_complete" == "true" ]]; then
                    echo "[watchdog] Agent resumed from complete - clearing completion flag"
                    log_agent "$AGENT_ID" "[watchdog] Resumed from complete" --quiet
                    notified_complete=false
                fi
                ;;

            unknown)
                # Treat unknown like waiting - agent may need attention
                waiting_counter=$((waiting_counter + 1))

                # Only log state change
                if [[ "$prev_state" != "unknown" ]]; then
                    echo "[watchdog] Agent state: unknown (counter: $waiting_counter, next notify at: $notify_interval)"
                    log_agent "$AGENT_ID" "[watchdog] State changed to: unknown" --quiet
                fi

                # Check if we've reached the notification threshold
                if [[ $waiting_counter -ge $notify_interval ]]; then
                    local wait_time=$((notify_interval * 5))
                    echo "[watchdog] THRESHOLD REACHED: Agent state unknown for ${wait_time}+ seconds"
                    if [[ "$QUIET" == "true" ]]; then
                        echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] QUIET MODE: Would notify manager $manager: agent state is unknown"
                    else
                        echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] Notifying manager $manager: agent state is unknown"
                        log_agent "$AGENT_ID" "[watchdog] Notified manager $manager: state unknown" --quiet
                        ib send "$manager" "[watchdog]: Your subtask $AGENT_ID state is unknown - may need attention"
                    fi

                    # Reset counter and double the interval (exponential backoff)
                    waiting_counter=0
                    notify_interval=$((notify_interval * 2))

                    # Cap at max interval (64 minutes)
                    if [[ $notify_interval -gt $max_notify_interval ]]; then
                        notify_interval=$max_notify_interval
                    fi

                    local next_seconds=$((notify_interval * 5))
                    echo "[watchdog] Next notification in ${next_seconds} seconds"
                    log_agent "$AGENT_ID" "[watchdog] Backoff increased: next notify in ${next_seconds}s" --quiet
                fi
                ;;

            stopped)
                # Only log on state change
                if [[ "$prev_state" != "stopped" ]]; then
                    if [[ $waiting_counter -gt 0 ]]; then
                        echo "[watchdog] Agent state: stopped (reset waiting counter and interval)"
                    else
                        echo "[watchdog] Agent state: stopped"
                    fi
                    log_agent "$AGENT_ID" "[watchdog] State changed to: stopped" --quiet
                fi
                waiting_counter=0
                notify_interval=6  # Reset to initial interval
                ;;
        esac

        # Update .ittybitty/STATUS.md on state change
        if [[ "$state" != "$prev_state" ]]; then
            update_claude_status
        fi

        prev_state="$state"
        sleep 5
    done

    # Agent killed/merged - worktree gone
    echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] Agent $AGENT_ID worktree removed, exiting"
    log_agent "$AGENT_ID" "[watchdog] Exiting (agent worktree removed)" --quiet
}

# =============================================================================
# COMMAND: tree
# =============================================================================

cmd_tree() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib tree

Show all agents in a tree structure displaying manager-worker relationships.

This makes it easy to see the hierarchy of agents and which agents spawned
which sub-agents.

Examples:
  ib tree
EOF
                exit 0
                ;;
            *)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
        esac
    done

    # Ensure .ittybitty directory structure exists
    ensure_ittybitty_dirs

    # Check if agents directory exists (should exist after ensure_ittybitty_dirs, but may be empty)
    if [[ ! -d "$AGENTS_DIR" ]]; then
        echo "No agents found."
        exit 0
    fi

    # Build agent data using shared helper
    set +e
    build_agent_data_file
    set -e
    local tmpfile="$BUILD_AGENT_DATA_RESULT"
    trap "rm -f '$tmpfile'" EXIT

    if [[ ! -s "$tmpfile" ]]; then
        echo "No agents found."
        exit 0
    fi

    # Get terminal width for prompt clipping
    local term_cols
    term_cols=$(tput cols 2>/dev/null) || term_cols=0

    # Build and display tree using shared helper (no subprocess)
    build_tree_lines "$tmpfile"
    format_tree_lines "$term_cols"
    local line
    for line in "${_FORMATTED_TREE_LINES[@]}"; do
        echo "$line"
    done
}

# =============================================================================
# COMMAND: watch (undocumented)
# =============================================================================

cmd_watch() {
    # Debug mode variables (must be declared before parsing)
    local DEBUG_MODE=0
    local DEBUG_MAX_FRAMES=100
    local DEBUG_FRAME_COUNT=0

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib watch [--debug]

Full-screen dashboard for monitoring all agents.

Options:
  --debug   Performance testing mode. Enables timing instrumentation,
            allows running from agent worktrees, and auto-exits after
            1000 frames (~100 seconds). Shows timing summary on exit.

Controls:
  j/k     Select next/previous agent
  /       Quick jump to agent by name
  p/n     Cycle right pane mode (agent log → prompt → denials → tree → diff)
  d       Jump to diff pane (shows changes and merge status)
  ;/l     Scroll panes down/up
  Ctrl-C  Exit

The display shows:
  - Agent tree (top 5 lines, scrolls with selection)
  - Selected agent info (model, prompt)
  - Split view: tmux output (left) and right pane (cycling modes)
  - Right pane modes: agent log, initial prompt, denials, full tree view, diff with merge status

EOF
                exit 0
                ;;
            --debug)
                DEBUG_MODE=1
                DEBUG_WATCH_MODE=1  # Set global for use by all functions
                shift
                ;;
            *)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
        esac
    done

    # Print timing summary (called on exit)
    # Uses global DEBUG_TIMING_* arrays populated by _debug_timing_record
    debug_print_summary() {
        [[ $DEBUG_MODE -eq 0 ]] && return

        # Restore terminal state
        tput rmcup 2>/dev/null || true
        tput cnorm 2>/dev/null || true

        echo ""
        echo "ib watch --debug completed ($DEBUG_FRAME_COUNT frames)"
        echo ""
        echo "Timing Summary (averages in ms):"

        local i name count sum min max avg
        for ((i=0; i<${#DEBUG_TIMING_NAMES[@]}; i++)); do
            name="${DEBUG_TIMING_NAMES[$i]}"
            count="${DEBUG_TIMING_COUNTS[$i]}"
            sum="${DEBUG_TIMING_SUMS[$i]}"
            min="${DEBUG_TIMING_MINS[$i]}"
            max="${DEBUG_TIMING_MAXES[$i]}"

            if [[ $count -gt 0 ]]; then
                # Calculate average (integer division, then add decimal)
                local avg_int=$((sum / count))
                local avg_frac=$(( (sum * 10 / count) % 10 ))
                avg="${avg_int}.${avg_frac}"

                # Format min/max with one decimal place
                local min_int=$((min))
                local max_int=$((max))

                printf "  %-20s %6s  (min: %4d, max: %4d, count: %d)\n" \
                    "$name:" "$avg" "$min_int" "$max_int" "$count"
            fi
        done
        echo ""
    }

    # Ensure .ittybitty directory structure exists
    ensure_ittybitty_dirs

    # Validate agent metadata before starting (catches invalid meta.json early)
    validate_agent_metadata

    # Load configuration (for CONFIG_FPS, etc.)
    load_config

    # State variables
    local TERM_LINES TERM_COLS
    local SELECTED_INDEX=0
    local SELECTED_NAME=""  # Track selected agent by name for stability when list changes
    local PREV_SELECTED_INDEX=-1  # Track for scroll reset on agent change
    local AGENT_COUNT=0
    local TREE_SCROLL=0  # Which line of tree to start display from
    local SCROLL_OFFSET=0  # Shared scroll offset for both panes (0 = bottom/autoscroll)
    local RIGHT_PANE_MODE=0  # 0=agent log, 1=initial prompt, 2=denials, 3=tree, 4=errors, 5=diff
    local RIGHT_PANE_NAMES=("AGENT LOG" "INITIAL PROMPT" "DENIALS" "TREE" "ERRORS" "DIFF")

    # Dialog state variables
    local DIALOG_MODE=0  # 0=none, 1=send, 2=kill, 3=nuke, 4=new_agent, 5=jump, 6=hooks, 7=merge
    local DIALOG_WIDTH=50  # Fixed dialog width

    # Frame rate control
    local TARGET_FPS="${CONFIG_FPS:-10}"
    local TARGET_FRAME_MS=$((1000 / TARGET_FPS))
    local LAST_FRAME_MS=0
    local SLEEP_ADJUST_MS=$((TARGET_FRAME_MS * 6 / 10))  # Start at 60% of target frame time

    # Escape sequence tracking for normal mode (arrow keys)
    local _WATCH_ESC_PENDING=0  # 0=none, 1=got ESC, 2=got ESC+[

    # Send dialog state
    local SEND_TEXT=""
    local SEND_FOCUS=0   # 0=text, 1=Send button, 2=Cancel button

    # Kill dialog state
    local KILL_FOCUS=0   # 0=Cancel, 1=Kill

    # Nuke dialog state
    local NUKE_TEXT=""
    local NUKE_FOCUS=0   # 0=text, 1=Cancel, 2=Confirm

    # New agent dialog state
    local NEW_AGENT_NAME=""
    local NEW_AGENT_MODEL_INDEX=0  # 0=default, 1=opus, 2=sonnet, 3=haiku
    local NEW_AGENT_MODELS=("default" "opus" "sonnet" "haiku")
    local NEW_AGENT_PROMPT=""
    local NEW_AGENT_FOCUS=0  # 0=name, 1=model, 2=worker, 3=prompt, 4=Cancel, 5=Create

    # Jump dialog state
    local JUMP_PATTERN=""

    # Merge dialog state
    local MERGE_FOCUS=0   # 0=Cancel, 1=Feedback, 2=Merge
    local MERGE_SCROLL=0  # Scroll offset for diff view
    local MERGE_CAN_MERGE=0  # 0=unknown, 1=yes (no conflicts), 2=no (conflicts)
    local MERGE_CONFLICT_FILES=""  # List of conflicting files if any
    local MERGE_DIFF=""   # Cached diff content
    local MERGE_ERROR=""  # Error message from merge attempt

    # Setup dialog state
    # Each: 0=unknown, 1=installed, 2=not installed
    local SETUP_HOOKS_INSTALLED=0     # Safety hooks (PreToolUse hook)
    local SETUP_IB_INSTRUCTIONS=0     # <ittybitty>...</ittybitty> block in CLAUDE.md
    local SETUP_STATUS_IMPORT=0       # @.ittybitty/STATUS.md inside <ittybitty> block
    local SETUP_GITIGNORE=0           # .ittybitty in .gitignore
    local SETUP_FOCUS=0  # 0=hooks, 1=ib instructions, 2=status import, 3=gitignore, 4=Close button

    # Legacy aliases for compatibility
    local HOOKS_INSTALLED=0  # 0=unknown, 1=installed, 2=not installed
    local STATUS_MD_INTEGRATED=0  # 0=unknown, 1=integrated, 2=not integrated

    # Errors cache for async agent creation failures
    # Each entry: "TIMESTAMP|TITLE|MESSAGE"
    local -a ERRORS_CACHE=()
    local ERRORS_UNREAD_COUNT=0  # Count of unread errors
    local ERRORS_TOTAL_COUNT=0   # Total count of errors (for skip logic)

    # Usage tracking state (refreshed periodically)
    local USAGE_SESSION_PCT=""   # 5-hour session utilization percentage
    local USAGE_WEEKLY_PCT=""    # 7-day weekly utilization percentage
    local USAGE_LAST_FETCH=0     # Timestamp of last successful fetch
    local USAGE_FETCH_INTERVAL=30  # Seconds between API calls

    # Check if main repo safety hooks are installed
    watch_check_hooks_status() {
        local status
        status=$(cmd_hooks_status 2>/dev/null)
        if [[ "$status" == "installed" ]]; then
            SETUP_HOOKS_INSTALLED=1
            HOOKS_INSTALLED=1  # Legacy
        else
            SETUP_HOOKS_INSTALLED=2
            HOOKS_INSTALLED=2  # Legacy
        fi
    }

    # Check if <ittybitty>...</ittybitty> block exists in CLAUDE.md
    watch_check_ib_instructions() {
        local claude_md="$ROOT_REPO_PATH/CLAUDE.md"
        if [[ -f "$claude_md" ]]; then
            local content
            content=$(cat "$claude_md")
            if check_claude_md_has_ittybitty_block "$content"; then
                SETUP_IB_INSTRUCTIONS=1
            else
                SETUP_IB_INSTRUCTIONS=2
            fi
        else
            SETUP_IB_INSTRUCTIONS=2
        fi
    }

    # Check if @.ittybitty/STATUS.md import exists inside <ittybitty> block
    watch_check_status_import() {
        local claude_md="$ROOT_REPO_PATH/CLAUDE.md"
        if [[ -f "$claude_md" ]]; then
            local content
            content=$(cat "$claude_md")
            if check_claude_md_has_status_import "$content"; then
                SETUP_STATUS_IMPORT=1
                STATUS_MD_INTEGRATED=1  # Legacy
            else
                SETUP_STATUS_IMPORT=2
                STATUS_MD_INTEGRATED=2  # Legacy
            fi
        else
            SETUP_STATUS_IMPORT=2
            STATUS_MD_INTEGRATED=2  # Legacy
        fi
    }

    # Check if .ittybitty is in .gitignore
    watch_check_gitignore() {
        local gitignore="$ROOT_REPO_PATH/.gitignore"
        if [[ -f "$gitignore" ]]; then
            local content
            content=$(cat "$gitignore")
            if check_gitignore_has_ittybitty "$content"; then
                SETUP_GITIGNORE=1
            else
                SETUP_GITIGNORE=2
            fi
        else
            SETUP_GITIGNORE=2
        fi
    }

    # Check all setup items on startup
    watch_check_all_setup() {
        watch_check_hooks_status
        watch_check_ib_instructions
        watch_check_status_import
        watch_check_gitignore
    }

    # Check all setup items on startup
    watch_check_all_setup

    # Refresh usage data if interval has elapsed
    watch_refresh_usage() {
        local now
        now=$(date +%s)
        if [[ $((now - USAGE_LAST_FETCH)) -ge $USAGE_FETCH_INTERVAL ]]; then
            USAGE_LAST_FETCH=$now
            if fetch_claude_usage; then
                USAGE_SESSION_PCT="$_USAGE_SESSION_PCT"
                USAGE_WEEKLY_PCT="$_USAGE_WEEKLY_PCT"
            fi
        fi
    }

    # Fetch usage on startup
    watch_refresh_usage

    # Refresh CLAUDE.md status on watch startup
    update_claude_status

    # Add an error to the errors file (can be called from subshells)
    # Args: $1=errors_file, $2=title, $3=message
    watch_add_error_to_file() {
        local errors_file="$1"
        local title="$2"
        local message="$3"
        local timestamp
        timestamp=$(date +%H:%M:%S)
        # Atomic append to file (escape any | in message)
        local safe_message="${message//|/ }"
        echo "$timestamp|$title|$safe_message" >> "$errors_file"
    }

    # Load errors from file into cache array (called from main loop)
    watch_load_errors_from_file() {
        [[ -z "$ERRORS_FILE" || ! -f "$ERRORS_FILE" ]] && return
        local line
        local count_before=${#ERRORS_CACHE[@]}
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            ERRORS_CACHE+=("$line")
        done < "$ERRORS_FILE"
        local count_after=${#ERRORS_CACHE[@]}
        local new_errors=$((count_after - count_before))
        if [[ $new_errors -gt 0 ]]; then
            ERRORS_UNREAD_COUNT=$((ERRORS_UNREAD_COUNT + new_errors))
            ERRORS_TOTAL_COUNT=$((ERRORS_TOTAL_COUNT + new_errors))
        fi
        # Clear the file after loading
        : > "$ERRORS_FILE"
    }

    # Clear all errors from the cache
    watch_clear_errors() {
        ERRORS_CACHE=()
        ERRORS_UNREAD_COUNT=0
        ERRORS_TOTAL_COUNT=0
    }

    # Mark all errors as read (reset unread count)
    watch_mark_errors_read() {
        ERRORS_UNREAD_COUNT=0
    }

    # Calculate next pane mode, skipping errors pane (mode 4) if no errors
    # Args: $1=direction (1 for next, -1 for previous)
    # Sets: _NEXT_PANE_MODE
    watch_calc_next_pane() {
        local direction="$1"
        local pane_count=${#RIGHT_PANE_NAMES[@]}
        local next_mode=$(( (RIGHT_PANE_MODE + direction + pane_count) % pane_count ))

        # Skip errors pane (mode 4) if there are no errors
        # Use ERRORS_TOTAL_COUNT instead of array length for reliable cross-function access
        if [[ $next_mode -eq 4 && $ERRORS_TOTAL_COUNT -eq 0 ]]; then
            next_mode=$(( (next_mode + direction + pane_count) % pane_count ))
        fi

        _NEXT_PANE_MODE=$next_mode
    }

    # Handle pane mode changes - start/stop background collectors as needed
    # Args: $1=new_mode, $2=selected_agent_id (optional, for diff mode)
    watch_set_pane_mode() {
        local new_mode="$1"
        local selected_id="${2:-}"
        local old_mode=$RIGHT_PANE_MODE

        # Stop denials collector when leaving denials mode
        if [[ $old_mode -eq 2 && $new_mode -ne 2 ]]; then
            stop_denials_collector
        fi

        # Start denials collector when entering denials mode
        if [[ $old_mode -ne 2 && $new_mode -eq 2 ]]; then
            start_denials_collector
        fi

        # Stop diff collector when leaving diff mode
        if [[ $old_mode -eq 5 && $new_mode -ne 5 ]]; then
            stop_diff_collector
        fi

        # Start diff collector when entering diff mode (needs agent id)
        if [[ $old_mode -ne 5 && $new_mode -eq 5 && -n "$selected_id" ]]; then
            start_diff_collector "$selected_id"
        fi

        RIGHT_PANE_MODE=$new_mode
    }

    # Cleanup function for exit
    watch_cleanup() {
        # Stop background collectors
        stop_denials_collector
        stop_diff_collector
        # Only restore terminal state if not in debug mode
        if [[ $DEBUG_MODE -eq 0 ]]; then
            stty echo    # Restore terminal echo
            tput cnorm   # Show cursor
            tput clear   # Clear screen
            echo "Exited ib watch"
        fi
    }

    # Trap Ctrl-C and other exits
    trap watch_cleanup EXIT

    # Hide cursor and disable terminal echo (skip in debug mode - no TTY)
    if [[ $DEBUG_MODE -eq 0 ]]; then
        tput civis
        stty -echo
    fi

    # Helper to get current time in milliseconds
    # Note: This is also duplicated in build_agent_data_file for debug timing
    # (can't call this function from outside cmd_watch)
    get_ms() {
        perl -MTime::HiRes -e 'printf "%d", Time::HiRes::time * 1000' 2>/dev/null || date +%s000
    }

    # ==========================================================================
    # Color/Formatting Helper Functions
    # ==========================================================================

    # ANSI color codes for consistent styling
    local COLOR_DIM=$'\e[2m'       # Dim/faint text
    local COLOR_CYAN=$'\e[36m'     # Cyan for brackets/blocks
    local COLOR_YELLOW=$'\e[33m'   # Yellow for warnings (>80%)
    local COLOR_RED=$'\e[31m'      # Red for critical (>90%), diff removals
    local COLOR_GREEN=$'\e[32m'    # Green for diff additions
    local COLOR_RESET=$'\e[0m'     # Reset all attributes

    # Colorize a log line for agent log display
    # - Makes ISO timestamps at line start dim
    # - Colors other [...] blocks in cyan
    # Args: $1=line
    # Sets: _COLORIZED_LINE
    # Performance: O(n) where n is number of bracket pairs (typically 1-2)
    colorize_log_line() {
        local line="$1"
        local result=""
        local remaining

        # Check for ISO timestamp at start: [2026-01-14T...] or [YYYY-MM-DD...]
        # Uses bash regex - much faster than character iteration
        if [[ "$line" =~ ^\[([0-9][^]]*)\](.*) ]]; then
            result="${COLOR_DIM}[${BASH_REMATCH[1]}]${COLOR_RESET}"
            remaining="${BASH_REMATCH[2]}"
        else
            remaining="$line"
        fi

        # Colorize remaining [...] blocks in cyan
        # Each iteration handles one bracket pair - typically 0-2 iterations
        while [[ "$remaining" =~ ^([^[]*)(\[[^]]*\])(.*)$ ]]; do
            result="${result}${BASH_REMATCH[1]}${COLOR_CYAN}${BASH_REMATCH[2]}${COLOR_RESET}"
            remaining="${BASH_REMATCH[3]}"
        done
        result="${result}${remaining}"

        _COLORIZED_LINE="$result"
    }

    # Colorize a diff line for diff panel display
    # - Green for addition lines (+)
    # - Red for removal lines (-)
    # - Dim grey for file headers (diff, index, ---, +++, @@)
    # Args: $1=line
    # Sets: _COLORIZED_LINE
    # Performance: O(1) - single character check
    colorize_diff_line() {
        local line="$1"
        local first_char="${line:0:1}"
        local first_two="${line:0:2}"
        local first_three="${line:0:3}"
        local first_four="${line:0:4}"

        # Check for file headers (grey/dim)
        # Order matters: check longer prefixes first
        if [[ "$first_four" == "diff" || "$first_four" == "inde" ]]; then
            # diff --git or index lines
            _COLORIZED_LINE="${COLOR_DIM}${line}${COLOR_RESET}"
        elif [[ "$first_three" == "---" || "$first_three" == "+++" ]]; then
            # File path markers
            _COLORIZED_LINE="${COLOR_DIM}${line}${COLOR_RESET}"
        elif [[ "$first_two" == "@@" ]]; then
            # Hunk headers
            _COLORIZED_LINE="${COLOR_DIM}${line}${COLOR_RESET}"
        elif [[ "$first_char" == "+" ]]; then
            # Addition lines (green)
            _COLORIZED_LINE="${COLOR_GREEN}${line}${COLOR_RESET}"
        elif [[ "$first_char" == "-" ]]; then
            # Removal lines (red)
            _COLORIZED_LINE="${COLOR_RED}${line}${COLOR_RESET}"
        else
            # Context lines and other content (no color)
            _COLORIZED_LINE="$line"
        fi
    }

    # Format session percentage with color coding
    # - Yellow if >80%
    # - Red if >90%
    # Args: $1=percentage (number without %)
    # Returns: colored string with % (restores dim after color)
    format_usage_pct() {
        local pct="$1"
        local label="$2"  # "session" or "weekly"
        if [[ -z "$pct" ]]; then
            echo ""
            return
        fi
        local pct_num="${pct%.*}"  # Remove decimal part if any
        if [[ $pct_num -gt 90 ]]; then
            echo "${COLOR_RED}${label}:${pct}%${COLOR_RESET}${COLOR_DIM}"
        elif [[ $pct_num -gt 80 ]]; then
            echo "${COLOR_YELLOW}${label}:${pct}%${COLOR_RESET}${COLOR_DIM}"
        else
            echo "${label}:${pct}%"
        fi
    }

    # ==========================================================================
    # Dialog Helper Functions
    # ==========================================================================

    # Calculate starting column for centered dialog
    # Sets: _DIALOG_START_COL
    dialog_calc_position() {
        _DIALOG_START_COL=$(( (TERM_COLS - DIALOG_WIDTH) / 2 ))
        [[ $_DIALOG_START_COL -lt 1 ]] && _DIALOG_START_COL=1
    }

    # Draw a horizontal line with box-drawing characters
    # Args: $1=row, $2=left_char, $3=fill_char, $4=right_char
    dialog_draw_hline() {
        local row="$1" left="$2" fill="$3" right="$4"
        local inner_width=$((DIALOG_WIDTH - 2))
        printf '\e[%d;%dH%s' "$row" "$_DIALOG_START_COL" "$left"
        local i
        for ((i=0; i<inner_width; i++)); do
            printf '%s' "$fill"
        done
        printf '%s' "$right"
    }

    # Draw a content line with box borders
    # Args: $1=row, $2=content (will be padded/truncated to fit)
    dialog_draw_line() {
        local row="$1" content="$2"
        local inner_width=$((DIALOG_WIDTH - 4))  # 2 for borders, 2 for padding
        printf '\e[%d;%dH│ %-*.*s │' "$row" "$_DIALOG_START_COL" "$inner_width" "$inner_width" "$content"
    }

    # Draw a button, optionally highlighted
    # Args: $1=label, $2=highlighted (0/1), $3=disabled (0/1, optional)
    # Returns: the button string
    dialog_format_button() {
        local label="$1" highlighted="$2" disabled="${3:-0}"
        if [[ "$disabled" == "1" ]]; then
            # Dim disabled button
            printf '\e[2m[%s]\e[0m' "$label"
        elif [[ "$highlighted" == "1" ]]; then
            # Reverse video for highlighted
            printf '\e[7m[%s]\e[0m' "$label"
        else
            printf '[%s]' "$label"
        fi
    }

    # Draw a text input field
    # Args: $1=value, $2=width, $3=focused (0/1)
    # Returns: the input field string
    dialog_format_input() {
        local value="$1" width="$2" focused="${3:-0}"
        local display_value="${value:0:$width}"
        local padding=$((width - ${#display_value}))
        if [[ "$focused" == "1" ]]; then
            # Show cursor indicator when focused
            printf '\e[7m%s%*s\e[0m' "$display_value" "$padding" ""
        else
            printf '[%s%*s]' "$display_value" "$((padding))" ""
        fi
    }

    # Clear the dialog area (fill with spaces)
    dialog_clear() {
        local start_row="$1" height="$2"
        local blank_line
        printf -v blank_line '%*s' "$DIALOG_WIDTH" ''
        local row
        for ((row=start_row; row<start_row+height; row++)); do
            printf '\e[%d;%dH%s' "$row" "$_DIALOG_START_COL" "$blank_line"
        done
    }

    # Delete word backwards from text (option+delete behavior)
    # Sets _DIALOG_TEXT_RESULT with the result
    # Args: $1=text
    dialog_delete_word() {
        local text="$1"
        # Delete trailing whitespace first (if any)
        while [[ -n "$text" && "${text: -1}" =~ [[:space:]] ]]; do
            text="${text%?}"
        done
        # Then delete non-whitespace (the word)
        while [[ -n "$text" && ! "${text: -1}" =~ [[:space:]] ]]; do
            text="${text%?}"
        done
        _DIALOG_TEXT_RESULT="$text"
    }

    # Delete to start of line (Ctrl+U behavior)
    # Sets _DIALOG_TEXT_RESULT with the result
    # Args: $1=text
    dialog_delete_line() {
        local text="$1"
        if [[ "$text" == *$'\n'* ]]; then
            # Delete back to last newline (keep the newline)
            _DIALOG_TEXT_RESULT="${text%$'\n'*}"$'\n'
        else
            # No newline, delete everything
            _DIALOG_TEXT_RESULT=""
        fi
    }

    # ==========================================================================
    # End Dialog Helper Functions
    # ==========================================================================

    # ==========================================================================
    # Kill Dialog (DIALOG_MODE=2)
    # ==========================================================================

    watch_dialog_init_kill() {
        KILL_FOCUS=0  # Default to Cancel
        _DIALOG_ESC_PENDING=0
        _DIALOG_DIRTY=1  # Force initial render
    }

    watch_dialog_render_kill() {
        # Check if a pending escape should close the dialog (no sequence followed)
        if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
            DIALOG_MODE=0
            _DIALOG_ESC_PENDING=0
            return
        fi

        # Only redraw when dirty (reduces flicker)
        [[ "${_DIALOG_DIRTY:-0}" != "1" ]] && return
        _DIALOG_DIRTY=0

        # Get terminal size
        TERM_LINES=$(tput lines)
        TERM_COLS=$(tput cols)

        # Calculate dialog position (centered)
        dialog_calc_position
        local start_row=$(( (TERM_LINES - 7) / 2 ))  # 7 lines tall
        [[ $start_row -lt 1 ]] && start_row=1

        # Clear dialog area
        dialog_clear "$start_row" 7

        # Draw dialog box
        local row=$start_row
        dialog_draw_hline "$row" "┌" "─" "┐"
        ((row++))

        # Title
        dialog_draw_line "$row" "Kill agent '$_WATCH_SELECTED_ID'?"
        ((row++))

        # Blank line
        dialog_draw_line "$row" ""
        ((row++))

        # Description
        dialog_draw_line "$row" "This will terminate the agent and"
        ((row++))
        dialog_draw_line "$row" "discard all uncommitted work."
        ((row++))

        # Blank line with buttons
        local cancel_btn=$(dialog_format_button "Cancel" "$([[ $KILL_FOCUS -eq 0 ]] && echo 1 || echo 0)")
        local kill_btn=$(dialog_format_button "Kill" "$([[ $KILL_FOCUS -eq 1 ]] && echo 1 || echo 0)")
        # Simple centered button line (visual width: [Cancel] = 8, [Kill] = 6, gap = 4, total = 18)
        local inner_width=$((DIALOG_WIDTH - 4))
        local btn_visual_width=18
        local left_pad=$(( (inner_width - btn_visual_width) / 2 ))
        local right_pad=$((inner_width - btn_visual_width - left_pad))
        printf '\e[%d;%dH│ %*s%s    %s%*s │' "$row" "$_DIALOG_START_COL" "$left_pad" "" "$cancel_btn" "$kill_btn" "$right_pad" ""
        ((row++))

        # Bottom border
        dialog_draw_hline "$row" "└" "─" "┘"

        # Footer hint
        ((row++))
        printf '\e[%d;%dH' "$row" "$_DIALOG_START_COL"
        printf '%*s' "$DIALOG_WIDTH" ''
        printf '\e[%d;%dH%s' "$row" "$(( _DIALOG_START_COL + (DIALOG_WIDTH - 28) / 2 ))" "Tab: switch   Enter: select"
    }

    watch_dialog_key_kill() {
        local key="$1"
        case "$key" in
            $'\t')  # Tab - forward
                KILL_FOCUS=$(( (KILL_FOCUS + 1) % 2 ))
                _DIALOG_DIRTY=1
                ;;
            $'\x1e')  # Enter (record separator marker from key reader)
                if [[ $KILL_FOCUS -eq 1 ]]; then
                    # Kill confirmed - execute kill command
                    DIALOG_MODE=0
                    # Run kill in background and refresh
                    cmd_kill --force "$_WATCH_SELECTED_ID" >/dev/null 2>&1 &
                else
                    # Cancel
                    DIALOG_MODE=0
                fi
                ;;
            $'\e')  # Escape - but need to check if it's a sequence
                _DIALOG_ESC_PENDING=1
                ;;
            '[')  # Part of escape sequence
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                    _DIALOG_ESC_PENDING=2  # Now expecting the direction char
                fi
                ;;
            'Z')  # Shift+Tab (part of \e[Z sequence)
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    # Shift+Tab - backward
                    KILL_FOCUS=$(( (KILL_FOCUS - 1 + 2) % 2 ))
                    _DIALOG_ESC_PENDING=0
                    _DIALOG_DIRTY=1
                fi
                ;;
            'A'|'D')  # Up or Left arrow - same as Shift+Tab (backward)
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    KILL_FOCUS=$(( (KILL_FOCUS - 1 + 2) % 2 ))
                    _DIALOG_ESC_PENDING=0
                    _DIALOG_DIRTY=1
                fi
                ;;
            'B'|'C')  # Down or Right arrow - same as Tab (forward)
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    KILL_FOCUS=$(( (KILL_FOCUS + 1) % 2 ))
                    _DIALOG_ESC_PENDING=0
                    _DIALOG_DIRTY=1
                fi
                ;;
            *)  # Any other key
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                    # Was a real escape (no sequence followed)
                    DIALOG_MODE=0
                fi
                _DIALOG_ESC_PENDING=0
                ;;
        esac
    }

    # ==========================================================================
    # End Kill Dialog
    # ==========================================================================

    # ==========================================================================
    # Send Dialog (DIALOG_MODE=1)
    # ==========================================================================

    watch_dialog_init_send() {
        SEND_TEXT=""
        SEND_FOCUS=0  # 0=text, 1=Send button, 2=Cancel button
        _DIALOG_ESC_PENDING=0
        _DIALOG_DIRTY=1
    }

    watch_dialog_render_send() {
        # Check if a pending escape should close the dialog
        if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
            DIALOG_MODE=0
            _DIALOG_ESC_PENDING=0
            return
        fi

        # Only redraw when dirty
        [[ "${_DIALOG_DIRTY:-0}" != "1" ]] && return
        _DIALOG_DIRTY=0

        # Get terminal size
        TERM_LINES=$(tput lines)
        TERM_COLS=$(tput cols)

        # Calculate dialog position (centered)
        dialog_calc_position
        local dialog_height=13  # Total dialog height
        local text_area_height=4  # Lines in the text area
        local start_row=$(( (TERM_LINES - dialog_height) / 2 ))
        [[ $start_row -lt 1 ]] && start_row=1

        # Clear dialog area
        dialog_clear "$start_row" "$((dialog_height + 1))"

        # Draw dialog box
        local row=$start_row
        dialog_draw_hline "$row" "┌" "─" "┐"
        ((row++))

        # Title with agent name
        local title="Send message to: $_WATCH_SELECTED_ID"
        dialog_draw_line "$row" "$title"
        ((row++))

        # Separator
        dialog_draw_hline "$row" "├" "─" "┤"
        ((row++))

        # Instruction
        dialog_draw_line "$row" "Type message (Enter for newline):"
        ((row++))

        # Text area box - top border
        # inner_width = space between outer │ borders (46 for DIALOG_WIDTH=50)
        # text_width = space for content inside inner │ borders
        # Both lines: │ ┌───┐ │ and │ │xxx│ │ should total DIALOG_WIDTH
        # │ ┌ (3) + dashes + ┐ │ (3) = 50, so dashes = 44
        # │ │ (3) + content + │ │ (3) = 50, so content = 44
        local inner_width=$((DIALOG_WIDTH - 4))
        local text_width=$((inner_width - 2))  # 44 chars for content
        printf '\e[%d;%dH│ ┌' "$row" "$_DIALOG_START_COL"
        local i
        for ((i=0; i<text_width; i++)); do printf '─'; done
        printf '┐ │'
        ((row++))

        # Parse text into lines and display in text area
        local text_focused=$([[ $SEND_FOCUS -eq 0 ]] && echo 1 || echo 0)
        local display_text="$SEND_TEXT"
        [[ $text_focused == "1" ]] && display_text="${display_text}_"

        # Split text by newlines and wrap long lines
        local -a display_lines=()
        local line=""
        local char
        local len=${#display_text}
        for ((i=0; i<len; i++)); do
            char="${display_text:$i:1}"
            if [[ "$char" == $'\n' ]]; then
                display_lines+=("$line")
                line=""
            else
                line="${line}${char}"
                if [[ ${#line} -ge $text_width ]]; then
                    display_lines+=("$line")
                    line=""
                fi
            fi
        done
        [[ -n "$line" ]] && display_lines+=("$line")

        # Show last 4 lines (scroll to bottom)
        local total_lines=${#display_lines[@]}
        local start_line=0
        if [[ $total_lines -gt $text_area_height ]]; then
            start_line=$((total_lines - text_area_height))
        fi

        # Draw text area lines
        local line_idx
        for ((line_idx=0; line_idx<text_area_height; line_idx++)); do
            local content_idx=$((start_line + line_idx))
            local content=""
            if [[ $content_idx -lt $total_lines ]]; then
                content="${display_lines[$content_idx]}"
            fi
            printf '\e[%d;%dH│ │' "$row" "$_DIALOG_START_COL"
            if [[ $text_focused == "1" ]]; then
                printf '\e[7m%-*s\e[0m' "$text_width" "$content"
            else
                printf '%-*s' "$text_width" "$content"
            fi
            printf '│ │'
            ((row++))
        done

        # Text area box - bottom border
        printf '\e[%d;%dH│ └' "$row" "$_DIALOG_START_COL"
        for ((i=0; i<text_width; i++)); do printf '─'; done
        printf '┘ │'
        ((row++))

        # Blank line
        dialog_draw_line "$row" ""
        ((row++))

        # Buttons (Cancel on left, Send on right)
        local send_disabled=$([[ -z "$SEND_TEXT" ]] && echo 1 || echo 0)
        local cancel_btn=$(dialog_format_button "Cancel" "$([[ $SEND_FOCUS -eq 1 ]] && echo 1 || echo 0)")
        local send_btn=$(dialog_format_button "Send" "$([[ $SEND_FOCUS -eq 2 ]] && echo 1 || echo 0)" "$send_disabled")
        local btn_visual_width=18  # [Cancel] = 8, [Send] = 6, gap = 4
        local left_pad=$(( (inner_width - btn_visual_width) / 2 ))
        local right_pad=$((inner_width - btn_visual_width - left_pad))
        printf '\e[%d;%dH│ %*s%s    %s%*s │' "$row" "$_DIALOG_START_COL" "$left_pad" "" "$cancel_btn" "$send_btn" "$right_pad" ""
        ((row++))

        # Bottom border
        dialog_draw_hline "$row" "└" "─" "┘"

        # Footer hint
        ((row++))
        printf '\e[%d;%dH' "$row" "$_DIALOG_START_COL"
        printf '%*s' "$DIALOG_WIDTH" ''
        printf '\e[%d;%dH%s' "$row" "$(( _DIALOG_START_COL + (DIALOG_WIDTH - 28) / 2 ))" "Tab: switch   Enter: select"
    }

    watch_dialog_key_send() {
        local key="$1"
        # Focus: 0=text, 1=Cancel, 2=Send
        case "$key" in
            $'\t')  # Tab - forward
                if [[ -z "$SEND_TEXT" ]]; then
                    # Skip Send button (focus 2) when text is empty
                    SEND_FOCUS=$(( SEND_FOCUS == 0 ? 1 : 0 ))
                else
                    SEND_FOCUS=$(( (SEND_FOCUS + 1) % 3 ))
                fi
                _DIALOG_DIRTY=1
                ;;
            $'\x1e')  # Enter
                if [[ $SEND_FOCUS -eq 0 ]]; then
                    # In text area, add newline
                    SEND_TEXT="${SEND_TEXT}"$'\n'
                    _DIALOG_DIRTY=1
                elif [[ $SEND_FOCUS -eq 1 ]]; then
                    # Cancel button
                    DIALOG_MODE=0
                elif [[ $SEND_FOCUS -eq 2 && -n "$SEND_TEXT" ]]; then
                    # Send button
                    DIALOG_MODE=0
                    cmd_send "$_WATCH_SELECTED_ID" "$SEND_TEXT" >/dev/null 2>&1 &
                fi
                ;;
            $'\e')  # Escape - check for sequence
                _DIALOG_ESC_PENDING=1
                ;;
            '[')  # Part of escape sequence
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                    _DIALOG_ESC_PENDING=2
                elif [[ $SEND_FOCUS -eq 0 ]]; then
                    # Typing in text field
                    SEND_TEXT="${SEND_TEXT}["
                    _DIALOG_DIRTY=1
                fi
                ;;
            'Z')  # Shift+Tab (part of \e[Z sequence)
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    # Shift+Tab - backward
                    if [[ -z "$SEND_TEXT" ]]; then
                        # Skip Send button (focus 2) when text is empty
                        SEND_FOCUS=$(( SEND_FOCUS == 0 ? 1 : 0 ))
                    else
                        SEND_FOCUS=$(( (SEND_FOCUS - 1 + 3) % 3 ))
                    fi
                    _DIALOG_ESC_PENDING=0
                    _DIALOG_DIRTY=1
                elif [[ $SEND_FOCUS -eq 0 ]]; then
                    # Typing in text field
                    SEND_TEXT="${SEND_TEXT}Z"
                    _DIALOG_DIRTY=1
                fi
                ;;
            'A'|'B'|'C'|'D')  # Arrow keys (as part of escape sequence) or regular letters
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    # Arrow key sequence - navigate focus
                    if [[ "$key" == "A" || "$key" == "D" ]]; then
                        # Up or Left arrow - backward
                        if [[ -z "$SEND_TEXT" ]]; then
                            SEND_FOCUS=$(( SEND_FOCUS == 0 ? 1 : 0 ))
                        else
                            SEND_FOCUS=$(( (SEND_FOCUS - 1 + 3) % 3 ))
                        fi
                    else
                        # Down or Right arrow - forward
                        if [[ -z "$SEND_TEXT" ]]; then
                            SEND_FOCUS=$(( SEND_FOCUS == 0 ? 1 : 0 ))
                        else
                            SEND_FOCUS=$(( (SEND_FOCUS + 1) % 3 ))
                        fi
                    fi
                    _DIALOG_ESC_PENDING=0
                    _DIALOG_DIRTY=1
                elif [[ $SEND_FOCUS -eq 0 ]]; then
                    # Typing in text field - add the letter
                    SEND_TEXT="${SEND_TEXT}${key}"
                    _DIALOG_DIRTY=1
                fi
                ;;
            $'\x15')  # Ctrl+U - delete to start of line
                if [[ $SEND_FOCUS -eq 0 && -n "$SEND_TEXT" ]]; then
                    dialog_delete_line "$SEND_TEXT"
                    SEND_TEXT="$_DIALOG_TEXT_RESULT"
                    _DIALOG_DIRTY=1
                fi
                ;;
            $'\x7f'|$'\b')  # Backspace (DEL or BS)
                if [[ $SEND_FOCUS -eq 0 && -n "$SEND_TEXT" ]]; then
                    if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                        # Option+Delete - delete word
                        dialog_delete_word "$SEND_TEXT"
                        SEND_TEXT="$_DIALOG_TEXT_RESULT"
                        _DIALOG_ESC_PENDING=0
                    else
                        # Regular backspace - delete one char
                        SEND_TEXT="${SEND_TEXT%?}"
                    fi
                    _DIALOG_DIRTY=1
                fi
                ;;
            *)  # Any other key
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                    DIALOG_MODE=0
                    _DIALOG_ESC_PENDING=0
                elif [[ $SEND_FOCUS -eq 0 ]]; then
                    # Typing in text field
                    SEND_TEXT="${SEND_TEXT}${key}"
                    _DIALOG_DIRTY=1
                fi
                _DIALOG_ESC_PENDING=0
                ;;
        esac
    }

    # ==========================================================================
    # End Send Dialog
    # ==========================================================================

    # ==========================================================================
    # Nuke Dialog (DIALOG_MODE=3)
    # ==========================================================================

    watch_dialog_init_nuke() {
        NUKE_TEXT=""
        NUKE_FOCUS=0  # 0=text, 1=Cancel, 2=Confirm
        _DIALOG_ESC_PENDING=0
        _DIALOG_DIRTY=1
    }

    watch_dialog_render_nuke() {
        # Check if a pending escape should close the dialog
        if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
            DIALOG_MODE=0
            _DIALOG_ESC_PENDING=0
            return
        fi

        # Only redraw when dirty
        [[ "${_DIALOG_DIRTY:-0}" != "1" ]] && return
        _DIALOG_DIRTY=0

        # Get terminal size
        TERM_LINES=$(tput lines)
        TERM_COLS=$(tput cols)

        # Calculate dialog position (centered)
        dialog_calc_position
        local start_row=$(( (TERM_LINES - 9) / 2 ))  # 9 lines tall
        [[ $start_row -lt 1 ]] && start_row=1

        # Clear dialog area
        dialog_clear "$start_row" 10

        # Draw dialog box
        local row=$start_row
        dialog_draw_hline "$row" "┌" "─" "┐"
        ((row++))

        # Title
        dialog_draw_line "$row" "NUKE: Terminate ALL agents"
        ((row++))

        # Blank line
        dialog_draw_line "$row" ""
        ((row++))

        # Description
        dialog_draw_line "$row" "This will kill all agents and discard"
        ((row++))
        dialog_draw_line "$row" "all uncommitted work permanently."
        ((row++))

        # Blank line
        dialog_draw_line "$row" ""
        ((row++))

        # Text input line
        local input_focused=$([[ $NUKE_FOCUS -eq 0 ]] && echo 1 || echo 0)
        local input_display="${NUKE_TEXT}"
        [[ $input_focused == "1" ]] && input_display="${input_display}_"
        printf '\e[%d;%dH│ Type NUKE to confirm: ' "$row" "$_DIALOG_START_COL"
        if [[ $input_focused == "1" ]]; then
            printf '\e[7m%-10s\e[0m' "$input_display"
        else
            printf '%-10s' "$input_display"
        fi
        local remaining=$((DIALOG_WIDTH - 35))
        printf '%*s│' "$remaining" ""
        ((row++))

        # Blank line with buttons
        local confirm_disabled=$([[ "$NUKE_TEXT" != "NUKE" ]] && echo 1 || echo 0)
        local cancel_btn=$(dialog_format_button "Cancel" "$([[ $NUKE_FOCUS -eq 1 ]] && echo 1 || echo 0)")
        local confirm_btn=$(dialog_format_button "Confirm" "$([[ $NUKE_FOCUS -eq 2 ]] && echo 1 || echo 0)" "$confirm_disabled")
        local inner_width=$((DIALOG_WIDTH - 4))
        local btn_visual_width=19  # [Cancel] = 8, [Confirm] = 9, gap = 4
        local left_pad=$(( (inner_width - btn_visual_width) / 2 ))
        local right_pad=$((inner_width - btn_visual_width - left_pad))
        printf '\e[%d;%dH│ %*s%s    %s%*s │' "$row" "$_DIALOG_START_COL" "$left_pad" "" "$cancel_btn" "$confirm_btn" "$right_pad" ""
        ((row++))

        # Bottom border
        dialog_draw_hline "$row" "└" "─" "┘"

        # Footer hint
        ((row++))
        printf '\e[%d;%dH' "$row" "$_DIALOG_START_COL"
        printf '%*s' "$DIALOG_WIDTH" ''
        printf '\e[%d;%dH%s' "$row" "$(( _DIALOG_START_COL + (DIALOG_WIDTH - 28) / 2 ))" "Tab: switch   Enter: select"
    }

    watch_dialog_key_nuke() {
        local key="$1"
        case "$key" in
            $'\t')  # Tab - forward
                if [[ "$NUKE_TEXT" == "NUKE" ]]; then
                    # All 3 fields available
                    NUKE_FOCUS=$(( (NUKE_FOCUS + 1) % 3 ))
                else
                    # Skip Confirm (only text and Cancel)
                    NUKE_FOCUS=$(( (NUKE_FOCUS + 1) % 2 ))
                fi
                _DIALOG_DIRTY=1
                ;;
            $'\x1e')  # Enter
                if [[ $NUKE_FOCUS -eq 1 ]]; then
                    # Cancel
                    DIALOG_MODE=0
                elif [[ $NUKE_FOCUS -eq 2 && "$NUKE_TEXT" == "NUKE" ]]; then
                    # Confirm - execute nuke command
                    DIALOG_MODE=0
                    cmd_nuke --force >/dev/null 2>&1 &
                fi
                # If focus is on text input, Enter does nothing
                ;;
            $'\e')  # Escape - check for sequence
                _DIALOG_ESC_PENDING=1
                ;;
            '[')  # Part of escape sequence
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                    _DIALOG_ESC_PENDING=2
                elif [[ $NUKE_FOCUS -eq 0 ]]; then
                    # Typing in text field
                    if [[ ${#NUKE_TEXT} -lt 4 ]]; then
                        NUKE_TEXT="${NUKE_TEXT}["
                        _DIALOG_DIRTY=1
                    fi
                fi
                ;;
            'Z')  # Shift+Tab (part of \e[Z sequence)
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    # Shift+Tab - backward
                    if [[ "$NUKE_TEXT" == "NUKE" ]]; then
                        NUKE_FOCUS=$(( (NUKE_FOCUS - 1 + 3) % 3 ))
                    else
                        NUKE_FOCUS=$(( (NUKE_FOCUS - 1 + 2) % 2 ))
                    fi
                    _DIALOG_ESC_PENDING=0
                    _DIALOG_DIRTY=1
                elif [[ $NUKE_FOCUS -eq 0 ]]; then
                    # Typing in text field
                    if [[ ${#NUKE_TEXT} -lt 4 ]]; then
                        NUKE_TEXT="${NUKE_TEXT}Z"
                        _DIALOG_DIRTY=1
                    fi
                fi
                ;;
            'A'|'B'|'C'|'D')  # Arrow keys (as part of escape sequence) or regular letters
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    # Arrow key sequence - navigate focus
                    if [[ "$key" == "A" || "$key" == "D" ]]; then
                        # Up or Left arrow - backward
                        if [[ "$NUKE_TEXT" == "NUKE" ]]; then
                            NUKE_FOCUS=$(( (NUKE_FOCUS - 1 + 3) % 3 ))
                        else
                            NUKE_FOCUS=$(( (NUKE_FOCUS - 1 + 2) % 2 ))
                        fi
                    else
                        # Down or Right arrow - forward
                        if [[ "$NUKE_TEXT" == "NUKE" ]]; then
                            NUKE_FOCUS=$(( (NUKE_FOCUS + 1) % 3 ))
                        else
                            NUKE_FOCUS=$(( (NUKE_FOCUS + 1) % 2 ))
                        fi
                    fi
                    _DIALOG_ESC_PENDING=0
                    _DIALOG_DIRTY=1
                elif [[ $NUKE_FOCUS -eq 0 ]]; then
                    # Typing in text field (limit to 4 chars)
                    if [[ ${#NUKE_TEXT} -lt 4 ]]; then
                        NUKE_TEXT="${NUKE_TEXT}${key}"
                        _DIALOG_DIRTY=1
                    fi
                fi
                ;;
            $'\x15')  # Ctrl+U - delete all (single line input)
                if [[ $NUKE_FOCUS -eq 0 && -n "$NUKE_TEXT" ]]; then
                    NUKE_TEXT=""
                    _DIALOG_DIRTY=1
                fi
                ;;
            $'\x7f'|$'\b')  # Backspace (DEL or BS)
                if [[ $NUKE_FOCUS -eq 0 && -n "$NUKE_TEXT" ]]; then
                    if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                        # Option+Delete - delete word (clears all for this small input)
                        NUKE_TEXT=""
                        _DIALOG_ESC_PENDING=0
                    else
                        # Regular backspace - delete one char
                        NUKE_TEXT="${NUKE_TEXT%?}"
                    fi
                    _DIALOG_DIRTY=1
                fi
                ;;
            *)  # Any other key
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                    DIALOG_MODE=0
                    _DIALOG_ESC_PENDING=0
                elif [[ $NUKE_FOCUS -eq 0 ]]; then
                    # Typing in text field (limit to 4 chars)
                    if [[ ${#NUKE_TEXT} -lt 4 ]]; then
                        NUKE_TEXT="${NUKE_TEXT}${key}"
                        _DIALOG_DIRTY=1
                    fi
                fi
                _DIALOG_ESC_PENDING=0
                ;;
        esac
    }

    # ==========================================================================
    # End Nuke Dialog
    # ==========================================================================

    # ==========================================================================
    # New Agent Dialog (DIALOG_MODE=4)
    # ==========================================================================

    watch_dialog_init_new_agent() {
        NEW_AGENT_NAME=""
        NEW_AGENT_DEFAULT_NAME="agent-$(openssl rand -hex 4)"  # Pre-generate default name
        NEW_AGENT_PROMPT=""
        NEW_AGENT_WORKER=0  # 0=unchecked, 1=checked
        NEW_AGENT_FOCUS=0  # 0=name, 1=model, 2=worker, 3=prompt, 4=Cancel, 5=Create
        _DIALOG_ESC_PENDING=0
        _DIALOG_DIRTY=1

        # Get default model from .ittybitty.json
        local config_model=""
        if [[ -f ".ittybitty.json" ]]; then
            config_model=$(jq -r '.model // ""' ".ittybitty.json" 2>/dev/null)
        fi

        # Find index for the configured model (default to 0 if not found)
        NEW_AGENT_MODEL_INDEX=0
        local i
        for i in "${!NEW_AGENT_MODELS[@]}"; do
            if [[ "${NEW_AGENT_MODELS[$i]}" == "$config_model" ]]; then
                NEW_AGENT_MODEL_INDEX=$i
                break
            fi
        done
    }

    watch_dialog_render_new_agent() {
        # Check if a pending escape should close the dialog
        if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
            DIALOG_MODE=0
            _DIALOG_ESC_PENDING=0
            return
        fi

        # Only redraw when dirty
        [[ "${_DIALOG_DIRTY:-0}" != "1" ]] && return
        _DIALOG_DIRTY=0

        # Get terminal size
        TERM_LINES=$(tput lines)
        TERM_COLS=$(tput cols)

        # Calculate dialog position (centered)
        dialog_calc_position
        local dialog_height=16  # Total dialog height
        local prompt_area_height=3  # Lines in the prompt area
        local start_row=$(( (TERM_LINES - dialog_height) / 2 ))
        [[ $start_row -lt 1 ]] && start_row=1

        # Clear dialog area
        dialog_clear "$start_row" "$((dialog_height + 1))"

        # Draw dialog box
        local row=$start_row
        dialog_draw_hline "$row" "┌" "─" "┐"
        ((row++))

        # Title
        dialog_draw_line "$row" "Create New Agent"
        ((row++))

        # Blank line
        dialog_draw_line "$row" ""
        ((row++))

        # Name field - show dim placeholder when empty
        local name_focused=$([[ $NEW_AGENT_FOCUS -eq 0 ]] && echo 1 || echo 0)
        local name_display="$NEW_AGENT_NAME"
        local show_placeholder=$([[ -z "$NEW_AGENT_NAME" ]] && echo 1 || echo 0)
        [[ $name_focused == "1" && -n "$NEW_AGENT_NAME" ]] && name_display="${name_display}_"
        [[ $name_focused == "1" && -z "$NEW_AGENT_NAME" ]] && name_display="_"
        printf '\e[%d;%dH│ Name:  ' "$row" "$_DIALOG_START_COL"
        if [[ $name_focused == "1" ]]; then
            if [[ $show_placeholder == "1" ]]; then
                # Show cursor followed by dim placeholder
                printf '\e[7m_\e[0m\e[2m%-19s\e[0m' "${NEW_AGENT_DEFAULT_NAME:0:19}"
            else
                printf '\e[7m%-20s\e[0m' "$name_display"
            fi
        else
            if [[ $show_placeholder == "1" ]]; then
                # Show dim placeholder when not focused and empty
                printf '\e[2m%-20s\e[0m' "$NEW_AGENT_DEFAULT_NAME"
            else
                printf '%-20s' "$name_display"
            fi
        fi
        local remaining=$((DIALOG_WIDTH - 30))
        printf '%*s│' "$remaining" ""
        ((row++))

        # Model field
        local model_focused=$([[ $NEW_AGENT_FOCUS -eq 1 ]] && echo 1 || echo 0)
        local model_name="${NEW_AGENT_MODELS[$NEW_AGENT_MODEL_INDEX]}"
        printf '\e[%d;%dH│ Model: ' "$row" "$_DIALOG_START_COL"
        if [[ $model_focused == "1" ]]; then
            printf '\e[7m%-17s ▼\e[0m' "$model_name"
        else
            printf '%-17s ▼' "$model_name"
        fi
        remaining=$((DIALOG_WIDTH - 29))
        printf '%*s│' "$remaining" ""
        ((row++))

        # Worker checkbox
        local worker_focused=$([[ $NEW_AGENT_FOCUS -eq 2 ]] && echo 1 || echo 0)
        local checkbox_mark=$([[ $NEW_AGENT_WORKER -eq 1 ]] && echo "X" || echo " ")
        printf '\e[%d;%dH│ ' "$row" "$_DIALOG_START_COL"
        if [[ $worker_focused == "1" ]]; then
            printf '\e[7m[%s] Worker\e[0m' "$checkbox_mark"
        else
            printf '[%s] Worker' "$checkbox_mark"
        fi
        remaining=$((DIALOG_WIDTH - 13))
        printf '%*s│' "$remaining" ""
        ((row++))

        # Blank line
        dialog_draw_line "$row" ""
        ((row++))

        # Prompt label
        dialog_draw_line "$row" "Prompt:"
        ((row++))

        # Prompt text area box - top border
        local inner_width=$((DIALOG_WIDTH - 4))
        local text_width=$((inner_width - 2))  # 44 chars for content
        printf '\e[%d;%dH│ ┌' "$row" "$_DIALOG_START_COL"
        local i
        for ((i=0; i<text_width; i++)); do printf '─'; done
        printf '┐ │'
        ((row++))

        # Parse prompt text into lines and display
        local prompt_focused=$([[ $NEW_AGENT_FOCUS -eq 3 ]] && echo 1 || echo 0)
        local display_text="$NEW_AGENT_PROMPT"
        [[ $prompt_focused == "1" ]] && display_text="${display_text}_"

        # Split text by newlines and wrap long lines
        local -a display_lines=()
        local line=""
        local char
        local len=${#display_text}
        for ((i=0; i<len; i++)); do
            char="${display_text:$i:1}"
            if [[ "$char" == $'\n' ]]; then
                display_lines+=("$line")
                line=""
            else
                line="${line}${char}"
                if [[ ${#line} -ge $text_width ]]; then
                    display_lines+=("$line")
                    line=""
                fi
            fi
        done
        [[ -n "$line" ]] && display_lines+=("$line")

        # Show last N lines (scroll to bottom)
        local total_lines=${#display_lines[@]}
        local start_line=0
        if [[ $total_lines -gt $prompt_area_height ]]; then
            start_line=$((total_lines - prompt_area_height))
        fi

        # Draw prompt area lines
        local line_idx
        for ((line_idx=0; line_idx<prompt_area_height; line_idx++)); do
            local content_idx=$((start_line + line_idx))
            local content=""
            if [[ $content_idx -lt $total_lines ]]; then
                content="${display_lines[$content_idx]}"
            fi
            printf '\e[%d;%dH│ │' "$row" "$_DIALOG_START_COL"
            if [[ $prompt_focused == "1" ]]; then
                printf '\e[7m%-*s\e[0m' "$text_width" "$content"
            else
                printf '%-*s' "$text_width" "$content"
            fi
            printf '│ │'
            ((row++))
        done

        # Prompt text area box - bottom border
        printf '\e[%d;%dH│ └' "$row" "$_DIALOG_START_COL"
        for ((i=0; i<text_width; i++)); do printf '─'; done
        printf '┘ │'
        ((row++))

        # Blank line
        dialog_draw_line "$row" ""
        ((row++))

        # Buttons - Create disabled if prompt empty (name uses default if not provided)
        local create_disabled=$([[ -z "$NEW_AGENT_PROMPT" ]] && echo 1 || echo 0)
        local cancel_btn=$(dialog_format_button "Cancel" "$([[ $NEW_AGENT_FOCUS -eq 4 ]] && echo 1 || echo 0)")
        local create_btn=$(dialog_format_button "Create" "$([[ $NEW_AGENT_FOCUS -eq 5 ]] && echo 1 || echo 0)" "$create_disabled")
        local btn_visual_width=20  # [Cancel] = 8, [Create] = 8, gap = 4
        local left_pad=$(( (inner_width - btn_visual_width) / 2 ))
        local right_pad=$((inner_width - btn_visual_width - left_pad))
        printf '\e[%d;%dH│ %*s%s    %s%*s │' "$row" "$_DIALOG_START_COL" "$left_pad" "" "$cancel_btn" "$create_btn" "$right_pad" ""
        ((row++))

        # Bottom border
        dialog_draw_hline "$row" "└" "─" "┘"

        # Footer hint
        ((row++))
        printf '\e[%d;%dH' "$row" "$_DIALOG_START_COL"
        printf '%*s' "$DIALOG_WIDTH" ''
        local hint="Tab: next   j/k: model   Space/Enter: select"
        printf '\e[%d;%dH%s' "$row" "$(( _DIALOG_START_COL + (DIALOG_WIDTH - ${#hint}) / 2 ))" "$hint"
    }

    watch_dialog_key_new_agent() {
        local key="$1"
        local can_create=$([[ -n "$NEW_AGENT_PROMPT" ]] && echo 1 || echo 0)  # Name uses default if empty

        case "$key" in
            $'\t')  # Tab - forward
                if [[ $can_create == "1" ]]; then
                    NEW_AGENT_FOCUS=$(( (NEW_AGENT_FOCUS + 1) % 6 ))
                else
                    # Skip Create button (focus 5) when disabled
                    NEW_AGENT_FOCUS=$(( (NEW_AGENT_FOCUS + 1) % 6 ))
                    [[ $NEW_AGENT_FOCUS -eq 5 ]] && NEW_AGENT_FOCUS=0
                fi
                _DIALOG_DIRTY=1
                ;;
            ' ')  # Spacebar - toggle checkbox when on worker checkbox, convert to dash for name, or add to prompt
                if [[ $NEW_AGENT_FOCUS -eq 0 ]]; then
                    # Typing in name field - convert space to dash
                    if [[ ${#NEW_AGENT_NAME} -lt 20 ]]; then
                        NEW_AGENT_NAME="${NEW_AGENT_NAME}-"
                        _DIALOG_DIRTY=1
                    fi
                elif [[ $NEW_AGENT_FOCUS -eq 2 ]]; then
                    # Worker checkbox - toggle
                    NEW_AGENT_WORKER=$(( 1 - NEW_AGENT_WORKER ))
                    _DIALOG_DIRTY=1
                elif [[ $NEW_AGENT_FOCUS -eq 3 ]]; then
                    # Typing in prompt field - add space
                    NEW_AGENT_PROMPT="${NEW_AGENT_PROMPT} "
                    _DIALOG_DIRTY=1
                fi
                ;;
            $'\x1e')  # Enter
                if [[ $NEW_AGENT_FOCUS -eq 2 ]]; then
                    # Worker checkbox - toggle
                    NEW_AGENT_WORKER=$(( 1 - NEW_AGENT_WORKER ))
                    _DIALOG_DIRTY=1
                elif [[ $NEW_AGENT_FOCUS -eq 3 ]]; then
                    # In prompt area, add newline
                    NEW_AGENT_PROMPT="${NEW_AGENT_PROMPT}"$'\n'
                    _DIALOG_DIRTY=1
                elif [[ $NEW_AGENT_FOCUS -eq 4 ]]; then
                    # Cancel button
                    DIALOG_MODE=0
                elif [[ $NEW_AGENT_FOCUS -eq 5 && $can_create == "1" ]]; then
                    # Create button - run in background for fast UI response
                    local model_arg=""
                    if [[ "${NEW_AGENT_MODELS[$NEW_AGENT_MODEL_INDEX]}" != "default" ]]; then
                        model_arg="--model ${NEW_AGENT_MODELS[$NEW_AGENT_MODEL_INDEX]}"
                    fi
                    local worker_arg=""
                    if [[ $NEW_AGENT_WORKER -eq 1 ]]; then
                        worker_arg="--worker"
                    fi
                    # Use user-provided name, or the pre-generated default
                    local final_name="${NEW_AGENT_NAME:-$NEW_AGENT_DEFAULT_NAME}"

                    # Run in background - errors reported via ERRORS_FILE
                    (
                        local error_output
                        if ! error_output=$(cmd_new_agent --name "$final_name" $model_arg $worker_arg "$NEW_AGENT_PROMPT" 2>&1 >/dev/null); then
                            # Failed - report error to errors file
                            local error_line
                            error_line=$(echo "$error_output" | grep -m1 "^Error:" || echo "$error_output" | head -1)
                            local user_msg="$error_line"
                            if [[ "$error_line" == *"session"* ]] || [[ "$error_line" == *"branch"* ]]; then
                                user_msg="$user_msg Agent names can only contain letters, numbers, and hyphens."
                            fi
                            watch_add_error_to_file "$ERRORS_FILE" "Failed to Create Agent '$final_name'" "$user_msg"
                        fi
                    ) &
                    # Close dialog immediately - don't wait for completion
                    DIALOG_MODE=0
                fi
                ;;
            'j'|'J')  # j - next model (when on model field)
                if [[ $NEW_AGENT_FOCUS -eq 1 ]]; then
                    NEW_AGENT_MODEL_INDEX=$(( (NEW_AGENT_MODEL_INDEX + 1) % ${#NEW_AGENT_MODELS[@]} ))
                    _DIALOG_DIRTY=1
                elif [[ $NEW_AGENT_FOCUS -eq 0 ]]; then
                    # Typing in name field - only alphanumeric and hyphen allowed
                    if [[ ${#NEW_AGENT_NAME} -lt 20 && "$key" =~ ^[a-zA-Z0-9-]$ ]]; then
                        NEW_AGENT_NAME="${NEW_AGENT_NAME}${key}"
                        _DIALOG_DIRTY=1
                    fi
                elif [[ $NEW_AGENT_FOCUS -eq 3 ]]; then
                    # Typing in prompt field
                    NEW_AGENT_PROMPT="${NEW_AGENT_PROMPT}${key}"
                    _DIALOG_DIRTY=1
                fi
                ;;
            'k'|'K')  # k - previous model (when on model field)
                if [[ $NEW_AGENT_FOCUS -eq 1 ]]; then
                    NEW_AGENT_MODEL_INDEX=$(( (NEW_AGENT_MODEL_INDEX - 1 + ${#NEW_AGENT_MODELS[@]}) % ${#NEW_AGENT_MODELS[@]} ))
                    _DIALOG_DIRTY=1
                elif [[ $NEW_AGENT_FOCUS -eq 0 ]]; then
                    # Typing in name field - only alphanumeric and hyphen allowed
                    if [[ ${#NEW_AGENT_NAME} -lt 20 && "$key" =~ ^[a-zA-Z0-9-]$ ]]; then
                        NEW_AGENT_NAME="${NEW_AGENT_NAME}${key}"
                        _DIALOG_DIRTY=1
                    fi
                elif [[ $NEW_AGENT_FOCUS -eq 3 ]]; then
                    # Typing in prompt field
                    NEW_AGENT_PROMPT="${NEW_AGENT_PROMPT}${key}"
                    _DIALOG_DIRTY=1
                fi
                ;;
            $'\e')  # Escape - check for sequence
                _DIALOG_ESC_PENDING=1
                ;;
            '[')  # Part of escape sequence
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                    _DIALOG_ESC_PENDING=2
                elif [[ $NEW_AGENT_FOCUS -eq 0 ]]; then
                    # '[' not allowed in name field - ignore
                    :
                elif [[ $NEW_AGENT_FOCUS -eq 3 ]]; then
                    NEW_AGENT_PROMPT="${NEW_AGENT_PROMPT}["
                    _DIALOG_DIRTY=1
                fi
                ;;
            'Z')  # Shift+Tab (part of \e[Z sequence)
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    # Shift+Tab - backward
                    if [[ $can_create == "1" ]]; then
                        NEW_AGENT_FOCUS=$(( (NEW_AGENT_FOCUS - 1 + 6) % 6 ))
                    else
                        # Skip Create button (focus 5) when disabled
                        NEW_AGENT_FOCUS=$(( (NEW_AGENT_FOCUS - 1 + 6) % 6 ))
                        [[ $NEW_AGENT_FOCUS -eq 5 ]] && NEW_AGENT_FOCUS=4
                    fi
                    _DIALOG_ESC_PENDING=0
                    _DIALOG_DIRTY=1
                elif [[ $NEW_AGENT_FOCUS -eq 0 ]]; then
                    # Typing in name field - only alphanumeric and hyphen allowed
                    if [[ ${#NEW_AGENT_NAME} -lt 20 && "$key" =~ ^[a-zA-Z0-9-]$ ]]; then
                        NEW_AGENT_NAME="${NEW_AGENT_NAME}Z"
                        _DIALOG_DIRTY=1
                    fi
                elif [[ $NEW_AGENT_FOCUS -eq 3 ]]; then
                    NEW_AGENT_PROMPT="${NEW_AGENT_PROMPT}Z"
                    _DIALOG_DIRTY=1
                fi
                ;;
            'A')  # Up arrow - previous model (when on model field), or backward navigation
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    if [[ $NEW_AGENT_FOCUS -eq 1 ]]; then
                        # On model field: cycle model
                        NEW_AGENT_MODEL_INDEX=$(( (NEW_AGENT_MODEL_INDEX - 1 + ${#NEW_AGENT_MODELS[@]}) % ${#NEW_AGENT_MODELS[@]} ))
                        _DIALOG_DIRTY=1
                    elif [[ $NEW_AGENT_FOCUS -eq 2 || $NEW_AGENT_FOCUS -eq 4 || $NEW_AGENT_FOCUS -eq 5 ]]; then
                        # On checkbox or buttons: navigate backward like Shift+Tab
                        if [[ $can_create == "1" ]]; then
                            NEW_AGENT_FOCUS=$(( (NEW_AGENT_FOCUS - 1 + 6) % 6 ))
                        else
                            NEW_AGENT_FOCUS=$(( (NEW_AGENT_FOCUS - 1 + 6) % 6 ))
                            [[ $NEW_AGENT_FOCUS -eq 5 ]] && NEW_AGENT_FOCUS=4
                        fi
                        _DIALOG_DIRTY=1
                    fi
                    _DIALOG_ESC_PENDING=0
                elif [[ $NEW_AGENT_FOCUS -eq 0 ]]; then
                    # Typing in name field - only alphanumeric and hyphen allowed
                    if [[ ${#NEW_AGENT_NAME} -lt 20 && "$key" =~ ^[a-zA-Z0-9-]$ ]]; then
                        NEW_AGENT_NAME="${NEW_AGENT_NAME}A"
                        _DIALOG_DIRTY=1
                    fi
                elif [[ $NEW_AGENT_FOCUS -eq 3 ]]; then
                    NEW_AGENT_PROMPT="${NEW_AGENT_PROMPT}A"
                    _DIALOG_DIRTY=1
                fi
                ;;
            'B')  # Down arrow - next model (when on model field), or forward navigation
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    if [[ $NEW_AGENT_FOCUS -eq 1 ]]; then
                        # On model field: cycle model
                        NEW_AGENT_MODEL_INDEX=$(( (NEW_AGENT_MODEL_INDEX + 1) % ${#NEW_AGENT_MODELS[@]} ))
                        _DIALOG_DIRTY=1
                    elif [[ $NEW_AGENT_FOCUS -eq 2 || $NEW_AGENT_FOCUS -eq 4 || $NEW_AGENT_FOCUS -eq 5 ]]; then
                        # On checkbox or buttons: navigate forward like Tab
                        if [[ $can_create == "1" ]]; then
                            NEW_AGENT_FOCUS=$(( (NEW_AGENT_FOCUS + 1) % 6 ))
                        else
                            NEW_AGENT_FOCUS=$(( (NEW_AGENT_FOCUS + 1) % 6 ))
                            [[ $NEW_AGENT_FOCUS -eq 5 ]] && NEW_AGENT_FOCUS=0
                        fi
                        _DIALOG_DIRTY=1
                    fi
                    _DIALOG_ESC_PENDING=0
                elif [[ $NEW_AGENT_FOCUS -eq 0 ]]; then
                    # Typing in name field - only alphanumeric and hyphen allowed
                    if [[ ${#NEW_AGENT_NAME} -lt 20 && "$key" =~ ^[a-zA-Z0-9-]$ ]]; then
                        NEW_AGENT_NAME="${NEW_AGENT_NAME}B"
                        _DIALOG_DIRTY=1
                    fi
                elif [[ $NEW_AGENT_FOCUS -eq 3 ]]; then
                    NEW_AGENT_PROMPT="${NEW_AGENT_PROMPT}B"
                    _DIALOG_DIRTY=1
                fi
                ;;
            'D')  # Left arrow - backward navigation (like Shift+Tab)
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    if [[ $NEW_AGENT_FOCUS -ne 0 && $NEW_AGENT_FOCUS -ne 3 ]]; then
                        # Not in text fields: navigate backward
                        if [[ $can_create == "1" ]]; then
                            NEW_AGENT_FOCUS=$(( (NEW_AGENT_FOCUS - 1 + 6) % 6 ))
                        else
                            NEW_AGENT_FOCUS=$(( (NEW_AGENT_FOCUS - 1 + 6) % 6 ))
                            [[ $NEW_AGENT_FOCUS -eq 5 ]] && NEW_AGENT_FOCUS=4
                        fi
                        _DIALOG_DIRTY=1
                    fi
                    _DIALOG_ESC_PENDING=0
                elif [[ $NEW_AGENT_FOCUS -eq 0 ]]; then
                    # Typing in name field - only alphanumeric and hyphen allowed
                    if [[ ${#NEW_AGENT_NAME} -lt 20 && "$key" =~ ^[a-zA-Z0-9-]$ ]]; then
                        NEW_AGENT_NAME="${NEW_AGENT_NAME}D"
                        _DIALOG_DIRTY=1
                    fi
                elif [[ $NEW_AGENT_FOCUS -eq 3 ]]; then
                    NEW_AGENT_PROMPT="${NEW_AGENT_PROMPT}D"
                    _DIALOG_DIRTY=1
                fi
                ;;
            'C')  # Right arrow - forward navigation (like Tab)
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    if [[ $NEW_AGENT_FOCUS -ne 0 && $NEW_AGENT_FOCUS -ne 3 ]]; then
                        # Not in text fields: navigate forward
                        if [[ $can_create == "1" ]]; then
                            NEW_AGENT_FOCUS=$(( (NEW_AGENT_FOCUS + 1) % 6 ))
                        else
                            NEW_AGENT_FOCUS=$(( (NEW_AGENT_FOCUS + 1) % 6 ))
                            [[ $NEW_AGENT_FOCUS -eq 5 ]] && NEW_AGENT_FOCUS=0
                        fi
                        _DIALOG_DIRTY=1
                    fi
                    _DIALOG_ESC_PENDING=0
                elif [[ $NEW_AGENT_FOCUS -eq 0 ]]; then
                    # Typing in name field - only alphanumeric and hyphen allowed
                    if [[ ${#NEW_AGENT_NAME} -lt 20 && "$key" =~ ^[a-zA-Z0-9-]$ ]]; then
                        NEW_AGENT_NAME="${NEW_AGENT_NAME}C"
                        _DIALOG_DIRTY=1
                    fi
                elif [[ $NEW_AGENT_FOCUS -eq 3 ]]; then
                    NEW_AGENT_PROMPT="${NEW_AGENT_PROMPT}C"
                    _DIALOG_DIRTY=1
                fi
                ;;
            $'\x15')  # Ctrl+U - delete to start of line
                if [[ $NEW_AGENT_FOCUS -eq 0 && -n "$NEW_AGENT_NAME" ]]; then
                    # Single line - clear all
                    NEW_AGENT_NAME=""
                    _DIALOG_DIRTY=1
                elif [[ $NEW_AGENT_FOCUS -eq 3 && -n "$NEW_AGENT_PROMPT" ]]; then
                    dialog_delete_line "$NEW_AGENT_PROMPT"
                    NEW_AGENT_PROMPT="$_DIALOG_TEXT_RESULT"
                    _DIALOG_DIRTY=1
                fi
                ;;
            $'\x7f'|$'\b')  # Backspace (DEL or BS)
                if [[ $NEW_AGENT_FOCUS -eq 0 && -n "$NEW_AGENT_NAME" ]]; then
                    if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                        # Option+Delete - delete word
                        dialog_delete_word "$NEW_AGENT_NAME"
                        NEW_AGENT_NAME="$_DIALOG_TEXT_RESULT"
                        _DIALOG_ESC_PENDING=0
                    else
                        NEW_AGENT_NAME="${NEW_AGENT_NAME%?}"
                    fi
                    _DIALOG_DIRTY=1
                elif [[ $NEW_AGENT_FOCUS -eq 3 && -n "$NEW_AGENT_PROMPT" ]]; then
                    if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                        # Option+Delete - delete word
                        dialog_delete_word "$NEW_AGENT_PROMPT"
                        NEW_AGENT_PROMPT="$_DIALOG_TEXT_RESULT"
                        _DIALOG_ESC_PENDING=0
                    else
                        NEW_AGENT_PROMPT="${NEW_AGENT_PROMPT%?}"
                    fi
                    _DIALOG_DIRTY=1
                fi
                ;;
            *)  # Any other key
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                    DIALOG_MODE=0
                    _DIALOG_ESC_PENDING=0
                elif [[ $NEW_AGENT_FOCUS -eq 0 ]]; then
                    # Typing in name field - only alphanumeric and hyphen allowed (spaces converted above)
                    if [[ ${#NEW_AGENT_NAME} -lt 20 && "$key" =~ ^[a-zA-Z0-9-]$ ]]; then
                        NEW_AGENT_NAME="${NEW_AGENT_NAME}${key}"
                        _DIALOG_DIRTY=1
                    fi
                elif [[ $NEW_AGENT_FOCUS -eq 3 ]]; then
                    # Typing in prompt field
                    NEW_AGENT_PROMPT="${NEW_AGENT_PROMPT}${key}"
                    _DIALOG_DIRTY=1
                fi
                _DIALOG_ESC_PENDING=0
                ;;
        esac
    }

    # ==========================================================================
    # End New Agent Dialog
    # ==========================================================================

    # ==========================================================================
    # Setup Dialog (DIALOG_MODE=6)
    # ==========================================================================

    watch_dialog_init_setup() {
        SETUP_FOCUS=0
        _DIALOG_ESC_PENDING=0
        _DIALOG_DIRTY=1
        # Refresh all setup status
        watch_check_all_setup
    }

    watch_dialog_render_setup() {
        # Check if a pending escape should close the dialog
        if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
            DIALOG_MODE=0
            _DIALOG_ESC_PENDING=0
            return
        fi

        # Only redraw when dirty
        [[ "${_DIALOG_DIRTY:-0}" != "1" ]] && return
        _DIALOG_DIRTY=0

        # Get terminal size
        TERM_LINES=$(tput lines)
        TERM_COLS=$(tput cols)

        # Calculate dialog position (centered)
        dialog_calc_position
        local start_row=$(( (TERM_LINES - 17) / 2 ))  # 17 lines tall
        [[ $start_row -lt 1 ]] && start_row=1

        # Clear dialog area
        dialog_clear "$start_row" 18

        # Draw dialog box
        local row=$start_row
        dialog_draw_hline "$row" "┌" "─" "┐"
        ((row++))

        # Title
        dialog_draw_line "$row" "SETUP"
        ((row++))

        # Blank line
        dialog_draw_line "$row" ""
        ((row++))

        # Draw a checkbox line with proper escape sequence handling
        # Unlike dialog_draw_line, this handles escape sequences correctly by
        # calculating visual width separately from the escape codes
        # Args: $1=row, $2=installed (1=yes, 0=no), $3=label, $4=focused (0/1), $5=disabled (0/1)
        dialog_draw_checkbox() {
            local row=$1
            local installed=$2
            local label=$3
            local focused=$4
            local disabled=${5:-0}

            local checkbox
            if [[ $installed -eq 1 ]]; then
                checkbox="[x]"
            else
                checkbox="[ ]"
            fi

            local text="$checkbox $label"
            local visual_len=${#text}
            local inner_width=$((DIALOG_WIDTH - 4))  # 2 for borders, 2 for padding
            local padding=$((inner_width - visual_len))
            [[ $padding -lt 0 ]] && padding=0

            # Build the line with proper escape sequences
            printf '\e[%d;%dH│ ' "$row" "$_DIALOG_START_COL"

            if [[ $disabled -eq 1 ]]; then
                printf '\e[2m%s\e[0m' "$text"
            elif [[ $focused -eq 1 ]]; then
                printf '\e[7m%s\e[0m' "$text"
            else
                printf '%s' "$text"
            fi

            printf '%*s │' "$padding" ""
        }

        # Option 1: Safety hooks
        dialog_draw_checkbox "$row" "$SETUP_HOOKS_INSTALLED" "Safety hooks" "$([[ $SETUP_FOCUS -eq 0 ]] && echo 1 || echo 0)"
        ((row++))

        # Description for safety hooks
        dialog_draw_line "$row" "  Prevent cd into agent worktrees"
        ((row++))

        # Blank line
        dialog_draw_line "$row" ""
        ((row++))

        # Option 2: ib instructions
        dialog_draw_checkbox "$row" "$SETUP_IB_INSTRUCTIONS" "ib instructions" "$([[ $SETUP_FOCUS -eq 1 ]] && echo 1 || echo 0)"
        ((row++))

        # Description for ib instructions
        dialog_draw_line "$row" "  Add <ittybitty> block to CLAUDE.md"
        ((row++))

        # Blank line
        dialog_draw_line "$row" ""
        ((row++))

        # Option 3: Agent status (disabled if ib instructions not installed)
        local item3_disabled=0
        local item3_note=""
        if [[ $SETUP_IB_INSTRUCTIONS -ne 1 ]]; then
            item3_disabled=1
            item3_note="  (requires ib instructions)"
        fi
        dialog_draw_checkbox "$row" "$SETUP_STATUS_IMPORT" "Agent status" "$([[ $SETUP_FOCUS -eq 2 ]] && echo 1 || echo 0)" "$item3_disabled"
        ((row++))

        # Description/note for agent status
        if [[ -n "$item3_note" ]]; then
            dialog_draw_line "$row" "$item3_note"
        else
            dialog_draw_line "$row" "  Add @.ittybitty/STATUS.md import"
        fi
        ((row++))

        # Blank line
        dialog_draw_line "$row" ""
        ((row++))

        # Option 4: Gitignore
        dialog_draw_checkbox "$row" "$SETUP_GITIGNORE" "Gitignore" "$([[ $SETUP_FOCUS -eq 3 ]] && echo 1 || echo 0)"
        ((row++))

        # Description for gitignore
        dialog_draw_line "$row" "  Add .ittybitty/ to .gitignore"
        ((row++))

        # Blank line
        dialog_draw_line "$row" ""
        ((row++))

        # Close button - render manually to handle escape sequences correctly
        local close_focused=$([[ $SETUP_FOCUS -eq 4 ]] && echo 1 || echo 0)
        local btn_visual_width=7  # [Close] = 7 chars
        local inner_width=$((DIALOG_WIDTH - 4))
        local left_pad=$(( (inner_width - btn_visual_width) / 2 ))
        local right_pad=$((inner_width - btn_visual_width - left_pad))
        printf '\e[%d;%dH│ %*s' "$row" "$_DIALOG_START_COL" "$left_pad" ""
        if [[ $close_focused == "1" ]]; then
            printf '\e[7m[Close]\e[0m'
        else
            printf '[Close]'
        fi
        printf '%*s │' "$right_pad" ""
        ((row++))

        # Bottom border
        dialog_draw_hline "$row" "└" "─" "┘"
    }

    watch_dialog_key_setup() {
        local key="$1"
        case "$key" in
            $'\x1e'|' ')  # Enter or Space - toggle current option
                case $SETUP_FOCUS in
                    0)  # Safety hooks
                        if [[ $SETUP_HOOKS_INSTALLED -eq 1 ]]; then
                            cmd_hooks_uninstall >/dev/null 2>&1
                        else
                            cmd_hooks_install >/dev/null 2>&1
                        fi
                        watch_check_hooks_status
                        _DIALOG_DIRTY=1
                        ;;
                    1)  # ib instructions
                        if [[ $SETUP_IB_INSTRUCTIONS -eq 1 ]]; then
                            # Uninstalling ib instructions also removes status import
                            cmd_setup_status_import_uninstall >/dev/null 2>&1
                            cmd_setup_ib_instructions_uninstall >/dev/null 2>&1
                        else
                            cmd_setup_ib_instructions_install >/dev/null 2>&1
                        fi
                        watch_check_ib_instructions
                        watch_check_status_import
                        _DIALOG_DIRTY=1
                        ;;
                    2)  # Agent status (only if ib instructions installed)
                        if [[ $SETUP_IB_INSTRUCTIONS -eq 1 ]]; then
                            if [[ $SETUP_STATUS_IMPORT -eq 1 ]]; then
                                cmd_setup_status_import_uninstall >/dev/null 2>&1
                            else
                                cmd_setup_status_import_install >/dev/null 2>&1
                            fi
                            watch_check_status_import
                            _DIALOG_DIRTY=1
                        fi
                        ;;
                    3)  # Gitignore
                        if [[ $SETUP_GITIGNORE -eq 1 ]]; then
                            cmd_setup_gitignore_uninstall >/dev/null 2>&1
                        else
                            cmd_setup_gitignore_install >/dev/null 2>&1
                        fi
                        watch_check_gitignore
                        _DIALOG_DIRTY=1
                        ;;
                    4)  # Close button
                        DIALOG_MODE=0
                        ;;
                esac
                ;;
            $'\e')  # Escape - check for sequence
                _DIALOG_ESC_PENDING=1
                ;;
            '[')  # Part of escape sequence
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                    _DIALOG_ESC_PENDING=2
                fi
                ;;
            $'\t'|'j')  # Tab or j - move down
                SETUP_FOCUS=$(( (SETUP_FOCUS + 1) % 5 ))
                _DIALOG_DIRTY=1
                ;;
            'B')  # Down arrow
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    SETUP_FOCUS=$(( (SETUP_FOCUS + 1) % 5 ))
                    _DIALOG_ESC_PENDING=0
                    _DIALOG_DIRTY=1
                fi
                ;;
            'k')  # k - move up
                SETUP_FOCUS=$(( (SETUP_FOCUS - 1 + 5) % 5 ))
                _DIALOG_DIRTY=1
                ;;
            'A'|'Z')  # Up arrow or Shift+Tab - move up
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    SETUP_FOCUS=$(( (SETUP_FOCUS - 1 + 5) % 5 ))
                    _DIALOG_ESC_PENDING=0
                    _DIALOG_DIRTY=1
                fi
                ;;
            *)  # Any other key
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                    # Real escape - close dialog
                    DIALOG_MODE=0
                fi
                _DIALOG_ESC_PENDING=0
                ;;
        esac
    }

    # Legacy aliases for compatibility
    watch_dialog_init_hooks() { watch_dialog_init_setup; }
    watch_dialog_render_hooks() { watch_dialog_render_setup; }
    watch_dialog_key_hooks() { watch_dialog_key_setup "$@"; }

    # ==========================================================================
    # End Setup Dialog
    # ==========================================================================

    # ==========================================================================
    # Jump Dialog (DIALOG_MODE=5)
    # ==========================================================================

    watch_dialog_init_jump() {
        JUMP_PATTERN=""
        _DIALOG_ESC_PENDING=0
        _DIALOG_DIRTY=1
    }

    watch_dialog_render_jump() {
        # Check if a pending escape should close the dialog
        if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
            DIALOG_MODE=0
            _DIALOG_ESC_PENDING=0
            return 0
        fi

        # Only redraw when dirty
        [[ "${_DIALOG_DIRTY:-0}" == "1" ]] || return 0
        _DIALOG_DIRTY=0

        # Get terminal size
        TERM_LINES=$(tput lines)
        TERM_COLS=$(tput cols)

        # Calculate dialog position (centered)
        dialog_calc_position
        local start_row=$(( (TERM_LINES - 9) / 2 ))  # 9 lines tall
        [[ $start_row -lt 1 ]] && start_row=1

        # Find matching agents
        local -a matching_ids=()
        local agent_dir id
        shopt -s nocasematch
        for agent_dir in "$AGENTS_DIR"/*/; do
            [[ -d "$agent_dir" ]] || continue
            id="${agent_dir%/}"; id="${id##*/}"
            # Case-insensitive substring match
            if [[ -z "$JUMP_PATTERN" ]] || [[ "$id" == *"$JUMP_PATTERN"* ]]; then
                matching_ids+=("$id")
            fi
        done
        shopt -u nocasematch

        # Clear dialog area
        dialog_clear "$start_row" 10

        # Draw dialog box
        local row=$start_row
        dialog_draw_hline "$row" "┌" "─" "┐"
        ((row++))

        # Title
        dialog_draw_line "$row" "Jump to Agent"
        ((row++))

        # Blank line
        dialog_draw_line "$row" ""
        ((row++))

        # Search input line
        local input_display="${JUMP_PATTERN}_"
        local inner_width=$((DIALOG_WIDTH - 4))
        local input_width=$((inner_width - 10))  # "Search: " is 8 chars + some padding
        printf '\e[%d;%dH│ Search: \e[7m%-*s\e[0m │' "$row" "$_DIALOG_START_COL" "$input_width" "${input_display:0:$input_width}"
        ((row++))

        # Blank line
        dialog_draw_line "$row" ""
        ((row++))

        # Match count and status
        local match_count=${#matching_ids[@]}
        local match_text
        if [[ $match_count -eq 0 ]]; then
            match_text="No matches"
        elif [[ $match_count -eq 1 ]]; then
            match_text="Match: ${matching_ids[0]}"
        else
            match_text="$match_count matches"
        fi
        dialog_draw_line "$row" "$match_text"
        ((row++))

        # Show first few matches if multiple
        if [[ $match_count -gt 1 && $match_count -le 3 ]]; then
            local m
            for m in "${matching_ids[@]:0:3}"; do
                dialog_draw_line "$row" "  $m"
                ((row++))
            done
        else
            # Blank lines for consistent height
            dialog_draw_line "$row" ""
            ((row++))
            dialog_draw_line "$row" ""
            ((row++))
        fi

        # Bottom border
        dialog_draw_hline "$row" "└" "─" "┘"

        # Footer hint
        ((row++))
        printf '\e[%d;%dH' "$row" "$_DIALOG_START_COL"
        printf '%*s' "$DIALOG_WIDTH" ''
        local hint="Enter: select   Esc: cancel"
        printf '\e[%d;%dH%s' "$row" "$(( _DIALOG_START_COL + (DIALOG_WIDTH - ${#hint}) / 2 ))" "$hint"
    }

    # Helper to check if exactly one agent matches
    # Note: We no longer auto-close the dialog here to prevent key batching issues
    # where subsequent keys in the same frame would go to normal mode handlers.
    # The dialog only closes on Enter (if one match) or Escape.
    watch_jump_check_single_match() {
        # This function is now a no-op placeholder.
        # Match checking happens in render and on Enter key.
        # Keeping the function to avoid removing all call sites.
        :
    }

    watch_dialog_key_jump() {
        local key="$1"
        case "$key" in
            $'\x1e')  # Enter - select if exactly one match, or close dialog
                # Find matching agents
                local -a matching_ids=()
                local agent_dir id
                shopt -s nocasematch
                for agent_dir in "$AGENTS_DIR"/*/; do
                    [[ -d "$agent_dir" ]] || continue
                    id="${agent_dir%/}"; id="${id##*/}"
                    if [[ -z "$JUMP_PATTERN" ]] || [[ "$id" == *"$JUMP_PATTERN"* ]]; then
                        matching_ids+=("$id")
                    fi
                done
                shopt -u nocasematch

                if [[ ${#matching_ids[@]} -eq 1 ]]; then
                    # Exactly one match - select it and close dialog
                    SELECTED_NAME="${matching_ids[0]}"
                    SELECTED_INDEX=-1  # Will be reconciled in render
                    DIALOG_MODE=0
                fi
                # If no match or multiple matches, do nothing on Enter
                ;;
            $'\e')  # Escape - check for sequence
                _DIALOG_ESC_PENDING=1
                ;;
            '[')  # Part of escape sequence
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                    _DIALOG_ESC_PENDING=2
                else
                    # Typing in search field
                    JUMP_PATTERN="${JUMP_PATTERN}["
                    _DIALOG_DIRTY=1
                    watch_jump_check_single_match
                fi
                ;;
            'A'|'B'|'C'|'D'|'Z')  # Arrow keys or shift-tab
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    _DIALOG_ESC_PENDING=0
                else
                    # Regular character in search
                    JUMP_PATTERN="${JUMP_PATTERN}${key}"
                    _DIALOG_DIRTY=1
                    watch_jump_check_single_match
                fi
                ;;
            $'\x15')  # Ctrl+U - clear all
                JUMP_PATTERN=""
                _DIALOG_DIRTY=1
                ;;
            $'\x7f'|$'\b')  # Backspace
                if [[ -n "$JUMP_PATTERN" ]]; then
                    if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                        # Option+Delete - delete word
                        dialog_delete_word "$JUMP_PATTERN"
                        JUMP_PATTERN="$_DIALOG_TEXT_RESULT"
                        _DIALOG_ESC_PENDING=0
                    else
                        # Regular backspace - delete one char
                        JUMP_PATTERN="${JUMP_PATTERN%?}"
                    fi
                    _DIALOG_DIRTY=1
                fi
                ;;
            *)  # Any other key
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                    DIALOG_MODE=0
                    _DIALOG_ESC_PENDING=0
                else
                    # Add character to search pattern
                    JUMP_PATTERN="${JUMP_PATTERN}${key}"
                    _DIALOG_DIRTY=1
                    watch_jump_check_single_match
                fi
                _DIALOG_ESC_PENDING=0
                ;;
        esac
    }

    # ==========================================================================
    # End Jump Dialog
    # ==========================================================================

    # ==========================================================================
    # Merge Dialog (DIALOG_MODE=7)
    # ==========================================================================

    watch_dialog_init_merge() {
        MERGE_FOCUS=0   # 0=Cancel, 1=Feedback, 2=Merge
        MERGE_SCROLL=0
        MERGE_CAN_MERGE=0  # Will be determined
        MERGE_CONFLICT_FILES=""
        MERGE_DIFF=""
        MERGE_ERROR=""
        _DIALOG_ESC_PENDING=0
        _DIALOG_DIRTY=1

        # Get target branch (same logic as cmd_merge)
        local target_branch=""
        if git show-ref --verify --quiet refs/heads/main; then
            target_branch="main"
        elif git show-ref --verify --quiet refs/heads/master; then
            target_branch="master"
        else
            target_branch=$(git branch --show-current 2>/dev/null) || target_branch="HEAD"
        fi

        local branch_name="agent/$_WATCH_SELECTED_ID"

        # Check for uncommitted changes
        local agent_dir="$AGENTS_DIR/$_WATCH_SELECTED_ID"
        local worktree_path="$agent_dir/repo"
        if [[ -n $(git -C "$worktree_path" status --porcelain 2>/dev/null) ]]; then
            MERGE_CAN_MERGE=2
            MERGE_ERROR="Agent has uncommitted changes"
            return
        fi

        # Check if branch exists
        if ! git show-ref --verify --quiet "refs/heads/$branch_name"; then
            MERGE_CAN_MERGE=2
            MERGE_ERROR="Branch $branch_name does not exist"
            return
        fi

        # Check for merge conflicts
        local conflict_files
        if conflict_files=$(check_merge_conflicts "$target_branch" "$branch_name" 2>/dev/null); then
            MERGE_CAN_MERGE=1  # No conflicts
        else
            MERGE_CAN_MERGE=2  # Conflicts detected
            MERGE_CONFLICT_FILES="$conflict_files"
        fi

        # Get the diff (merge-base comparison like cmd_diff)
        local merge_base
        merge_base=$(git merge-base "$target_branch" "$branch_name" 2>/dev/null) || merge_base="$target_branch"
        MERGE_DIFF=$(git diff --stat "$merge_base..$branch_name" 2>/dev/null || echo "Unable to get diff")
    }

    watch_dialog_render_merge() {
        # Check if a pending escape should close the dialog
        if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
            DIALOG_MODE=0
            _DIALOG_ESC_PENDING=0
            return
        fi

        # Only redraw when dirty
        [[ "${_DIALOG_DIRTY:-0}" != "1" ]] && return
        _DIALOG_DIRTY=0

        # Get terminal size
        TERM_LINES=$(tput lines)
        TERM_COLS=$(tput cols)

        # Use wider dialog for merge (show diff content)
        local merge_dialog_width=70
        [[ $merge_dialog_width -gt $((TERM_COLS - 4)) ]] && merge_dialog_width=$((TERM_COLS - 4))
        local start_col=$(( (TERM_COLS - merge_dialog_width) / 2 ))
        [[ $start_col -lt 1 ]] && start_col=1

        # Dialog height: title(1) + separator(1) + status(1) + separator(1) + diff_header(1) + diff_area(10) + separator(1) + buttons(1) + border(2) = ~19
        local diff_area_height=10
        local dialog_height=$((6 + diff_area_height + 2))  # borders + content
        local start_row=$(( (TERM_LINES - dialog_height) / 2 ))
        [[ $start_row -lt 1 ]] && start_row=1

        local inner_width=$((merge_dialog_width - 4))

        # Helper to draw lines at custom width
        local row=$start_row

        # Top border
        printf '\e[%d;%dH┌' "$row" "$start_col"
        local i
        for ((i=0; i<inner_width+2; i++)); do printf '─'; done
        printf '┐'
        ((row++))

        # Title
        local title="Merge agent '$_WATCH_SELECTED_ID'"
        printf '\e[%d;%dH│ %-*s │' "$row" "$start_col" "$inner_width" "$title"
        ((row++))

        # Separator
        printf '\e[%d;%dH├' "$row" "$start_col"
        for ((i=0; i<inner_width+2; i++)); do printf '─'; done
        printf '┤'
        ((row++))

        # Status line with indicator
        local status_text status_indicator
        if [[ $MERGE_CAN_MERGE -eq 1 ]]; then
            status_indicator=$'\e[32m✓\e[0m'  # Green checkmark
            status_text="Ready to merge (no conflicts)"
        elif [[ $MERGE_CAN_MERGE -eq 2 ]]; then
            status_indicator=$'\e[31m✗\e[0m'  # Red X
            if [[ -n "$MERGE_ERROR" ]]; then
                status_text="$MERGE_ERROR"
            elif [[ -n "$MERGE_CONFLICT_FILES" ]]; then
                status_text="Conflicts in: ${MERGE_CONFLICT_FILES%%$'\n'*}"
                # Truncate if too long
                [[ ${#status_text} -gt $((inner_width - 4)) ]] && status_text="${status_text:0:$((inner_width - 7))}..."
            else
                status_text="Merge conflicts detected"
            fi
        else
            status_indicator="?"
            status_text="Checking merge status..."
        fi
        # Status indicator is 1 visible char but may have escape codes
        local status_line="$status_indicator $status_text"
        local status_visible_len=$((2 + ${#status_text}))
        local status_pad=$((inner_width - status_visible_len))
        printf '\e[%d;%dH│ %s%*s │' "$row" "$start_col" "$status_line" "$status_pad" ""
        ((row++))

        # Separator before diff
        printf '\e[%d;%dH├' "$row" "$start_col"
        for ((i=0; i<inner_width+2; i++)); do printf '─'; done
        printf '┤'
        ((row++))

        # Diff header
        printf '\e[%d;%dH│ %-*s │' "$row" "$start_col" "$inner_width" "Changes (;/l to scroll):"
        ((row++))

        # Diff content area (scrollable)
        # Parse diff into lines
        local -a diff_lines=()
        local line=""
        while IFS= read -r line; do
            diff_lines+=("$line")
        done <<< "$MERGE_DIFF"

        local total_diff_lines=${#diff_lines[@]}
        local visible_lines=$diff_area_height

        # Calculate scroll bounds
        local max_scroll=$((total_diff_lines - visible_lines))
        [[ $max_scroll -lt 0 ]] && max_scroll=0
        [[ $MERGE_SCROLL -gt $max_scroll ]] && MERGE_SCROLL=$max_scroll
        [[ $MERGE_SCROLL -lt 0 ]] && MERGE_SCROLL=0

        # Render diff lines
        local line_idx
        for ((line_idx=0; line_idx<visible_lines; line_idx++)); do
            local content_idx=$((MERGE_SCROLL + line_idx))
            local content=""
            if [[ $content_idx -lt $total_diff_lines ]]; then
                content="${diff_lines[$content_idx]}"
                # Truncate if too long
                [[ ${#content} -gt $inner_width ]] && content="${content:0:$((inner_width - 3))}..."
            fi
            printf '\e[%d;%dH│ %-*.*s │' "$row" "$start_col" "$inner_width" "$inner_width" "$content"
            ((row++))
        done

        # Separator before buttons
        printf '\e[%d;%dH├' "$row" "$start_col"
        for ((i=0; i<inner_width+2; i++)); do printf '─'; done
        printf '┤'
        ((row++))

        # Buttons: [Cancel] [Feedback] [Merge]
        local merge_disabled=$([[ $MERGE_CAN_MERGE -ne 1 ]] && echo 1 || echo 0)
        local cancel_btn=$(dialog_format_button "Cancel" "$([[ $MERGE_FOCUS -eq 0 ]] && echo 1 || echo 0)")
        local feedback_btn=$(dialog_format_button "Feedback" "$([[ $MERGE_FOCUS -eq 1 ]] && echo 1 || echo 0)")
        local merge_btn=$(dialog_format_button "Merge" "$([[ $MERGE_FOCUS -eq 2 ]] && echo 1 || echo 0)" "$merge_disabled")

        # Button visual widths: [Cancel]=8, [Feedback]=10, [Merge]=7, gaps=8, total=33
        local btn_visual_width=33
        local left_pad=$(( (inner_width - btn_visual_width) / 2 ))
        local right_pad=$((inner_width - btn_visual_width - left_pad))
        printf '\e[%d;%dH│ %*s%s    %s    %s%*s │' "$row" "$start_col" "$left_pad" "" "$cancel_btn" "$feedback_btn" "$merge_btn" "$right_pad" ""
        ((row++))

        # Bottom border
        printf '\e[%d;%dH└' "$row" "$start_col"
        for ((i=0; i<inner_width+2; i++)); do printf '─'; done
        printf '┘'

        # Footer hint
        ((row++))
        local hint="Tab: switch   ;/l: scroll   Enter: select"
        local hint_start=$(( start_col + (merge_dialog_width - ${#hint}) / 2 ))
        printf '\e[%d;%dH%*s' "$row" "$start_col" "$merge_dialog_width" ""
        printf '\e[%d;%dH%s' "$row" "$hint_start" "$hint"
    }

    watch_dialog_key_merge() {
        local key="$1"
        # Focus: 0=Cancel, 1=Feedback, 2=Merge
        case "$key" in
            $'\t')  # Tab - forward
                if [[ $MERGE_CAN_MERGE -ne 1 ]]; then
                    # Skip Merge button when merge not possible
                    MERGE_FOCUS=$(( (MERGE_FOCUS + 1) % 2 ))
                else
                    MERGE_FOCUS=$(( (MERGE_FOCUS + 1) % 3 ))
                fi
                _DIALOG_DIRTY=1
                ;;
            $'\x1e')  # Enter
                if [[ $MERGE_FOCUS -eq 0 ]]; then
                    # Cancel
                    DIALOG_MODE=0
                elif [[ $MERGE_FOCUS -eq 1 ]]; then
                    # Feedback - close merge dialog and open send dialog
                    DIALOG_MODE=0
                    # Set up send dialog with pre-filled context
                    watch_dialog_init_send
                    DIALOG_MODE=1
                elif [[ $MERGE_FOCUS -eq 2 && $MERGE_CAN_MERGE -eq 1 ]]; then
                    # Merge - execute the merge
                    DIALOG_MODE=0
                    # Run merge in background
                    cmd_merge --force "$_WATCH_SELECTED_ID" >/dev/null 2>&1 &
                fi
                ;;
            ';')  # Scroll down
                MERGE_SCROLL=$((MERGE_SCROLL + 1))
                _DIALOG_DIRTY=1
                ;;
            'l')  # Scroll up
                MERGE_SCROLL=$((MERGE_SCROLL - 1))
                [[ $MERGE_SCROLL -lt 0 ]] && MERGE_SCROLL=0
                _DIALOG_DIRTY=1
                ;;
            $'\e')  # Escape
                _DIALOG_ESC_PENDING=1
                ;;
            '[')  # Part of escape sequence
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                    _DIALOG_ESC_PENDING=2
                fi
                ;;
            'Z')  # Shift+Tab
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    if [[ $MERGE_CAN_MERGE -ne 1 ]]; then
                        MERGE_FOCUS=$(( (MERGE_FOCUS - 1 + 2) % 2 ))
                    else
                        MERGE_FOCUS=$(( (MERGE_FOCUS - 1 + 3) % 3 ))
                    fi
                    _DIALOG_ESC_PENDING=0
                    _DIALOG_DIRTY=1
                fi
                ;;
            'A'|'D')  # Up or Left arrow
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    if [[ $MERGE_CAN_MERGE -ne 1 ]]; then
                        MERGE_FOCUS=$(( (MERGE_FOCUS - 1 + 2) % 2 ))
                    else
                        MERGE_FOCUS=$(( (MERGE_FOCUS - 1 + 3) % 3 ))
                    fi
                    _DIALOG_ESC_PENDING=0
                    _DIALOG_DIRTY=1
                fi
                ;;
            'B'|'C')  # Down or Right arrow
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "2" ]]; then
                    if [[ $MERGE_CAN_MERGE -ne 1 ]]; then
                        MERGE_FOCUS=$(( (MERGE_FOCUS + 1) % 2 ))
                    else
                        MERGE_FOCUS=$(( (MERGE_FOCUS + 1) % 3 ))
                    fi
                    _DIALOG_ESC_PENDING=0
                    _DIALOG_DIRTY=1
                fi
                ;;
            *)
                if [[ "${_DIALOG_ESC_PENDING:-0}" == "1" ]]; then
                    DIALOG_MODE=0
                fi
                _DIALOG_ESC_PENDING=0
                ;;
        esac
    }

    # ==========================================================================
    # End Merge Dialog
    # ==========================================================================

    # Render footer with help text, timing, and clock (2 lines)
    # Args: $1=footer_row, $2=frame_start_ms
    watch_render_footer() {
        local footer_row="$1"
        local frame_start_ms="$2"

        # Move cursor to footer row and start dim mode for footer
        printf '\e[%d;1H%s' "$footer_row" "$COLOR_DIM"

        # Check background process health and show age
        local bg_status=""
        if [[ -n "$HEARTBEAT_FILE" && -f "$HEARTBEAT_FILE" ]]; then
            local hb_time now_time hb_age
            read -r hb_time < "$HEARTBEAT_FILE" 2>/dev/null || hb_time=0
            now_time=$(date +%s)
            hb_age=$((now_time - hb_time))
            bg_status="bg:${hb_age}s  "
        fi

        # Build usage info string for right side of row 1 with color coding
        local usage_info=""
        local usage_info_visible_len=0
        if [[ -n "$USAGE_SESSION_PCT" || -n "$USAGE_WEEKLY_PCT" ]]; then
            local session_str=""
            local weekly_str=""
            if [[ -n "$USAGE_SESSION_PCT" ]]; then
                session_str=$(format_usage_pct "$USAGE_SESSION_PCT" "session")
                usage_info_visible_len=$((usage_info_visible_len + 8 + ${#USAGE_SESSION_PCT} + 1))  # "session:" + pct + "%"
            fi
            if [[ -n "$USAGE_WEEKLY_PCT" ]]; then
                weekly_str=$(format_usage_pct "$USAGE_WEEKLY_PCT" "weekly")
                if [[ -n "$session_str" ]]; then
                    usage_info_visible_len=$((usage_info_visible_len + 2))  # "  " separator
                fi
                usage_info_visible_len=$((usage_info_visible_len + 7 + ${#USAGE_WEEKLY_PCT} + 1))  # "weekly:" + pct + "%"
            fi
            if [[ -n "$session_str" && -n "$weekly_str" ]]; then
                usage_info="$session_str  $weekly_str"
            elif [[ -n "$session_str" ]]; then
                usage_info="$session_str"
            else
                usage_info="$weekly_str"
            fi
        fi

        # Row 1: Navigation keys (left) + Usage stats (right)
        local help_text
        if [[ $RIGHT_PANE_MODE -eq 2 ]]; then
            # Denials mode: show time filter toggle
            local filter_name="${DENIALS_TIME_FILTER_NAMES[$DENIALS_TIME_FILTER]}"
            help_text=";/l: scroll    t: filter [$filter_name]    n/p: pane    Ctrl-C: quit"
        elif [[ $RIGHT_PANE_MODE -eq 5 ]]; then
            # Diff mode: show scroll and pane navigation
            help_text=";/l: scroll    n/p: pane    Ctrl-C: quit"
        else
            # Normal mode
            help_text="j/k: select    ;/l: scroll    n/p: pane    Ctrl-C: quit"
        fi
        [[ $SCROLL_OFFSET -gt 0 ]] && help_text="[+$SCROLL_OFFSET]  $help_text"
        local help_text_len=${#help_text}
        local row1_padding=$((TERM_COLS - help_text_len - usage_info_visible_len))
        printf "%s%*s%s\n" "$help_text" "$row1_padding" "" "$usage_info"

        # Row 2: Action keys (left) + timing info (right)
        local action_text
        local action_text_visible_len
        if [[ $RIGHT_PANE_MODE -eq 2 ]]; then
            # Denials mode: show filter explanation
            action_text="Viewing aggregated permission denials across all agents"
            action_text_visible_len=${#action_text}
        elif [[ $RIGHT_PANE_MODE -eq 4 ]]; then
            # Errors mode: show clear option
            action_text="c: clear all    n/p: pane"
            action_text_visible_len=${#action_text}
        elif [[ $RIGHT_PANE_MODE -eq 5 ]]; then
            # Diff mode: show merge status info
            case "$DIFF_MERGE_STATUS" in
                ok)
                    action_text=$'\e[32m'"Merge ready: no conflicts detected"$'\e[0m'
                    action_text_visible_len=34  # length of "Merge ready: no conflicts detected"
                    ;;
                conflicts)
                    action_text=$'\e[31m'"Merge blocked: conflicts exist"$'\e[0m'
                    action_text_visible_len=30  # length of "Merge blocked: conflicts exist"
                    ;;
                error)
                    action_text=$'\e[33m'"Error checking merge status"$'\e[0m'
                    action_text_visible_len=27  # length of "Error checking merge status"
                    ;;
                *)
                    action_text="Checking merge status..."
                    action_text_visible_len=${#action_text}
                    ;;
            esac
        else
            # Normal mode: show action keys
            action_text="/: jump    s: send    m: merge    x: kill    !: nuke    a: new agent"
            action_text_visible_len=${#action_text}
            # Add errors indicator if there are unread errors (in red, then restore dim)
            if [[ $ERRORS_UNREAD_COUNT -gt 0 ]]; then
                action_text="$action_text    ${COLOR_RED}e: errors ($ERRORS_UNREAD_COUNT)${COLOR_RESET}${COLOR_DIM}"
                local err_text="    e: errors ($ERRORS_UNREAD_COUNT)"
                action_text_visible_len=$((action_text_visible_len + ${#err_text}))
            fi
            # Add setup indicator (yellow if any setup item not installed, normal if all installed)
            if [[ $SETUP_HOOKS_INSTALLED -ne 1 || $SETUP_IB_INSTRUCTIONS -ne 1 || $SETUP_STATUS_IMPORT -ne 1 || $SETUP_GITIGNORE -ne 1 ]]; then
                # At least one setup item is not installed - show in yellow, then restore dim
                action_text="$action_text    ${COLOR_YELLOW}h: setup${COLOR_RESET}${COLOR_DIM}"
                action_text_visible_len=$((action_text_visible_len + 12))  # "    h: setup" = 12 chars
            else
                # All setup items installed - show in normal (dim) color
                action_text="$action_text    h: setup"
                action_text_visible_len=$((action_text_visible_len + 12))  # "    h: setup" = 12 chars
            fi
        fi
        # Use LAST_FRAME_MS from previous complete frame (includes sleep)
        local frame_ms=$LAST_FRAME_MS
        if [[ $frame_ms -eq 0 ]]; then
            # First frame, calculate render time only
            local frame_end_ms=$(get_ms)
            frame_ms=$((frame_end_ms - frame_start_ms))
        fi
        local fps=0
        if [[ $frame_ms -gt 0 ]]; then
            fps=$((1000 / frame_ms))
        fi
        local current_time
        current_time=$(date +%H:%M:%S)
        printf -v right_info "%sframe:%3dms  fps:%2d  %s" "$bg_status" "$frame_ms" "$fps" "$current_time"
        local padding=$((TERM_COLS - action_text_visible_len - ${#right_info}))
        printf "%s%*s%s%s" "$action_text" "$padding" "" "$right_info" "$COLOR_RESET"
    }

    # Render tree with selection highlighting
    # Args: $1=tmpfile
    # Sets: _WATCH_SELECTED_ID, _WATCH_TREE_DISPLAY_LINES
    # Modifies: SELECTED_INDEX, SELECTED_NAME, TREE_SCROLL, AGENT_COUNT
    watch_render_tree() {
        local tmpfile="$1"

        # Read agent IDs directly from tmpfile (already in tree order!)
        local agent_ids=()
        local line
        while IFS= read -r line; do
            agent_ids+=("${line%%|*}")
        done < "$tmpfile"
        AGENT_COUNT=${#agent_ids[@]}

        # Reconcile SELECTED_NAME with SELECTED_INDEX
        # If we have a name, try to find it in the list to handle insertions/deletions
        if [[ -n "$SELECTED_NAME" && $AGENT_COUNT -gt 0 ]]; then
            local found_idx=-1
            local i
            for ((i=0; i<AGENT_COUNT; i++)); do
                if [[ "${agent_ids[$i]}" == "$SELECTED_NAME" ]]; then
                    found_idx=$i
                    break
                fi
            done
            if [[ $found_idx -ge 0 ]]; then
                # Found the agent - update index to match
                SELECTED_INDEX=$found_idx
            fi
            # If not found, keep using SELECTED_INDEX (will clamp below and update SELECTED_NAME)
        fi

        # Clamp selection to valid range
        if [[ $SELECTED_INDEX -ge $AGENT_COUNT ]]; then
            SELECTED_INDEX=$((AGENT_COUNT - 1))
        fi
        if [[ $SELECTED_INDEX -lt 0 ]]; then
            SELECTED_INDEX=0
        fi

        # Get the selected agent ID and update SELECTED_NAME
        _WATCH_SELECTED_ID="${agent_ids[$SELECTED_INDEX]}"
        SELECTED_NAME="$_WATCH_SELECTED_ID"

        # Set terminal title to selected agent name
        printf '\e]0;ib watch: %s\a' "$_WATCH_SELECTED_ID"

        # Get tree lines (no subprocess - uses global arrays)
        build_tree_lines "$tmpfile"
        format_tree_lines "$TERM_COLS"
        local tree_lines=("${_FORMATTED_TREE_LINES[@]}")
        local total_tree_lines=${#tree_lines[@]}

        # Calculate tree scroll to keep selection in middle positions (1-3)
        # Only use position 0 when at first item, position 4 when at last item
        # This makes it clear when you've hit the top or bottom of the list
        if [[ $AGENT_COUNT -le 5 ]]; then
            # All agents fit on screen - no scrolling needed
            TREE_SCROLL=0
        elif [[ $SELECTED_INDEX -eq 0 ]]; then
            # First item - show at position 0
            TREE_SCROLL=0
        elif [[ $SELECTED_INDEX -eq $((AGENT_COUNT - 1)) ]]; then
            # Last item - show at position 4 (bottom)
            TREE_SCROLL=$((AGENT_COUNT - 5))
        else
            # Keep selection in middle positions (1-3)
            # Ideal position is 2 (center of 0-4)
            local ideal_scroll=$((SELECTED_INDEX - 2))
            # Clamp to valid range
            if [[ $ideal_scroll -lt 0 ]]; then
                ideal_scroll=0
            elif [[ $ideal_scroll -gt $((AGENT_COUNT - 5)) ]]; then
                ideal_scroll=$((AGENT_COUNT - 5))
            fi
            TREE_SCROLL=$ideal_scroll
        fi

        # Display min(agent count, 5) lines of tree with selection highlighting
        # Skip rendering the header tree when TREE or DIFF pane is active (modes 3, 5) to use full height
        if [[ $RIGHT_PANE_MODE -eq 3 || $RIGHT_PANE_MODE -eq 5 ]]; then
            _WATCH_TREE_DISPLAY_LINES=0
        else
            _WATCH_TREE_DISPLAY_LINES=$total_tree_lines
            [[ $_WATCH_TREE_DISPLAY_LINES -gt 5 ]] && _WATCH_TREE_DISPLAY_LINES=5
            local display_line
            for ((display_line=0; display_line<_WATCH_TREE_DISPLAY_LINES; display_line++)); do
                local tree_idx=$((TREE_SCROLL + display_line))
                if [[ $tree_idx -lt $total_tree_lines ]]; then
                    line="${tree_lines[$tree_idx]}"
                    if [[ $tree_idx -eq $SELECTED_INDEX ]]; then
                        # Highlight selected line with reverse video
                        printf "\e[7m%-${TERM_COLS}.${TERM_COLS}s\e[0m\n" "$line"
                    else
                        printf "%-${TERM_COLS}.${TERM_COLS}s\n" "$line"
                    fi
                else
                    printf "%-${TERM_COLS}s\n" ""
                fi
            done
        fi
    }

    # Render split panes (tmux output + agent log)
    # Args: $1=selected_id, $2=tree_display_lines
    # Sets: _WATCH_PANE_START_ROW, _WATCH_PANE_HEIGHT
    # Modifies: SCROLL_OFFSET, PREV_SELECTED_INDEX
    watch_render_split_panes() {
        local selected_id="$1"
        local tree_display_lines="$2"
        local tmpfile="$3"

        # Check if selected agent is orphaned (worker with missing manager)
        local is_orphaned=false
        local agent_meta="$AGENTS_DIR/$selected_id/meta.json"
        if [[ -f "$agent_meta" ]]; then
            local agent_worker=$(read_meta_field "$agent_meta" "worker" "false")
            local agent_manager=$(read_meta_field "$agent_meta" "manager" "")
            if [[ "$agent_worker" == "true" && -n "$agent_manager" ]]; then
                # This is a worker with a manager - check if manager exists
                if [[ ! -d "$AGENTS_DIR/$agent_manager" ]]; then
                    is_orphaned=true
                fi
            fi
        fi

        # Calculate pane dimensions
        # Left pane uses TMUX_WIDTH, right pane gets the rest
        # Rows: tree + pane_header(1) + pane_separator(1) + footer(2) = tree + 4
        # If orphaned, add warning pane (2 lines)
        local warning_pane_height=0
        if [[ "$is_orphaned" == "true" ]]; then
            warning_pane_height=2
        fi
        local pane_height=$((TERM_LINES - tree_display_lines - 4 - warning_pane_height))  # header + separator + 2 footer lines + warning
        local left_pane_width=$TMUX_WIDTH
        local right_pane_width=$((TERM_COLS - TMUX_WIDTH - 3))  # -3 for " │ " separator

        # ===== SPECIAL HANDLING FOR DENIALS PANE (MODE 2) =====
        if [[ $RIGHT_PANE_MODE -eq 2 ]]; then
            # Set terminal title (since tree rendering is skipped)
            printf '\e]0;ib watch: denials\a'

            # Full-width header for denials mode (box chars dim, title white)
            local filter_name="${DENIALS_TIME_FILTER_NAMES[$DENIALS_TIME_FILTER]}"
            local title="DENIED TOOLS ($filter_name)"
            local pad_count=$((TERM_COLS - 3 - ${#title} - 1))  # 3 for "── ", 1 for trailing space
            [[ $pad_count -lt 0 ]] && pad_count=0
            local pad=""
            local i
            for ((i=0; i<pad_count; i++)); do pad="${pad}─"; done
            printf "%s── %s%s%s %s%s\n" "$COLOR_DIM" "$COLOR_RESET" "$title" "$COLOR_DIM" "$pad" "$COLOR_RESET"

            # Load denials from background cache (non-blocking)
            load_denials_from_cache

            # Render full-width denials pane (hide left tmux pane)
            local content_height=$pane_height
            local content_width=$TERM_COLS

            # Render denial lines
            local total_lines=${#DENIALS_CACHE_LINES[@]}

            # Show loading state if cache not loaded yet
            if [[ $DENIALS_CACHE_LOADED -eq 0 ]]; then
                local loading_msg="Loading permission denials..."
                for ((line_num=0; line_num<content_height; line_num++)); do
                    if [[ $line_num -eq $((content_height / 2)) ]]; then
                        # Center the message
                        local padding=$(( (content_width - ${#loading_msg}) / 2 ))
                        printf '%*s%s\n' "$padding" "" "$loading_msg"
                    else
                        printf '%-*s\n' "$content_width" ""
                    fi
                done
            # Show "No permission denials" if loaded but empty
            elif [[ $total_lines -eq 0 ]]; then
                local filter_name="${DENIALS_TIME_FILTER_NAMES[$DENIALS_TIME_FILTER]}"
                local empty_msg="No permission denials recorded ($filter_name)"
                for ((line_num=0; line_num<content_height; line_num++)); do
                    if [[ $line_num -eq $((content_height / 2)) ]]; then
                        # Center the message
                        local padding=$(( (content_width - ${#empty_msg}) / 2 ))
                        printf '%*s%s\n' "$padding" "" "$empty_msg"
                    else
                        printf '%-*s\n' "$content_width" ""
                    fi
                done
            else
                # Calculate scroll parameters
                local max_scroll=$((total_lines - content_height + 1))
                [[ $max_scroll -lt 0 ]] && max_scroll=0
                [[ $SCROLL_OFFSET -gt $max_scroll ]] && SCROLL_OFFSET=$max_scroll
                [[ $SCROLL_OFFSET -lt 0 ]] && SCROLL_OFFSET=0

                local start_idx=$((total_lines - content_height - SCROLL_OFFSET + 1))
                [[ $start_idx -lt 0 ]] && start_idx=0

                local line_num
                for ((line_num=0; line_num<content_height; line_num++)); do
                    local array_idx=$((start_idx + line_num))
                    if [[ $array_idx -ge 0 && $array_idx -lt $total_lines ]]; then
                        # Truncate to terminal width
                        local display_line="${DENIALS_CACHE_LINES[$array_idx]:0:$content_width}"
                        printf '%-*s\n' "$content_width" "$display_line"
                    else
                        # Empty line (no content)
                        printf '%-*s\n' "$content_width" ""
                    fi
                done
            fi

            # Bottom separator (dim)
            local separator=""
            local i
            for ((i=0; i<content_width; i++)); do separator="${separator}─"; done
            printf '%s%s%s' "$COLOR_DIM" "$separator" "$COLOR_RESET"

            # Store pane info for footer
            _WATCH_PANE_START_ROW=$((tree_display_lines + 2))
            _WATCH_PANE_HEIGHT=$content_height

            return  # Skip normal split pane rendering
        fi

        # ===== TREE MODE (MODE 3) =====
        if [[ $RIGHT_PANE_MODE -eq 3 ]]; then
            # Full-width header for tree mode (box chars dim, title white)
            local title="AGENT TREE"
            local pad_count=$((TERM_COLS - 3 - ${#title} - 1))  # 3 for "── ", 1 for trailing space
            [[ $pad_count -lt 0 ]] && pad_count=0
            local pad=""
            local i
            for ((i=0; i<pad_count; i++)); do pad="${pad}─"; done
            printf "%s── %s%s%s %s%s\n" "$COLOR_DIM" "$COLOR_RESET" "$title" "$COLOR_DIM" "$pad" "$COLOR_RESET"

            # Render full-width tree pane (hide left tmux pane)
            local content_height=$pane_height
            local content_width=$TERM_COLS

            # Build tree using existing tree building functions
            # Use the same tmpfile that was already built for the top tree display
            build_tree_lines "$tmpfile"
            format_tree_lines "$TERM_COLS"
            local tree_lines=("${_FORMATTED_TREE_LINES[@]}")
            local total_lines=${#tree_lines[@]}

            # Show "No agents" if empty
            if [[ $total_lines -eq 0 ]]; then
                local empty_msg="No agents running"
                for ((line_num=0; line_num<content_height; line_num++)); do
                    if [[ $line_num -eq $((content_height / 2)) ]]; then
                        # Center the message
                        local padding=$(( (content_width - ${#empty_msg}) / 2 ))
                        printf '%*s%s\n' "$padding" "" "$empty_msg"
                    else
                        printf '%-*s\n' "$content_width" ""
                    fi
                done
            else
                # Calculate scroll parameters
                local max_scroll=$((total_lines - content_height + 1))
                [[ $max_scroll -lt 0 ]] && max_scroll=0
                [[ $SCROLL_OFFSET -gt $max_scroll ]] && SCROLL_OFFSET=$max_scroll
                [[ $SCROLL_OFFSET -lt 0 ]] && SCROLL_OFFSET=0

                local start_idx=$((total_lines - content_height - SCROLL_OFFSET + 1))
                [[ $start_idx -lt 0 ]] && start_idx=0

                local line_num
                for ((line_num=0; line_num<content_height; line_num++)); do
                    local array_idx=$((start_idx + line_num))
                    if [[ $array_idx -ge 0 && $array_idx -lt $total_lines ]]; then
                        # Truncate to terminal width
                        local display_line="${tree_lines[$array_idx]:0:$content_width}"
                        printf '%-*s\n' "$content_width" "$display_line"
                    else
                        # Empty line (no content)
                        printf '%-*s\n' "$content_width" ""
                    fi
                done
            fi

            # Bottom separator (dim)
            local separator=""
            local i
            for ((i=0; i<content_width; i++)); do separator="${separator}─"; done
            printf '%s%s%s' "$COLOR_DIM" "$separator" "$COLOR_RESET"

            # Store pane info for footer
            _WATCH_PANE_START_ROW=$((tree_display_lines + 2))
            _WATCH_PANE_HEIGHT=$content_height

            return  # Skip normal split pane rendering
        fi

        # ===== ERRORS MODE (MODE 4) =====
        if [[ $RIGHT_PANE_MODE -eq 4 ]]; then
            # Mark errors as read when viewing errors pane
            watch_mark_errors_read

            # Full-width header for errors mode (dim)
            local error_count=${#ERRORS_CACHE[@]}
            local header="── ERRORS ($error_count) "
            while [[ ${#header} -lt $TERM_COLS ]]; do
                header="${header}─"
            done
            printf "%s%s%s\n" "$COLOR_DIM" "$header" "$COLOR_RESET"

            # Render full-width errors pane (hide left tmux pane)
            local content_height=$pane_height
            local content_width=$TERM_COLS

            # Build display lines from errors cache (newest first)
            local -a error_lines=()
            local i
            for ((i=${#ERRORS_CACHE[@]}-1; i>=0; i--)); do
                local entry="${ERRORS_CACHE[$i]}"
                local timestamp="${entry%%|*}"
                local rest="${entry#*|}"
                local title="${rest%%|*}"
                local message="${rest#*|}"
                # Format: [HH:MM:SS] Title: Message
                error_lines+=("[$timestamp] $title")
                # Wrap message to width with indent
                local indent="           "  # 11 spaces for timestamp alignment
                local msg_width=$((content_width - ${#indent}))
                while [[ ${#message} -gt $msg_width ]]; do
                    error_lines+=("$indent${message:0:$msg_width}")
                    message="${message:$msg_width}"
                done
                [[ -n "$message" ]] && error_lines+=("$indent$message")
                error_lines+=("")  # Blank line between errors
            done

            local total_lines=${#error_lines[@]}

            # Show "No errors" if empty
            if [[ $total_lines -eq 0 ]]; then
                local empty_msg="No errors recorded"
                # Truncate message if wider than content area
                if [[ ${#empty_msg} -gt $content_width ]]; then
                    empty_msg="${empty_msg:0:$content_width}"
                fi
                for ((line_num=0; line_num<content_height; line_num++)); do
                    if [[ $line_num -eq $((content_height / 2)) ]]; then
                        # Center the message
                        local padding=$(( (content_width - ${#empty_msg}) / 2 ))
                        [[ $padding -lt 0 ]] && padding=0
                        printf '%*s%s\n' "$padding" "" "$empty_msg"
                    else
                        printf '%-*s\n' "$content_width" ""
                    fi
                done
            else
                # Calculate scroll parameters (scroll from top, newest first)
                local max_scroll=$((total_lines - content_height))
                [[ $max_scroll -lt 0 ]] && max_scroll=0
                [[ $SCROLL_OFFSET -gt $max_scroll ]] && SCROLL_OFFSET=$max_scroll
                [[ $SCROLL_OFFSET -lt 0 ]] && SCROLL_OFFSET=0

                local start_idx=$SCROLL_OFFSET

                local line_num
                for ((line_num=0; line_num<content_height; line_num++)); do
                    local array_idx=$((start_idx + line_num))
                    if [[ $array_idx -ge 0 && $array_idx -lt $total_lines ]]; then
                        # Truncate to terminal width
                        local display_line="${error_lines[$array_idx]:0:$content_width}"
                        printf '%-*s\n' "$content_width" "$display_line"
                    else
                        # Empty line (no content)
                        printf '%-*s\n' "$content_width" ""
                    fi
                done
            fi

            # Bottom separator (dim)
            local separator=""
            local i
            for ((i=0; i<content_width; i++)); do separator="${separator}─"; done
            printf '%s%s%s' "$COLOR_DIM" "$separator" "$COLOR_RESET"

            # Store pane info for footer
            _WATCH_PANE_START_ROW=$((tree_display_lines + 2))
            _WATCH_PANE_HEIGHT=$content_height

            return  # Skip normal split pane rendering
        fi

        # ===== DIFF MODE (MODE 5) =====
        if [[ $RIGHT_PANE_MODE -eq 5 ]]; then
            # Load diff from background cache (non-blocking)
            load_diff_from_cache "$selected_id"

            # Build header with merge status indicator
            local merge_indicator=""
            case "$DIFF_MERGE_STATUS" in
                ok)        merge_indicator=" (merge OK)" ;;
                conflicts) merge_indicator=" (CONFLICTS)" ;;
                error)     merge_indicator=" (error)" ;;
                *)         merge_indicator="" ;;  # Still loading
            esac

            # Full-width header for diff mode
            local header="── DIFF$merge_indicator "
            while [[ ${#header} -lt $TERM_COLS ]]; do
                header="${header}─"
            done
            printf "%s\n" "$header"

            # Render full-width diff pane (hide left tmux pane)
            local content_height=$pane_height
            local content_width=$TERM_COLS

            local total_lines=${#DIFF_CACHE_LINES[@]}

            # Show loading state if cache not loaded yet
            if [[ $DIFF_CACHE_LOADED -eq 0 ]]; then
                local loading_msg="Loading diff..."
                for ((line_num=0; line_num<content_height; line_num++)); do
                    if [[ $line_num -eq $((content_height / 2)) ]]; then
                        # Center the message
                        local padding=$(( (content_width - ${#loading_msg}) / 2 ))
                        printf '%*s%s\n' "$padding" "" "$loading_msg"
                    else
                        printf '%-*s\n' "$content_width" ""
                    fi
                done
            # Show "No changes" if loaded but empty
            elif [[ $total_lines -eq 0 ]]; then
                local empty_msg="No changes (branch is identical to base)"
                for ((line_num=0; line_num<content_height; line_num++)); do
                    if [[ $line_num -eq $((content_height / 2)) ]]; then
                        # Center the message
                        local padding=$(( (content_width - ${#empty_msg}) / 2 ))
                        printf '%*s%s\n' "$padding" "" "$empty_msg"
                    else
                        printf '%-*s\n' "$content_width" ""
                    fi
                done
            else
                # Calculate scroll parameters (scroll from top like a normal diff view)
                local max_scroll=$((total_lines - content_height))
                [[ $max_scroll -lt 0 ]] && max_scroll=0
                [[ $SCROLL_OFFSET -gt $max_scroll ]] && SCROLL_OFFSET=$max_scroll
                [[ $SCROLL_OFFSET -lt 0 ]] && SCROLL_OFFSET=0

                local start_idx=$SCROLL_OFFSET

                local line_num
                for ((line_num=0; line_num<content_height; line_num++)); do
                    local array_idx=$((start_idx + line_num))
                    if [[ $array_idx -ge 0 && $array_idx -lt $total_lines ]]; then
                        # Truncate to terminal width
                        local display_line="${DIFF_CACHE_LINES[$array_idx]:0:$content_width}"
                        local visible_len=${#display_line}
                        # Apply diff colorization
                        colorize_diff_line "$display_line"
                        # Calculate padding needed (visible chars only)
                        local padding=$((content_width - visible_len))
                        [[ $padding -lt 0 ]] && padding=0
                        printf '%s%*s\n' "$_COLORIZED_LINE" "$padding" ""
                    else
                        # Empty line (no content)
                        printf '%-*s\n' "$content_width" ""
                    fi
                done
            fi

            # Bottom separator
            local separator=""
            local i
            for ((i=0; i<content_width; i++)); do separator="${separator}─"; done
            printf '%s' "$separator"

            # Store pane info for footer
            _WATCH_PANE_START_ROW=$((tree_display_lines + 2))
            _WATCH_PANE_HEIGHT=$content_height

            return  # Skip normal split pane rendering
        fi

        # ===== NORMAL SPLIT PANE MODE =====

        # Pane headers with box-drawing characters dim but titles white
        local left_title="$selected_id"
        local right_title="${RIGHT_PANE_NAMES[$RIGHT_PANE_MODE]}"
        # Calculate padding needed after titles (account for "── " prefix and " " suffix around title)
        local left_pad_count=$((left_pane_width - 3 - ${#left_title} - 1))  # 3 for "── ", 1 for trailing space
        local right_pad_count=$((right_pane_width - 3 - ${#right_title} - 1))
        [[ $left_pad_count -lt 0 ]] && left_pad_count=0
        [[ $right_pad_count -lt 0 ]] && right_pad_count=0
        local left_pad="" right_pad=""
        local i
        for ((i=0; i<left_pad_count; i++)); do left_pad="${left_pad}─"; done
        for ((i=0; i<right_pad_count; i++)); do right_pad="${right_pad}─"; done
        # Format: dim "── " + reset + title + dim " ─────" for each pane
        printf "%s── %s%s%s %s─┬─── %s%s%s %s%s\n" \
            "$COLOR_DIM" "$COLOR_RESET" "$left_title" "$COLOR_DIM" "$left_pad" \
            "$COLOR_RESET" "$right_title" "$COLOR_DIM" "$right_pad" "$COLOR_RESET"

        # ===== ORPHAN WARNING PANE =====
        if [[ "$is_orphaned" == "true" ]]; then
            # Get manager ID from meta
            local manager_id=$(read_meta_field "$agent_meta" "manager" "unknown")
            local warning_msg="⚠️  WARNING: This worker agent is orphaned. Manager '$manager_id' no longer exists."
            # Print warning pane (2 lines: message + separator)
            printf '\e[33m%-*s\e[0m\n' "$TERM_COLS" "$warning_msg"
            local warning_sep=""
            local i
            for ((i=0; i<TERM_COLS; i++)); do warning_sep="${warning_sep}─"; done
            printf '%s\n' "$warning_sep"
        fi

        # Reset scroll offset when agent changes
        if [[ $SELECTED_INDEX -ne $PREV_SELECTED_INDEX ]]; then
            SCROLL_OFFSET=0
            PREV_SELECTED_INDEX=$SELECTED_INDEX
        fi

        # ===== PHASE 1: COLLECT & PROCESS DATA =====

        # Capture more lines for scrolling (up to 500 lines of history)
        local capture_lines=500

        # Get tmux output for selected agent (all lines, for total count)
        local tmux_session
        tmux_session=$(session_name "$selected_id")
        local all_tmux_lines=()
        # Try background cache first, then direct capture
        local tmux_output=""
        local cache_file="$TMUX_CACHE_DIR/$selected_id"
        if [[ -n "$TMUX_CACHE_DIR" && -f "$cache_file" ]]; then
            # Read from background cache using bash builtin (no subprocess)
            tmux_output=$(<"$cache_file") 2>/dev/null || true
        else
            # Fallback: capture directly from tmux and strip ANSI codes
            local raw_output
            raw_output=$(tmux capture-pane -t "$tmux_session" -p -S -"$capture_lines" 2>/dev/null) || true
            if [[ -n "$raw_output" ]]; then
                _strip_ansi "$raw_output"
                tmux_output="$_STRIP_ANSI_RESULT"
            fi
        fi
        local line
        if [[ -n "$tmux_output" ]]; then
            while IFS= read -r line; do
                all_tmux_lines+=("$line")
            done <<< "$tmux_output"
        fi

        # Get right pane content based on mode
        local right_pane_lines=()

        if [[ $RIGHT_PANE_MODE -eq 0 ]]; then
            # Mode 0: Agent log (pre-wrapped by background process, cached parse)
            # Update width file for background process (only when changed to reduce I/O)
            if [[ -n "$LOG_WIDTH_FILE" && "$right_pane_width" != "$LOG_WIDTH_PREV" ]]; then
                echo "$right_pane_width" > "$LOG_WIDTH_FILE"
                LOG_WIDTH_PREV="$right_pane_width"
            fi

            # Only check file every 7 frames (or immediately on agent change)
            local log_cache_file="$LOG_CACHE_DIR/$selected_id"
            if [[ "$LOG_PARSED_AGENT" != "$selected_id" ]] || [[ $((STATE_FRAME_COUNT % 7)) -eq 0 ]]; then
                if [[ -n "$LOG_CACHE_DIR" && -f "$log_cache_file" ]]; then
                    local log_content
                    log_content=$(<"$log_cache_file") 2>/dev/null || true
                    local content_len=${#log_content}

                    # Reparse if agent changed or content length changed
                    if [[ "$LOG_PARSED_AGENT" != "$selected_id" || "$LOG_PARSED_LEN" != "$content_len" ]]; then
                        LOG_PARSED_LINES=()
                        if [[ -n "$log_content" ]]; then
                            while IFS= read -r line; do
                                LOG_PARSED_LINES+=("$line")
                            done <<< "$log_content"
                        fi
                        LOG_PARSED_AGENT="$selected_id"
                        LOG_PARSED_LEN=$content_len
                    fi
                elif [[ "$LOG_PARSED_AGENT" != "$selected_id" ]]; then
                    # No cache file, clear if agent changed
                    LOG_PARSED_LINES=()
                    LOG_PARSED_AGENT="$selected_id"
                    LOG_PARSED_LEN=0
                fi
            fi
            right_pane_lines=("${LOG_PARSED_LINES[@]}")
        else
            # Mode 1: Initial prompt from prompt.txt
            local prompt_file="$AGENTS_DIR/$selected_id/prompt.txt"
            if [[ -f "$prompt_file" ]]; then
                local prompt_content
                prompt_content=$(<"$prompt_file") 2>/dev/null || true
                if [[ -n "$prompt_content" ]]; then
                    # Trim to [USER TASK] marker if present (removes repetitive prefix)
                    local user_task_marker="[USER TASK]"
                    if [[ "$prompt_content" == *"$user_task_marker"* ]]; then
                        prompt_content="${prompt_content#*"$user_task_marker"}"
                        # Remove leading newlines after the marker
                        prompt_content="${prompt_content#$'\n'}"
                    fi
                    # Wrap prompt to right pane width using fold
                    local wrapped
                    wrapped=$(echo "$prompt_content" | fold -s -w "$right_pane_width")
                    while IFS= read -r line; do
                        right_pane_lines+=("$line")
                    done <<< "$wrapped"
                fi
            fi
        fi

        local tmux_total=${#all_tmux_lines[@]}
        local right_total=${#right_pane_lines[@]}

        # Calculate and clamp scroll offset
        # Use max of the two so scrolling works if either pane has content
        local tmux_max_scroll=$((tmux_total - pane_height))
        local right_max_scroll=$((right_total - pane_height))
        [[ $tmux_max_scroll -lt 0 ]] && tmux_max_scroll=0
        [[ $right_max_scroll -lt 0 ]] && right_max_scroll=0
        local max_scroll=$tmux_max_scroll
        [[ $right_max_scroll -gt $max_scroll ]] && max_scroll=$right_max_scroll
        [[ $SCROLL_OFFSET -gt $max_scroll ]] && SCROLL_OFFSET=$max_scroll
        [[ $SCROLL_OFFSET -lt 0 ]] && SCROLL_OFFSET=0

        # Extract visible window of tmux lines (truncate to width)
        local visible_tmux_lines=()
        local pane_line

        # Extract visible lines and truncate (ANSI already stripped by background process)
        local tmux_start_idx=$((tmux_total - pane_height - SCROLL_OFFSET))
        for ((pane_line=0; pane_line<pane_height; pane_line++)); do
            local tmux_idx=$((tmux_start_idx + pane_line))
            if [[ $tmux_idx -ge 0 && $tmux_idx -lt $tmux_total ]]; then
                visible_tmux_lines+=("${all_tmux_lines[$tmux_idx]:0:$left_pane_width}")
            else
                visible_tmux_lines+=("")
            fi
        done

        # Extract visible window of right pane lines (truncate to current width in case of resize)
        local visible_right_lines=()
        local right_start_idx=$((right_total - pane_height - SCROLL_OFFSET))
        for ((pane_line=0; pane_line<pane_height; pane_line++)); do
            local right_idx=$((right_start_idx + pane_line))
            if [[ $right_idx -ge 0 && $right_idx -lt $right_total ]]; then
                visible_right_lines+=("${right_pane_lines[$right_idx]:0:$right_pane_width}")
            else
                visible_right_lines+=("")
            fi
        done

        # ===== PHASE 2: RENDER (no processing, just print) =====

        _WATCH_PANE_START_ROW=$((tree_display_lines + 2))  # tree + pane_header
        _WATCH_PANE_HEIGHT=$pane_height
        for ((pane_line=0; pane_line<pane_height; pane_line++)); do
            local row=$((_WATCH_PANE_START_ROW + pane_line))
            local right_line="${visible_right_lines[$pane_line]}"
            # Colorize log lines in agent log mode (mode 0)
            if [[ $RIGHT_PANE_MODE -eq 0 && -n "$right_line" ]]; then
                colorize_log_line "$right_line"
                right_line="$_COLORIZED_LINE"
            fi
            printf '\e[%d;1H\e[K%s\e[%d;%dH %s│%s %s' \
                "$row" "${visible_tmux_lines[$pane_line]}" \
                "$row" "$((left_pane_width + 1))" \
                "$COLOR_DIM" "$COLOR_RESET" "$right_line"
        done

        # Bottom separator line with connected box-drawing character (dim)
        local separator_row=$((_WATCH_PANE_START_ROW + pane_height))
        local left_sep="" right_sep=""
        local i
        for ((i=0; i<left_pane_width; i++)); do left_sep="${left_sep}─"; done
        for ((i=0; i<right_pane_width; i++)); do right_sep="${right_sep}─"; done
        printf '\e[%d;1H%s%s─┴─%s%s' "$separator_row" "$COLOR_DIM" "$left_sep" "$right_sep" "$COLOR_RESET"
    }

    # Background process to collect permission denials and write to cache file
    # This runs in a loop, refreshing the cache file periodically
    # Args: $1=cache_file, $2=time_filter (0=active, 1=24h, 2=7d), $3=agents_dir, $4=archive_dir
    denials_background_collector() {
        local cache_file="$1"
        local time_filter="$2"
        local agents_dir="$3"
        local archive_dir="$4"
        local refresh_interval=10  # Refresh every 10 seconds

        while true; do
            local now
            now=$(date +%s)
            local tmpfile
            tmpfile=$(mktemp)

            # Active agents (always included)
            # Look for both "Permission denied" and "Path violation" patterns
            if [[ -d "$agents_dir" ]]; then
                for agent_log in "$agents_dir"/*/agent.log; do
                    [[ -f "$agent_log" ]] || continue
                    local agent_id
                    agent_id=$(basename "$(dirname "$agent_log")")
                    # Grep for both denial patterns
                    grep -E "Permission denied|Path violation" "$agent_log" 2>/dev/null | \
                        while IFS= read -r log_line; do
                            # Extract timestamp and format
                            local timestamp="${log_line#*[}"
                            timestamp="${timestamp%%]*}"
                            local denial="${log_line#*] }"
                            echo "$timestamp|$agent_id|$denial"
                        done >> "$tmpfile"
                done
            fi

            # Archived agents (if time filter allows)
            if [[ $time_filter -gt 0 && -d "$archive_dir" ]]; then
                # Calculate cutoff timestamp
                local cutoff_seconds
                if [[ $time_filter -eq 1 ]]; then
                    cutoff_seconds=$((now - 86400))  # 24 hours
                else
                    cutoff_seconds=$((now - 604800))  # 7 days
                fi

                # Convert to YYYYMMDD-HHMMSS format for directory name comparison
                local cutoff_date
                cutoff_date=$(date -r "$cutoff_seconds" +%Y%m%d-%H%M%S 2>/dev/null)

                # If date -r is not supported (Linux), use -d instead
                if [[ -z "$cutoff_date" ]]; then
                    cutoff_date=$(date -d "@$cutoff_seconds" +%Y%m%d-%H%M%S 2>/dev/null)
                fi

                # Find archive directories newer than cutoff
                for archive_dir_entry in "$archive_dir"/20*-*; do
                    [[ -d "$archive_dir_entry" ]] || continue
                    local dir_name
                    dir_name=$(basename "$archive_dir_entry")
                    local dir_timestamp="${dir_name%%-*}-${dir_name#*-}"
                    dir_timestamp="${dir_timestamp%%-*}"

                    if [[ "$dir_timestamp" > "$cutoff_date" || "$dir_timestamp" == "$cutoff_date" ]]; then
                        if [[ -f "$archive_dir_entry/agent.log" ]]; then
                            local agent_name="${dir_name#*-*-}"
                            grep -E "Permission denied|Path violation" "$archive_dir_entry/agent.log" 2>/dev/null | \
                                while IFS= read -r log_line; do
                                    local timestamp="${log_line#*[}"
                                    timestamp="${timestamp%%]*}"
                                    local denial="${log_line#*] }"
                                    echo "$timestamp|$agent_name|$denial"
                                done >> "$tmpfile"
                        fi
                    fi
                done
            fi

            # Sort and write to cache file atomically
            local sorted_file
            sorted_file=$(mktemp)
            sort "$tmpfile" > "$sorted_file"
            mv "$sorted_file" "$cache_file"
            rm -f "$tmpfile"

            # Sleep before next refresh
            sleep $refresh_interval
        done
    }

    # Start the background denials collector
    # Sets DENIALS_BG_PID with the process ID
    start_denials_collector() {
        # Kill existing collector if any
        stop_denials_collector

        # Create cache file path
        DENIALS_CACHE_FILE=$(mktemp)

        # Start collector in background
        denials_background_collector "$DENIALS_CACHE_FILE" "$DENIALS_TIME_FILTER" "$AGENTS_DIR" "$ARCHIVE_DIR" &
        DENIALS_BG_PID=$!

        # Mark cache as not loaded yet
        DENIALS_CACHE_LOADED=0
        DENIALS_LAST_FILTER=$DENIALS_TIME_FILTER
    }

    # Stop the background denials collector
    stop_denials_collector() {
        if [[ -n "$DENIALS_BG_PID" ]]; then
            kill "$DENIALS_BG_PID" 2>/dev/null || true
            wait "$DENIALS_BG_PID" 2>/dev/null || true
            DENIALS_BG_PID=""
        fi
        if [[ -n "$DENIALS_CACHE_FILE" && -f "$DENIALS_CACHE_FILE" ]]; then
            rm -f "$DENIALS_CACHE_FILE"
            DENIALS_CACHE_FILE=""
        fi
        DENIALS_CACHE_LOADED=0
    }

    # Load denials from cache file into DENIALS_CACHE_LINES array
    # This is non-blocking - reads whatever is in the file
    load_denials_from_cache() {
        DENIALS_CACHE_LINES=()

        # Check if filter changed - need to restart collector
        if [[ $DENIALS_TIME_FILTER -ne $DENIALS_LAST_FILTER ]]; then
            start_denials_collector
            return
        fi

        # Check if cache file exists and has content
        if [[ -z "$DENIALS_CACHE_FILE" || ! -f "$DENIALS_CACHE_FILE" ]]; then
            return
        fi

        # Read lines from cache file
        while IFS='|' read -r timestamp agent_id denial_text; do
            [[ -n "$timestamp" ]] && DENIALS_CACHE_LINES+=("[$timestamp] $agent_id: $denial_text")
        done < "$DENIALS_CACHE_FILE"

        # Mark as loaded once we have data (or if file exists but is empty)
        DENIALS_CACHE_LOADED=1
    }

    # Background process to collect diff output and merge status for an agent
    # Args: $1=cache_file, $2=agent_id, $3=agents_dir
    diff_background_collector() {
        local cache_file="$1"
        local agent_id="$2"
        local agents_dir="$3"
        local refresh_interval=5  # Refresh every 5 seconds

        while true; do
            local tmpfile
            tmpfile=$(mktemp)

            local agent_dir="$agents_dir/$agent_id"
            local branch_name="agent/$agent_id"

            # Check if agent exists
            if [[ ! -d "$agent_dir" ]]; then
                echo "STATUS:error" > "$tmpfile"
                echo "Agent '$agent_id' not found" >> "$tmpfile"
                mv "$tmpfile" "$cache_file"
                sleep $refresh_interval
                continue
            fi

            # Check if branch exists
            if ! git show-ref --verify --quiet "refs/heads/$branch_name" 2>/dev/null; then
                echo "STATUS:error" > "$tmpfile"
                echo "Branch '$branch_name' does not exist" >> "$tmpfile"
                mv "$tmpfile" "$cache_file"
                sleep $refresh_interval
                continue
            fi

            # Determine target branch
            local target_branch=""
            if git show-ref --verify --quiet refs/heads/main 2>/dev/null; then
                target_branch="main"
            elif git show-ref --verify --quiet refs/heads/master 2>/dev/null; then
                target_branch="master"
            else
                target_branch="HEAD"
            fi

            # Check merge status
            local merge_status="ok"
            if ! git merge-tree "$(git merge-base "$target_branch" "$branch_name")" "$target_branch" "$branch_name" 2>/dev/null | grep -q "^<<<<<<<" ; then
                merge_status="ok"
            else
                merge_status="conflicts"
            fi

            # Alternative: use merge --no-commit --no-ff in a temporary worktree
            # For simplicity, we'll do a dry-run merge check
            local conflict_check
            conflict_check=$(git merge-base "$target_branch" "$branch_name" 2>/dev/null)
            if [[ -n "$conflict_check" ]]; then
                # Try to detect conflicts more reliably using git diff with conflict markers check
                local test_merge
                test_merge=$(git merge-tree "$conflict_check" "$target_branch" "$branch_name" 2>/dev/null || true)
                if echo "$test_merge" | grep -q "^<<<<<<<"; then
                    merge_status="conflicts"
                else
                    merge_status="ok"
                fi
            fi

            echo "STATUS:$merge_status" > "$tmpfile"

            # Get diff output
            local merge_base
            merge_base=$(git merge-base "$target_branch" "$branch_name" 2>/dev/null) || true
            if [[ -n "$merge_base" ]]; then
                git diff "$merge_base..$branch_name" 2>/dev/null >> "$tmpfile" || true
            fi

            # Atomic write
            mv "$tmpfile" "$cache_file"

            sleep $refresh_interval
        done
    }

    # Start the background diff collector for a specific agent
    # Args: $1=agent_id
    start_diff_collector() {
        local agent_id="$1"

        # Kill existing collector if any
        stop_diff_collector

        # Create cache file path
        DIFF_CACHE_FILE=$(mktemp)
        DIFF_CACHE_AGENT="$agent_id"

        # Start collector in background
        diff_background_collector "$DIFF_CACHE_FILE" "$agent_id" "$AGENTS_DIR" &
        DIFF_BG_PID=$!

        # Mark cache as not loaded yet
        DIFF_CACHE_LOADED=0
        DIFF_MERGE_STATUS=""
    }

    # Stop the background diff collector
    stop_diff_collector() {
        if [[ -n "$DIFF_BG_PID" ]]; then
            kill "$DIFF_BG_PID" 2>/dev/null || true
            wait "$DIFF_BG_PID" 2>/dev/null || true
            DIFF_BG_PID=""
        fi
        if [[ -n "$DIFF_CACHE_FILE" && -f "$DIFF_CACHE_FILE" ]]; then
            rm -f "$DIFF_CACHE_FILE"
            DIFF_CACHE_FILE=""
        fi
        DIFF_CACHE_LOADED=0
        DIFF_CACHE_AGENT=""
        DIFF_MERGE_STATUS=""
    }

    # Load diff from cache file into DIFF_CACHE_LINES array
    # Args: $1=agent_id (to check if we need to restart collector)
    load_diff_from_cache() {
        local agent_id="$1"
        DIFF_CACHE_LINES=()

        # Check if agent changed - need to restart collector
        if [[ "$DIFF_CACHE_AGENT" != "$agent_id" ]]; then
            start_diff_collector "$agent_id"
            return
        fi

        # Check if cache file exists and has content
        if [[ -z "$DIFF_CACHE_FILE" || ! -f "$DIFF_CACHE_FILE" ]]; then
            return
        fi

        # Read first line for status
        local first_line
        first_line=$(head -n 1 "$DIFF_CACHE_FILE" 2>/dev/null) || true
        if [[ "$first_line" == STATUS:* ]]; then
            DIFF_MERGE_STATUS="${first_line#STATUS:}"
            # Read rest of file as diff lines (using here-string to avoid subshell)
            local content
            content=$(tail -n +2 "$DIFF_CACHE_FILE" 2>/dev/null) || true
            if [[ -n "$content" ]]; then
                while IFS= read -r line; do
                    DIFF_CACHE_LINES+=("$line")
                done <<< "$content"
            fi
        fi

        # Mark as loaded once we have data
        DIFF_CACHE_LOADED=1
    }

    # Main render function
    watch_render() {
        local t_frame_start=$(get_ms)

        # Get terminal size
        TERM_LINES=$(tput lines)
        TERM_COLS=$(tput cols)

        # Validate minimum terminal size
        if [[ $TERM_LINES -lt 20 || $TERM_COLS -lt 80 ]]; then
            tput cup 0 0
            printf "Terminal too small (need 20x80, got %dx%d)\n" "$TERM_LINES" "$TERM_COLS"
            printf "Please resize your terminal window.\n"
            return
        fi

        # Refresh usage data periodically
        watch_refresh_usage

        # Move cursor to top-left (no flicker vs clear)
        tput cup 0 0

        # Build agent data (only get state for visible tree indices)
        # Called directly (not in subshell) to preserve meta.json cache
        local t_build_start t_build_end
        [[ $DEBUG_MODE -eq 1 ]] && t_build_start=$(get_ms)
        build_agent_data_file "$TREE_SCROLL" "$((TREE_SCROLL + 4))"
        [[ $DEBUG_MODE -eq 1 ]] && { t_build_end=$(get_ms); _debug_timing_record "build_agent_data" $((t_build_end - t_build_start)); }
        local tmpfile="$BUILD_AGENT_DATA_RESULT"
        # Ensure tmpfile cleanup on any exit path
        trap "rm -f '$tmpfile'" RETURN

        if [[ ! -s "$tmpfile" ]]; then
            # No agents - show proper screen with message
            AGENT_COUNT=0
            _WATCH_SELECTED_ID=""

            # Only redraw when dirty (reduces flicker)
            if [[ "${_NO_AGENTS_DIRTY:-1}" != "1" ]]; then
                # Just update footer for timing
                local pane_height=$((TERM_LINES - 5 - 4))  # 5 tree lines + header + separator + 2 footer
                local footer_row=$((5 + 2 + pane_height + 1))  # tree(5) + header(1) + panes + separator(1) = start after separator
                watch_render_footer "$footer_row" "$t_frame_start"
                return
            fi
            _NO_AGENTS_DIRTY=0

            # Set terminal title
            printf '\e]0;ib watch: no agents\a'

            # Tree area: show "No agents running" message (5 lines reserved for tree)
            printf '\e[1;1H'
            printf '\e[2m%-*s\e[0m\n' "$TERM_COLS" "No agents running. Press 'a' to create one."
            local line
            for ((line=2; line<=5; line++)); do
                printf '%-*s\n' "$TERM_COLS" ""
            done

            # Calculate pane dimensions
            local pane_height=$((TERM_LINES - 5 - 4))  # 5 tree lines + header + separator + 2 footer
            local left_pane_width=$TMUX_WIDTH
            local right_pane_width=$((TERM_COLS - TMUX_WIDTH - 3))

            # Pane header with box-drawing characters dim but titles white
            local left_title="(no agent)"
            local right_title="AGENT LOG"
            local left_pad_count=$((left_pane_width - 3 - ${#left_title} - 1))
            local right_pad_count=$((right_pane_width - 3 - ${#right_title} - 1))
            [[ $left_pad_count -lt 0 ]] && left_pad_count=0
            [[ $right_pad_count -lt 0 ]] && right_pad_count=0
            local left_pad="" right_pad=""
            local i
            for ((i=0; i<left_pad_count; i++)); do left_pad="${left_pad}─"; done
            for ((i=0; i<right_pad_count; i++)); do right_pad="${right_pad}─"; done
            printf '%s── %s%s%s %s─┬─── %s%s%s %s%s\n' \
                "$COLOR_DIM" "$COLOR_RESET" "$left_title" "$COLOR_DIM" "$left_pad" \
                "$COLOR_RESET" "$right_title" "$COLOR_DIM" "$right_pad" "$COLOR_RESET"

            # Blank panes with dim separator (only │ is dim)
            local pane_line
            for ((pane_line=0; pane_line<pane_height; pane_line++)); do
                printf '%-*s %s│%s %-*s\n' "$left_pane_width" "" "$COLOR_DIM" "$COLOR_RESET" "$right_pane_width" ""
            done

            # Bottom separator with ─ characters (dim)
            local left_sep="" right_sep=""
            local i
            for ((i=0; i<left_pane_width; i++)); do left_sep="${left_sep}─"; done
            for ((i=0; i<right_pane_width; i++)); do right_sep="${right_sep}─"; done
            printf '%s%s─┴─%s%s' "$COLOR_DIM" "$left_sep" "$right_sep" "$COLOR_RESET"

            # Footer
            local footer_row=$((5 + 2 + pane_height + 1))  # tree(5) + header(1) + panes + separator(1) = start after separator
            watch_render_footer "$footer_row" "$t_frame_start"

            return  # tmpfile cleanup handled by RETURN trap
        fi
        # Agents exist - clear the no-agents dirty flag for next time
        _NO_AGENTS_DIRTY=1

        # Render tree and get selected agent (skip for full-width modes)
        local t_tree_start t_tree_end
        [[ $DEBUG_MODE -eq 1 ]] && t_tree_start=$(get_ms)
        if [[ $RIGHT_PANE_MODE -eq 2 || $RIGHT_PANE_MODE -eq 5 ]]; then
            # Denials/Diff mode: skip tree rendering, set tree_display_lines to 0
            # Still need to process agent list for state tracking
            local agent_ids=()
            local line
            while IFS= read -r line; do
                agent_ids+=("${line%%|*}")
            done < "$tmpfile"
            AGENT_COUNT=${#agent_ids[@]}
            _WATCH_SELECTED_ID="${agent_ids[$SELECTED_INDEX]:-}"
            _WATCH_TREE_DISPLAY_LINES=0
        else
            watch_render_tree "$tmpfile"
        fi
        [[ $DEBUG_MODE -eq 1 ]] && { t_tree_end=$(get_ms); _debug_timing_record "render_tree" $((t_tree_end - t_tree_start)); }
        local selected_id="$_WATCH_SELECTED_ID"
        local tree_display_lines="$_WATCH_TREE_DISPLAY_LINES"

        # Render split panes (tmux output + agent log)
        local t_panes_start t_panes_end
        [[ $DEBUG_MODE -eq 1 ]] && t_panes_start=$(get_ms)
        watch_render_split_panes "$selected_id" "$tree_display_lines" "$tmpfile"
        [[ $DEBUG_MODE -eq 1 ]] && { t_panes_end=$(get_ms); _debug_timing_record "render_split_panes" $((t_panes_end - t_panes_start)); }

        # Render footer (after panes + separator line)
        local t_footer_start t_footer_end
        [[ $DEBUG_MODE -eq 1 ]] && t_footer_start=$(get_ms)
        local footer_row=$((_WATCH_PANE_START_ROW + _WATCH_PANE_HEIGHT + 1))
        watch_render_footer "$footer_row" "$t_frame_start"
        [[ $DEBUG_MODE -eq 1 ]] && { t_footer_end=$(get_ms); _debug_timing_record "render_footer" $((t_footer_end - t_footer_start)); }
        # tmpfile cleanup handled by RETURN trap
    }

    # Process a single key
    watch_process_key() {
        local key="$1"

        # If a dialog is active, route to dialog-specific key handler
        if [[ $DIALOG_MODE -ne 0 ]]; then
            case $DIALOG_MODE in
                1) watch_dialog_key_send "$key" ;;
                2) watch_dialog_key_kill "$key" ;;
                3) watch_dialog_key_nuke "$key" ;;
                4) watch_dialog_key_new_agent "$key" ;;
                5) watch_dialog_key_jump "$key" ;;
                6) watch_dialog_key_hooks "$key" ;;
                7) watch_dialog_key_merge "$key" ;;
            esac
            return
        fi

        # Time filter toggle (only in denials mode)
        if [[ "$key" == "t" && $RIGHT_PANE_MODE -eq 2 ]]; then
            # Cycle through time filters: 0 → 1 → 2 → 0
            DENIALS_TIME_FILTER=$(( (DENIALS_TIME_FILTER + 1) % 3 ))
            # Restart collector with new filter
            start_denials_collector
            # Reset scroll to bottom
            SCROLL_OFFSET=0
            return
        fi

        # Normal mode key handling
        case "$key" in
            $'\e')  # Escape - start of arrow key sequence
                _WATCH_ESC_PENDING=1
                ;;
            '[')  # Part of escape sequence
                if [[ "$_WATCH_ESC_PENDING" == "1" ]]; then
                    _WATCH_ESC_PENDING=2
                fi
                ;;
            'A')  # Up arrow (when part of escape sequence)
                if [[ "$_WATCH_ESC_PENDING" == "2" ]]; then
                    # Up arrow = same as k (move selection up)
                    if [[ $AGENT_COUNT -gt 0 ]]; then
                        SELECTED_INDEX=$(( (SELECTED_INDEX - 1 + AGENT_COUNT) % AGENT_COUNT ))
                        SELECTED_NAME=""
                    fi
                    _WATCH_ESC_PENDING=0
                fi
                ;;
            'B')  # Down arrow (when part of escape sequence)
                if [[ "$_WATCH_ESC_PENDING" == "2" ]]; then
                    # Down arrow = same as j (move selection down)
                    if [[ $AGENT_COUNT -gt 0 ]]; then
                        SELECTED_INDEX=$(( (SELECTED_INDEX + 1) % AGENT_COUNT ))
                        SELECTED_NAME=""
                    fi
                    _WATCH_ESC_PENDING=0
                fi
                ;;
            'C')  # Right arrow (when part of escape sequence)
                if [[ "$_WATCH_ESC_PENDING" == "2" ]]; then
                    # Right arrow = same as n (previous pane, skip errors if empty)
                    watch_calc_next_pane -1
                    watch_set_pane_mode $_NEXT_PANE_MODE "$_WATCH_SELECTED_ID"
                    SCROLL_OFFSET=0
                    _WATCH_ESC_PENDING=0
                fi
                ;;
            'D')  # Left arrow (when part of escape sequence)
                if [[ "$_WATCH_ESC_PENDING" == "2" ]]; then
                    # Left arrow = same as p (next pane, skip errors if empty)
                    watch_calc_next_pane 1
                    watch_set_pane_mode $_NEXT_PANE_MODE "$_WATCH_SELECTED_ID"
                    SCROLL_OFFSET=0
                    _WATCH_ESC_PENDING=0
                fi
                ;;
            j)
                _WATCH_ESC_PENDING=0
                # Move selection down
                if [[ $AGENT_COUNT -gt 0 ]]; then
                    SELECTED_INDEX=$(( (SELECTED_INDEX + 1) % AGENT_COUNT ))
                    SELECTED_NAME=""  # Clear so render will update from new index
                fi
                ;;
            k)
                _WATCH_ESC_PENDING=0
                # Move selection up
                if [[ $AGENT_COUNT -gt 0 ]]; then
                    SELECTED_INDEX=$(( (SELECTED_INDEX - 1 + AGENT_COUNT) % AGENT_COUNT ))
                    SELECTED_NAME=""  # Clear so render will update from new index
                fi
                ;;
            \;)
                _WATCH_ESC_PENDING=0
                # Scroll down (show older content) - ; key
                SCROLL_OFFSET=$((SCROLL_OFFSET + 10))
                ;;
            l)
                _WATCH_ESC_PENDING=0
                # Scroll up (show newer content, toward bottom)
                SCROLL_OFFSET=$((SCROLL_OFFSET - 10))
                if [[ $SCROLL_OFFSET -lt 0 ]]; then
                    SCROLL_OFFSET=0
                fi
                ;;
            n)
                _WATCH_ESC_PENDING=0
                # Previous right pane mode (skip errors pane if empty)
                watch_calc_next_pane -1
                watch_set_pane_mode $_NEXT_PANE_MODE "$_WATCH_SELECTED_ID"
                SCROLL_OFFSET=0  # Reset scroll on pane change
                ;;
            p)
                _WATCH_ESC_PENDING=0
                # Next right pane mode (skip errors pane if empty)
                watch_calc_next_pane 1
                watch_set_pane_mode $_NEXT_PANE_MODE "$_WATCH_SELECTED_ID"
                SCROLL_OFFSET=0  # Reset scroll on pane change
                ;;
            s)
                _WATCH_ESC_PENDING=0
                # Open Send dialog
                if [[ $AGENT_COUNT -gt 0 ]]; then
                    watch_dialog_init_send
                    DIALOG_MODE=1
                fi
                ;;
            m)
                _WATCH_ESC_PENDING=0
                # Open Merge dialog
                if [[ $AGENT_COUNT -gt 0 ]]; then
                    watch_dialog_init_merge
                    DIALOG_MODE=7
                fi
                ;;
            x)
                _WATCH_ESC_PENDING=0
                # Open Kill dialog
                if [[ $AGENT_COUNT -gt 0 ]]; then
                    watch_dialog_init_kill
                    DIALOG_MODE=2
                fi
                ;;
            !)
                _WATCH_ESC_PENDING=0
                # Open Nuke dialog
                watch_dialog_init_nuke
                DIALOG_MODE=3
                ;;
            a)
                _WATCH_ESC_PENDING=0
                # Open New Agent dialog
                watch_dialog_init_new_agent
                DIALOG_MODE=4
                ;;
            /)
                _WATCH_ESC_PENDING=0
                # Open Jump dialog
                if [[ $AGENT_COUNT -gt 0 ]]; then
                    watch_dialog_init_jump
                    DIALOG_MODE=5
                fi
                ;;
            e)
                _WATCH_ESC_PENDING=0
                # Switch to errors pane
                watch_set_pane_mode 4
                SCROLL_OFFSET=0
                ;;
            d)
                _WATCH_ESC_PENDING=0
                # Switch to diff pane
                watch_set_pane_mode 5 "$_WATCH_SELECTED_ID"
                SCROLL_OFFSET=0
                ;;
            c)
                _WATCH_ESC_PENDING=0
                # Clear all errors (only when in errors pane)
                if [[ $RIGHT_PANE_MODE -eq 4 ]]; then
                    watch_clear_errors
                fi
                ;;
            h)
                _WATCH_ESC_PENDING=0
                # Open Setup dialog
                watch_dialog_init_setup
                DIALOG_MODE=6
                ;;
            *)
                _WATCH_ESC_PENDING=0
                ;;
        esac
    }

    # Start persistent background key reader (skip in debug mode - no TTY input needed)
    local keyfile=$(mktemp)
    local reader_pid=""
    if [[ $DEBUG_MODE -eq 0 ]]; then
        (
            set +e  # Disable exit-on-error in subshell
            exec < /dev/tty 2>/dev/null
            while true; do
                # Read one character; Enter produces empty $k but successful read
                # Redirect stderr to suppress I/O error messages
                if ! IFS= read -rsn1 k 2>/dev/null; then
                    # Read failed (I/O error or EOF) - exit cleanly
                    break
                fi
                if [[ -z "$k" ]]; then
                    # Empty means Enter was pressed - use record separator (0x1E) as marker
                    printf '\x1e' >> "$keyfile"
                else
                    printf "%s" "$k" >> "$keyfile"
                fi
            done
        ) &
        reader_pid=$!
    fi

    # Start background session monitor (refreshes tmux session list AND captures pane output)
    local sessionfile=$(mktemp)
    local tmux_cache_dir=$(mktemp -d)
    local log_cache_dir=$(mktemp -d)
    local log_width_file=$(mktemp)
    local heartbeat_file=$(mktemp)
    local errors_file=$(mktemp)
    echo "80" > "$log_width_file"  # Default width
    SESSIONS_FILE="$sessionfile"  # Global for build_agent_data_file to read
    TMUX_CACHE_DIR="$tmux_cache_dir"  # Global for reading cached tmux output
    LOG_CACHE_DIR="$log_cache_dir"  # Global for reading cached wrapped logs
    LOG_WIDTH_FILE="$log_width_file"  # Global for main loop to update wrap width
    HEARTBEAT_FILE="$heartbeat_file"  # Global for health monitoring
    ERRORS_FILE="$errors_file"  # Global for async error reporting
    (
        local agents_dir="$PWD/.ittybitty/agents"
        local hb_file="$heartbeat_file"
        while true; do
            # Update heartbeat timestamp
            date +%s > "$hb_file"
            # Get session list
            local sessions
            sessions=$(tmux list-sessions -F '#{session_name}' 2>/dev/null) || true
            printf '%s' "${sessions//$'\n'/|}" > "$sessionfile"

            # Capture pane output for each agent (iterate by agent directory, not session prefix)
            # This ensures consistency with session_name() which reads from meta.json
            for agent_dir in "$agents_dir"/*/; do
                [[ -d "$agent_dir" ]] || continue
                [[ -f "$agent_dir/meta.json" ]] || continue
                local agent_id="${agent_dir%/}"
                agent_id="${agent_id##*/}"
                # Read tmux_session from meta.json (same source as session_name())
                local tmux_session
                tmux_session=$(grep -o '"tmux_session"[[:space:]]*:[[:space:]]*"[^"]*"' "$agent_dir/meta.json" 2>/dev/null | sed 's/.*: *"\([^"]*\)".*/\1/')
                [[ -z "$tmux_session" ]] && continue
                # Only capture if session exists in current sessions list
                [[ "$sessions" == *"$tmux_session"* ]] || continue
                # Capture and strip ANSI codes using _strip_ansi (same as capture_tmux)
                local raw_capture
                raw_capture=$(tmux capture-pane -t "$tmux_session" -p -S -500 2>/dev/null) || true
                if [[ -n "$raw_capture" ]]; then
                    _strip_ansi "$raw_capture"
                    printf '%s' "$_STRIP_ANSI_RESULT" > "$tmux_cache_dir/$agent_id.tmp" && \
                        mv "$tmux_cache_dir/$agent_id.tmp" "$tmux_cache_dir/$agent_id" 2>/dev/null || true
                fi
            done

            # Cache wrapped log files for each agent
            local wrap_width
            read -r wrap_width < "$log_width_file" 2>/dev/null || wrap_width=80
            for agent_dir in "$agents_dir"/*/; do
                [[ -d "$agent_dir" ]] || continue
                local agent_id="${agent_dir%/}"
                agent_id="${agent_id##*/}"
                local log_file="$agent_dir/agent.log"
                if [[ -f "$log_file" ]]; then
                    # Read last 200 lines, wrap to width, write to cache
                    tail -n 200 "$log_file" 2>/dev/null | fold -w "$wrap_width" > "$log_cache_dir/$agent_id.tmp" && \
                        mv "$log_cache_dir/$agent_id.tmp" "$log_cache_dir/$agent_id" 2>/dev/null || true
                fi
            done

            sleep 0.15
        done
    ) &
    local session_monitor_pid=$!

    # Cleanup reader and session monitor on exit
    watch_cleanup_reader() {
        [[ -n "$reader_pid" ]] && kill $reader_pid 2>/dev/null
        kill $session_monitor_pid 2>/dev/null
        rm -f "$keyfile" "$sessionfile" "$log_width_file" "$heartbeat_file" "$errors_file"
        rm -rf "$tmux_cache_dir" "$log_cache_dir"
        SESSIONS_FILE=""
        TMUX_CACHE_DIR=""
        LOG_CACHE_DIR=""
        LOG_WIDTH_FILE=""
        HEARTBEAT_FILE=""
        ERRORS_FILE=""
    }
    trap 'watch_cleanup_reader; watch_cleanup' EXIT
    trap 'exit 0' INT  # Ensure Ctrl+C triggers EXIT trap

    # Main loop
    while true; do
        local frame_start_ms=$(get_ms)

        # Load any new errors from background processes
        watch_load_errors_from_file

        # Track dialog state for dirty detection at end of frame
        local prev_dialog_mode=$DIALOG_MODE

        # Render frame (dialog or normal)
        if [[ $DIALOG_MODE -ne 0 ]]; then
            set +e  # Disable exit-on-error for dialog rendering
            case $DIALOG_MODE in
                1) watch_dialog_render_send ;;
                2) watch_dialog_render_kill ;;
                3) watch_dialog_render_nuke ;;
                4) watch_dialog_render_new_agent ;;
                5) watch_dialog_render_jump ;;
                6) watch_dialog_render_hooks ;;
                7) watch_dialog_render_merge ;;
            esac
            set -e
        else
            # In debug mode, suppress TUI output (redirect to /dev/null)
            # but still run all timing code inside watch_render
            if [[ $DEBUG_MODE -eq 1 ]]; then
                watch_render > /dev/null 2>&1
            else
                watch_render
            fi
        fi

        # Record render time (before sleep) for debug mode
        if [[ $DEBUG_MODE -eq 1 ]]; then
            local render_end_ms=$(get_ms)
            _debug_timing_record "total_frame" $((render_end_ms - frame_start_ms))
            DEBUG_FRAME_COUNT=$((DEBUG_FRAME_COUNT + 1))

            # Show progress every 100 frames
            if [[ $((DEBUG_FRAME_COUNT % 100)) -eq 0 ]]; then
                echo "Progress: $DEBUG_FRAME_COUNT / $DEBUG_MAX_FRAMES frames" >&2
            fi

            # Exit after max frames in debug mode
            if [[ $DEBUG_FRAME_COUNT -ge $DEBUG_MAX_FRAMES ]]; then
                debug_print_summary
                exit 0
            fi
        fi

        # Sleep using adaptive sleep time (skip in debug mode and if negative)
        if [[ $DEBUG_MODE -eq 0 && $SLEEP_ADJUST_MS -gt 0 ]]; then
            sleep $(awk "BEGIN {printf \"%.3f\", $SLEEP_ADJUST_MS / 1000}")
        fi

        # Calculate total frame time including sleep
        local frame_end_ms=$(get_ms)
        LAST_FRAME_MS=$((frame_end_ms - frame_start_ms))

        # Feedback loop: adjust sleep based on whether we hit target
        # If frame was too slow (>100ms), reduce sleep
        # If frame was too fast (<100ms), increase sleep
        # Use 0.3 gain factor for gradual adjustment
        local frame_error=$((LAST_FRAME_MS - TARGET_FRAME_MS))
        local adjustment=$((frame_error * 3 / 10))  # 30% of error
        SLEEP_ADJUST_MS=$((SLEEP_ADJUST_MS - adjustment))  # Subtract to correct

        # Collect and clear accumulated keys
        local keys_to_process=""
        if [[ -s "$keyfile" ]]; then
            keys_to_process=$(cat "$keyfile")
            : > "$keyfile"  # Clear for next frame
        fi

        # Process all accumulated keys
        set +e  # Disable exit-on-error for key processing
        local i
        for ((i=0; i<${#keys_to_process}; i++)); do
            watch_process_key "${keys_to_process:$i:1}"
        done
        set -e

        # If dialog was closed during this frame (via render or key processing),
        # force full screen redraw on next frame to clear dialog remnants
        if [[ $prev_dialog_mode -ne 0 && $DIALOG_MODE -eq 0 ]]; then
            _NO_AGENTS_DIRTY=1
        fi
    done
}

# =============================================================================
# COMMAND: config
# =============================================================================

cmd_config() {
    local SUBCOMMAND="${1:-}"
    shift || true

    case "$SUBCOMMAND" in
        get)
            # ib config get <key>
            local KEY="${1:-}"
            if [[ -z "$KEY" ]]; then
                echo "Error: Key required" >&2
                echo "Usage: ib config get <key>" >&2
                exit 1
            fi

            local config_file=".ittybitty.json"
            if [[ ! -f "$config_file" ]]; then
                echo "Error: .ittybitty.json not found" >&2
                exit 1
            fi

            if ! command -v jq &>/dev/null; then
                echo "Error: jq is required for config commands" >&2
                exit 1
            fi

            # Use jq to get the value at the specified key path
            local value
            value=$(jq -r ".$KEY // empty" "$config_file" 2>/dev/null)

            if [[ -z "$value" ]]; then
                echo "Error: Key '$KEY' not found in $config_file" >&2
                exit 1
            fi

            echo "$value"
            ;;

        set)
            # ib config set <key> <value>
            local KEY="${1:-}"
            local VALUE="${2:-}"

            if [[ -z "$KEY" ]]; then
                echo "Error: Key required" >&2
                echo "Usage: ib config set <key> <value>" >&2
                exit 1
            fi

            if [[ -z "$VALUE" ]]; then
                echo "Error: Value required" >&2
                echo "Usage: ib config set <key> <value>" >&2
                exit 1
            fi

            local config_file=".ittybitty.json"

            # Create default config if it doesn't exist
            if [[ ! -f "$config_file" ]]; then
                echo "{}" > "$config_file"
            fi

            if ! command -v jq &>/dev/null; then
                echo "Error: jq is required for config commands" >&2
                exit 1
            fi

            # Validate type for known configuration keys
            case "$KEY" in
                maxAgents|fps)
                    if ! [[ "$VALUE" =~ ^[0-9]+$ ]]; then
                        echo "Error: '$KEY' must be a number, got '$VALUE'" >&2
                        exit 1
                    fi
                    ;;
                createPullRequests)
                    if [[ "$VALUE" != "true" && "$VALUE" != "false" ]]; then
                        echo "Error: '$KEY' must be true or false, got '$VALUE'" >&2
                        exit 1
                    fi
                    ;;
                model)
                    if [[ "$VALUE" != "sonnet" && "$VALUE" != "opus" && "$VALUE" != "haiku" ]]; then
                        echo "Error: '$KEY' must be one of: sonnet, opus, haiku" >&2
                        exit 1
                    fi
                    ;;
                permissions.*.allow|permissions.*.deny)
                    if ! [[ "$VALUE" == "["* && "$VALUE" == *"]" ]]; then
                        echo "Error: '$KEY' must be a JSON array, got '$VALUE'" >&2
                        exit 1
                    fi
                    ;;
            esac

            # Determine if value is a number, boolean, array, or string
            local json_value
            if [[ "$VALUE" =~ ^[0-9]+$ ]]; then
                # Integer
                json_value="$VALUE"
            elif [[ "$VALUE" == "true" || "$VALUE" == "false" ]]; then
                # Boolean
                json_value="$VALUE"
            elif [[ "$VALUE" == "["* && "$VALUE" == *"]" ]]; then
                # Array (assume it's valid JSON)
                json_value="$VALUE"
            elif [[ "$VALUE" == "{"* && "$VALUE" == *"}" ]]; then
                # Object (assume it's valid JSON)
                json_value="$VALUE"
            else
                # String - needs quoting
                json_value="\"$VALUE\""
            fi

            # Use jq to set the value at the specified key path
            local tmpfile=$(mktemp)
            if jq ".$KEY = $json_value" "$config_file" > "$tmpfile" 2>/dev/null; then
                mv "$tmpfile" "$config_file"
                echo "Set $KEY = $VALUE"
            else
                rm -f "$tmpfile"
                echo "Error: Failed to set key '$KEY' to value '$VALUE'" >&2
                exit 1
            fi
            ;;

        -h|--help|help|"")
            cat <<EOF
Usage: ib config <subcommand> [options]

Subcommands:
  get <key>         Get a configuration value from .ittybitty.json
  set <key> <value> Set a configuration value in .ittybitty.json

Examples:
  ib config get model
  ib config get permissions.manager.allow
  ib config set model "sonnet"
  ib config set maxAgents 20
  ib config set fps 15
  ib config set permissions.worker.allow '["Read", "Write"]'

Key Paths:
  Use dot notation to access nested keys (e.g., permissions.manager.allow)

Value Types:
  - Numbers: Integers are stored as numbers (e.g., 10)
  - Booleans: true/false are stored as booleans
  - Strings: Other values are stored as quoted strings
  - Arrays/Objects: JSON arrays/objects (must be valid JSON)
EOF
            exit 0
            ;;

        *)
            echo "Error: Unknown subcommand '$SUBCOMMAND'" >&2
            echo "Usage: ib config {get|set} [options]" >&2
            echo "Run 'ib config --help' for more information" >&2
            exit 1
            ;;
    esac
}

# =============================================================================
# MAIN DISPATCH
# =============================================================================

# Initialize paths to use root repo (handles running from worktrees)
init_paths

# Enforce command access restrictions based on execution context
# Pass command and subcommand (for hooks install/uninstall detection)
enforce_command_access "${1:-help}" "${2:-}"

case "${1:-help}" in
    new-agent|new)
        shift
        cmd_new_agent "$@"
        ;;
    list|ls)
        shift
        cmd_list "$@"
        ;;
    tree)
        shift
        cmd_tree "$@"
        ;;
    watch)
        shift
        cmd_watch "$@"
        ;;
    status)
        shift
        cmd_status "$@"
        ;;
    diff)
        shift
        cmd_diff "$@"
        ;;
    info)
        shift
        cmd_info "$@"
        ;;
    merge)
        shift
        cmd_merge "$@"
        ;;
    merge-check)
        shift
        cmd_merge_check "$@"
        ;;
    send)
        shift
        cmd_send "$@"
        ;;
    look)
        shift
        cmd_look "$@"
        ;;
    kill)
        shift
        cmd_kill "$@"
        ;;
    nuke)
        shift
        cmd_nuke "$@"
        ;;
    resume)
        shift
        cmd_resume "$@"
        ;;
    hooks)
        shift
        cmd_hooks "$@"
        ;;
    hook-status)
        # Backward compatibility alias
        shift
        cmd_hooks_agent_status "$@"
        ;;
    hook-check-path)
        # Backward compatibility alias
        shift
        cmd_hooks_agent_path "$@"
        ;;
    parse-state)
        shift
        cmd_parse_state "$@"
        ;;
    test-tool-match)
        shift
        cmd_test_tool_match "$@"
        ;;
    test-pretooluse)
        shift
        cmd_test_pretooluse "$@"
        ;;
    test-validate-meta)
        shift
        cmd_test_validate_meta "$@"
        ;;
    test-format-age)
        shift
        cmd_test_format_age "$@"
        ;;
    test-tool-allowed)
        shift
        cmd_test_tool_allowed "$@"
        ;;
    test-build-settings)
        shift
        cmd_test_build_settings "$@"
        ;;
    test-load-config)
        shift
        cmd_test_load_config "$@"
        ;;
    test-resolve-id)
        shift
        cmd_test_resolve_id "$@"
        ;;
    test-relationships)
        shift
        cmd_test_relationships "$@"
        ;;
    test-log-format)
        shift
        cmd_test_log_format "$@"
        ;;
    test-parse-denial)
        shift
        cmd_test_parse_denial "$@"
        ;;
    test-setup-check)
        shift
        cmd_test_setup_check "$@"
        ;;
    test-gitignore-filter)
        shift
        cmd_test_gitignore_filter "$@"
        ;;
    test-main-path)
        shift
        cmd_test_main_path "$@"
        ;;
    test-enforce-access)
        shift
        cmd_test_enforce_access "$@"
        ;;
    test-agent-worktree)
        # Test if a path matches the agent worktree pattern
        # Usage: ib test-agent-worktree PATH
        # Returns: "true" or "false"
        shift
        if [[ -z "${1:-}" ]]; then
            echo "Usage: ib test-agent-worktree PATH" >&2
            exit 1
        fi
        if is_in_agent_worktree "$1"; then
            echo "true"
        else
            echo "false"
        fi
        ;;
    is-in-agent-worktree)
        # Check if current directory is inside an agent worktree
        # Usage: ib is-in-agent-worktree
        # Exit code: 0 if in agent worktree, 1 if not
        if is_in_agent_worktree; then
            exit 0
        else
            exit 1
        fi
        ;;
    is-in-main-repo)
        # Check if current directory is in the main repo (not an agent worktree)
        # Usage: ib is-in-main-repo
        # Exit code: 0 if in main repo, 1 if in agent worktree or elsewhere
        if is_in_agent_worktree; then
            exit 1
        else
            exit 0
        fi
        ;;
    log)
        shift
        cmd_log "$@"
        ;;
    ask)
        shift
        cmd_ask "$@"
        ;;
    acknowledge|ack)
        shift
        cmd_acknowledge "$@"
        ;;
    questions)
        shift
        cmd_questions "$@"
        ;;
    watchdog)
        shift
        cmd_watchdog "$@"
        ;;
    config)
        shift
        cmd_config "$@"
        ;;
    refresh-status)
        # Undocumented: refresh the <ittybitty-status> block in CLAUDE.md
        shift
        update_claude_status
        ;;
    help|--help|-h)
        SHOW_UNDOCUMENTED=false
        if [[ "$2" == "--undocumented" || "$2" == "-u" ]]; then
            SHOW_UNDOCUMENTED=true
        fi

        cat <<EOF
ib (ittybitty) - multi-agent orchestration for Claude Code

Usage: ib <command> [options]

Agent Lifecycle:
  new-agent     Start a new agent with a prompt
  resume        Restart a stopped agent's session
  kill          Close an agent without merging
  merge         Merge agent's work and close the agent
  merge-check   Check if a merge would succeed (no conflicts)

Monitoring:
  list        Show all agents and their state
  tree        Show agents in a tree structure
  watch       Interactive dashboard for monitoring agents
  look        View an agent's recent output
  status      Show agent's git commits and changes
  diff        Show full diff of agent's work vs main
  info        Show agent's meta.json configuration

Communication:
  send        Send input to an agent
  ask         Ask the user-level Claude a question (top-level managers only)
  questions   List pending questions from agents
  acknowledge Mark a question as handled (alias: ack)
  watchdog    Monitor agent and notify manager on state changes

Configuration:
  hooks       Manage main repo hooks (status, install, uninstall)
  config      Get or set values in .ittybitty.json

Aliases:
  new         Alias for new-agent
  ls          Alias for list
EOF

        if [[ "$SHOW_UNDOCUMENTED" == true ]]; then
            cat <<EOF

Internal Commands (for scripts/testing):
  nuke            Emergency stop: kill all agents or a manager tree
  log             Write timestamped message to agent's log file
  parse-state     Parse agent state from tmux output (for testing)
  refresh-status  Update <ittybitty-status> block in CLAUDE.md

Deprecated Aliases:
  hook-status     Use 'ib hooks agent-status' instead
  hook-check-path Use 'ib hooks agent-path' instead
EOF
        fi

        cat <<EOF

Environment:
  ITTYBITTY_DIR   Base directory for data (default: .ittybitty)

Configuration:
  .ittybitty.json   Agent permissions (see 'ib new-agent --help')

Run 'ib <command> --help' for command-specific help.

Examples:
  ib new-agent "refactor the auth module"    # Spawn an agent
  ib watch                                   # Monitor all agents
  ib look abc123                             # View agent output
  ib send abc123 "yes, proceed"              # Send input
  ib diff abc123                             # Review changes
  ib merge abc123                            # Merge and close
EOF
        ;;
    *)
        echo "Unknown command: $1" >&2
        echo "Run 'ib help' for usage." >&2
        exit 1
        ;;
esac

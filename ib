#!/bin/bash
# ib (ittybitty) - multi-agent orchestration for Claude Code
# Usage: ib <command> [options]
#
# A minimal tool for spawning and managing multiple Claude Code agents
# using tmux sessions and git worktrees.

set -e

ITTYBITTY_DIR="${ITTYBITTY_DIR:-.ittybitty}"
SESSION_PREFIX="ittybitty-"

# Initialize paths - will be set to root repo after get_root_repo is defined
AGENTS_DIR=""
ARCHIVE_DIR=""
ROOT_REPO_PATH=""

# Convert agent ID to tmux session name
session_name() {
    echo "${SESSION_PREFIX}$1"
}

# =============================================================================
# HELPERS
# =============================================================================

# Archive an agent's output before cleanup
# Creates .ittybitty/archive/YYYYMMDD-HHMMSS-<agent-id>.txt
archive_agent_output() {
    local ID="$1"
    local AGENT_DIR="$AGENTS_DIR/$ID"

    # Capture final output if session is still running
    local SESSION=$(session_name "$ID")
    if tmux has-session -t "$SESSION" 2>/dev/null; then
        tmux capture-pane -t "$SESSION" -p -S - > "$AGENT_DIR/output.log" 2>/dev/null || true
    fi

    # Archive output.log if it exists
    if [[ -f "$AGENT_DIR/output.log" ]]; then
        mkdir -p "$ARCHIVE_DIR"
        local timestamp=$(date +%Y%m%d-%H%M%S)
        local archive_file="$ARCHIVE_DIR/${timestamp}-${ID}.txt"
        mv "$AGENT_DIR/output.log" "$archive_file"
        echo "Archived output to: $archive_file"
    fi
}

# Load config from .ittybitty.json if it exists
# Sets global variables: CONFIG_TASK_ALLOW, CONFIG_TASK_DENY, CONFIG_LEAF_ALLOW, CONFIG_LEAF_DENY, CONFIG_CREATE_PRS
load_config() {
    CONFIG_TASK_ALLOW=""
    CONFIG_TASK_DENY=""
    CONFIG_LEAF_ALLOW=""
    CONFIG_LEAF_DENY=""
    CONFIG_CREATE_PRS="false"

    local config_file=".ittybitty.json"
    if [[ ! -f "$config_file" ]]; then
        return 0
    fi

    if ! command -v jq &>/dev/null; then
        echo "Warning: jq not available, cannot read $config_file" >&2
        return 0
    fi

    # Read task permissions
    CONFIG_TASK_ALLOW=$(jq -r '.permissions.task.allow // [] | @json' "$config_file" 2>/dev/null)
    CONFIG_TASK_DENY=$(jq -r '.permissions.task.deny // [] | @json' "$config_file" 2>/dev/null)

    # Read leaf permissions
    CONFIG_LEAF_ALLOW=$(jq -r '.permissions.leaf.allow // [] | @json' "$config_file" 2>/dev/null)
    CONFIG_LEAF_DENY=$(jq -r '.permissions.leaf.deny // [] | @json' "$config_file" 2>/dev/null)

    # Read PR creation setting
    CONFIG_CREATE_PRS=$(jq -r '.createPullRequests // false' "$config_file" 2>/dev/null)
}

# Build settings.local.json content for an agent worktree
# Args: $1 = "task" or "leaf"
build_agent_settings() {
    local agent_type="$1"
    local base_settings="{}"

    # Start with existing settings if available
    if [[ -f ".claude/settings.local.json" ]]; then
        base_settings=$(cat ".claude/settings.local.json")
    fi

    # Load config
    load_config

    # Determine which permissions to use
    local allow_json="[]"
    local deny_json="[]"

    if [[ "$agent_type" == "leaf" && "$CONFIG_LEAF_ALLOW" != "[]" && "$CONFIG_LEAF_ALLOW" != "" ]]; then
        allow_json="$CONFIG_LEAF_ALLOW"
        deny_json="${CONFIG_LEAF_DENY:-[]}"
    elif [[ "$CONFIG_TASK_ALLOW" != "[]" && "$CONFIG_TASK_ALLOW" != "" ]]; then
        allow_json="$CONFIG_TASK_ALLOW"
        deny_json="${CONFIG_TASK_DENY:-[]}"
    fi

    # Always include ib and git permissions
    # Git commands are safe in worktrees: agents can't switch branches or push
    local ib_perms='["Bash(ib:*)", "Bash(./ib:*)", "Bash(git status:*)", "Bash(git add:*)", "Bash(git commit:*)", "Bash(git diff:*)", "Bash(git show:*)", "Bash(git log:*)", "Bash(git ls-files:*)", "Bash(git grep:*)"]'

    # Merge everything together and add Stop hook
    echo "$base_settings" | jq --argjson ib "$ib_perms" \
        --argjson cfg_allow "$allow_json" \
        --argjson cfg_deny "$deny_json" '
        .permissions.allow = ((.permissions.allow // []) + $ib + $cfg_allow | unique) |
        .permissions.deny = ((.permissions.deny // []) + $cfg_deny | unique) |
        .hooks.Stop = [{
            "hooks": [{
                "type": "command",
                "command": "ib",
                "args": ["hook-status", "__AGENT_ID__"]
            }]
        }]
    '
}

# Resolve a partial agent ID to a full ID
# Returns the full ID if exactly one match, errors otherwise
resolve_agent_id() {
    local partial="$1"
    local matches=()

    # Check for exact match first (tmux session or directory)
    if tmux has-session -t "$(session_name "$partial")" 2>/dev/null || [[ -d "$AGENTS_DIR/$partial" ]]; then
        echo "$partial"
        return 0
    fi

    # Look for partial matches in agent directories
    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        local id=$(basename "$agent_dir")
        if [[ "$id" == *"$partial"* ]]; then
            matches+=("$id")
        fi
    done

    # Also check tmux sessions that might not have directories
    while IFS= read -r session; do
        if [[ "$session" == *"$partial"* ]] && [[ ! " ${matches[*]} " =~ " $session " ]]; then
            matches+=("$session")
        fi
    done < <(tmux list-sessions -F '#{session_name}' 2>/dev/null | grep -E '^agent-')

    case ${#matches[@]} in
        0)
            echo "Error: no agent matching '$partial'" >&2
            return 1
            ;;
        1)
            echo "${matches[0]}"
            return 0
            ;;
        *)
            echo "Error: '$partial' matches multiple agents:" >&2
            printf "  %s\n" "${matches[@]}" >&2
            return 1
            ;;
    esac
}

# Check that we're in a git repo at its root directory
require_git_root() {
    # Check if in a git repo
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "Error: must be run from within a git repository" >&2
        exit 1
    fi

    # Check if at repo root
    local git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    local cwd=$(pwd)
    if [[ "$cwd" != "$git_root" ]]; then
        echo "Error: must be run from git repository root" >&2
        echo "  Current directory: $cwd" >&2
        echo "  Repository root:   $git_root" >&2
        exit 1
    fi
}

# Find the root repository path (the original repo, not a worktree)
# If running from within a worktree, returns the main repo root.
# If running from main repo, returns the current location.
get_root_repo() {
    # First check we're in a git repo
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "Error: not in a git repository" >&2
        return 1
    fi

    # Get the common git directory (shared across all worktrees)
    local common_dir=$(git rev-parse --git-common-dir 2>/dev/null)

    if [[ -z "$common_dir" ]]; then
        # Fallback for older git versions
        git rev-parse --show-toplevel
        return 0
    fi

    # If common_dir is relative (like ".git"), we're in the main repo
    if [[ "$common_dir" == ".git" || "$common_dir" == "$(git rev-parse --git-dir)" ]]; then
        git rev-parse --show-toplevel
    else
        # common_dir is absolute path like /path/to/repo/.git
        # Go up one level to get the repo root
        dirname "$common_dir"
    fi
}

# Initialize global paths to use root repo
# Called once when script runs (if in a git repo)
init_paths() {
    if git rev-parse --git-dir >/dev/null 2>&1; then
        ROOT_REPO_PATH=$(get_root_repo)
        AGENTS_DIR="$ROOT_REPO_PATH/$ITTYBITTY_DIR/agents"
        ARCHIVE_DIR="$ROOT_REPO_PATH/$ITTYBITTY_DIR/archive"
    else
        # Not in a git repo - use relative paths as fallback
        AGENTS_DIR="$ITTYBITTY_DIR/agents"
        ARCHIVE_DIR="$ITTYBITTY_DIR/archive"
    fi
}

# Format age from ISO timestamp
format_age() {
    local created="$1"
    local now=$(date +%s)
    # Strip timezone suffix (use % not %% to get shortest match from end)
    local timestamp="${created%[-+]*}"
    local then=$(date -j -f "%Y-%m-%dT%H:%M:%S" "$timestamp" +%s 2>/dev/null || echo "$now")
    local diff=$((now - then))

    if [[ $diff -lt 60 ]]; then
        echo "${diff}s"
    elif [[ $diff -lt 3600 ]]; then
        echo "$((diff / 60))m"
    elif [[ $diff -lt 86400 ]]; then
        echo "$((diff / 3600))h"
    else
        echo "$((diff / 86400))d"
    fi
}

# Detect agent state from tmux
# States: running, waiting, stopped, complete, unknown
get_state() {
    local id="$1"
    local tmux_session=$(session_name "$id")

    if ! tmux has-session -t "$tmux_session" 2>/dev/null; then
        echo "stopped"
        return
    fi

    # Capture visible pane for state detection
    local recent=$(tmux capture-pane -t "$tmux_session" -p -S -20 2>/dev/null)

    # Check for Claude Code processing indicators (running) FIRST
    # These indicate active work even if completion phrase exists in context
    # - "esc to interrupt" appears when Claude is actively generating
    # - "ctrl+b ctrl+b" appears when a bash command is running
    # - "⎿  Running…" appears when bash tool is executing
    if echo "$recent" | grep -qE 'esc to interrupt|ctrl\+b ctrl\+b|⎿  Running'; then
        echo "running"
        return
    fi

    # Check for completion signal (task agents say this when done)
    # Use last 15 lines to see past status bar but avoid matching instructions
    local last_lines=$(echo "$recent" | tail -15)
    if echo "$last_lines" | grep -qF 'I HAVE COMPLETED THE GOAL'; then
        echo "complete"
        return
    fi

    # Check for explicit waiting message
    if echo "$last_lines" | grep -qF 'WAITING'; then
        echo "waiting"
        return
    fi

    # Idle but no explicit state message = unknown
    echo "unknown"
}

# =============================================================================
# COMMAND: new-agent
# =============================================================================

cmd_new_agent() {
    local NAME=""
    local PARENT=""
    local USE_WORKTREE=true
    local ALLOW_TOOLS=""
    local DENY_TOOLS=""
    local PRINT_MODE=false
    local YOLO_MODE=false
    local LEAF_MODE=false
    local MODEL=""
    local PROMPT=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)        NAME="$2"; shift 2 ;;
            --parent)      PARENT="$2"; shift 2 ;;
            --no-worktree) USE_WORKTREE=false; shift ;;
            --allow-tools) ALLOW_TOOLS="$2"; shift 2 ;;
            --deny-tools)  DENY_TOOLS="$2"; shift 2 ;;
            --print)       PRINT_MODE=true; shift ;;
            --yolo)        YOLO_MODE=true; shift ;;
            --leaf|--worker) LEAF_MODE=true; shift ;;
            --model)       MODEL="$2"; shift 2 ;;
            -h|--help)
                cat <<EOF
Usage: ib new-agent [options] "prompt"

Start a new Claude agent with the given prompt.

Must be run from the root of a git repository. By default, each agent gets
its own git worktree and branch for isolated work.

Options:
  --name NAME           Custom agent name (default: auto-generated)
  --parent ID           Parent agent ID (for hierarchy tracking)
  --no-worktree         Work in repo root instead of isolated worktree
  --allow-tools LIST    Only allow these tools (comma-separated)
  --deny-tools LIST     Deny these tools (comma-separated)
  --print               Run in one-shot mode (no interaction)
  --yolo                Skip all permission prompts (full autonomy)
  --leaf, --worker      Create a leaf agent (no sub-agent spawning)
  --model MODEL         Claude model to use (e.g., opus, sonnet, haiku)
  -h, --help            Show this help

Permission modes:
  (default)   Auto-rejects non-allowed tools, auto-accepts workspace trust
  --yolo      Auto-accepts everything (full autonomy, use with caution)

Agent types:
  (default)   Can spawn and manage sub-agents via 'ib' commands
  --leaf      Worker agent - cannot spawn sub-agents, focused on task

Configuration:
  Create .ittybitty.json in your repo root to configure agent permissions:

    {
      "permissions": {
        "task": { "allow": ["Read", "Write", "Edit"], "deny": [] },
        "leaf": { "allow": ["Read", "Write"], "deny": [] }
      }
    }

  - permissions.task: Applied to regular (coordinator) agents
  - permissions.leaf: Applied to leaf/worker agents
  - Bash(ib:*) is always added for agent coordination
  - Base settings from .claude/settings.local.json are merged in

Examples:
  ib new-agent "verify citations in vs-freeform.md"
  ib new-agent --name checker "research and summarize"
  ib new --yolo "research and update the pricing page"
  ib new --leaf --parent coordinator "check link #1"
  ib new --model sonnet "quick task for a faster model"
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                PROMPT="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$PROMPT" ]]; then
        echo "Error: prompt required" >&2
        echo "Usage: ib new-agent [options] \"prompt\"" >&2
        exit 1
    fi

    # Verify we're in a git repo
    if [[ -z "$ROOT_REPO_PATH" ]]; then
        echo "Error: must be run from within a git repository" >&2
        exit 1
    fi

    # Load config for PR settings
    load_config

    # Generate agent ID
    local ID
    if [[ -n "$NAME" ]]; then
        ID="$NAME"
    else
        ID="agent-$(openssl rand -hex 4)"
    fi

    # Check if agent already exists
    local TMUX_SESSION=$(session_name "$ID")
    if [[ -d "$AGENTS_DIR/$ID" ]] || tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        echo "Error: agent '$ID' already exists" >&2
        exit 1
    fi

    # Set up directories in root repo
    local AGENT_DIR="$AGENTS_DIR/$ID"
    mkdir -p "$AGENT_DIR"

    # Set working directory (default to root repo)
    local WORK_PATH="$ROOT_REPO_PATH"

    # Create git worktree if requested
    if [[ "$USE_WORKTREE" == true ]]; then
        local BRANCH_NAME="agent/$ID"
        # Create worktree from root repo, branching from current HEAD
        git -C "$ROOT_REPO_PATH" worktree add "$AGENT_DIR/repo" -b "$BRANCH_NAME" HEAD || {
            echo "Error: could not create worktree" >&2
            rm -rf "$AGENT_DIR"
            exit 1
        }
        WORK_PATH="$AGENT_DIR/repo"

        # Build agent settings with permissions from .ittybitty.json config
        mkdir -p "$AGENT_DIR/repo/.claude"
        local agent_type="task"
        [[ "$LEAF_MODE" == true ]] && agent_type="leaf"

        if command -v jq &>/dev/null; then
            # Run build_agent_settings from root repo context
            (cd "$ROOT_REPO_PATH" && build_agent_settings "$agent_type") > "$AGENT_DIR/repo/.claude/settings.local.json"
            # Replace agent ID placeholder in hook configuration
            sed -i '' "s|__AGENT_ID__|$ID|g" "$AGENT_DIR/repo/.claude/settings.local.json"
        else
            # Fallback: minimal settings if jq not available
            if [[ -f "$ROOT_REPO_PATH/.claude/settings.local.json" ]]; then
                cp "$ROOT_REPO_PATH/.claude/settings.local.json" "$AGENT_DIR/repo/.claude/"
            else
                echo '{"permissions":{"allow":["Bash(ib:*)","Bash(./ib:*)"]}}' > "$AGENT_DIR/repo/.claude/settings.local.json"
            fi
        fi
    else
        # Non-worktree mode: ensure ib permissions are in root repo settings
        local ROOT_SETTINGS="$ROOT_REPO_PATH/.claude/settings.local.json"
        if command -v jq &>/dev/null && [[ -f "$ROOT_SETTINGS" ]]; then
            # Check if both patterns are already allowed
            local needs_update=false
            if ! jq -e '.permissions.allow | index("Bash(ib:*)")' "$ROOT_SETTINGS" &>/dev/null; then
                needs_update=true
            fi
            if ! jq -e '.permissions.allow | index("Bash(./ib:*)")' "$ROOT_SETTINGS" &>/dev/null; then
                needs_update=true
            fi
            if [[ "$needs_update" == true ]]; then
                local tmp=$(mktemp)
                jq '.permissions.allow += ["Bash(ib:*)", "Bash(./ib:*)"] | .permissions.allow |= unique' \
                    "$ROOT_SETTINGS" > "$tmp" && mv "$tmp" "$ROOT_SETTINGS"
                echo "Added Bash(ib:*) and Bash(./ib:*) to .claude/settings.local.json" >&2
            fi
        elif [[ ! -f "$ROOT_SETTINGS" ]]; then
            mkdir -p "$ROOT_REPO_PATH/.claude"
            echo '{"permissions":{"allow":["Bash(ib:*)","Bash(./ib:*)"]}}' > "$ROOT_SETTINGS"
            echo "Created .claude/settings.local.json with ib allowed" >&2
        fi
    fi

    # Generate a UUID for the Claude session (enables resume if tmux dies)
    local SESSION_UUID=$(uuidgen | tr '[:upper:]' '[:lower:]')

    # Write metadata
    cat > "$AGENT_DIR/meta.json" <<EOF
{
  "id": "$ID",
  "session_id": "$SESSION_UUID",
  "prompt": $(echo "$PROMPT" | jq -Rs .),
  "parent": $(if [[ -n "$PARENT" ]]; then echo "\"$PARENT\""; else echo "null"; fi),
  "created": "$(date -Iseconds)",
  "worktree": $USE_WORKTREE,
  "leaf": $LEAF_MODE,
  "model": $(if [[ -n "$MODEL" ]]; then echo "\"$MODEL\""; else echo "null"; fi)
}
EOF

    # Build prompt with context prefix
    local PARENT_INFO=""
    if [[ -n "$PARENT" ]]; then
        PARENT_INFO="Your parent agent is: $PARENT"
    fi

    local WORKTREE_INFO=""
    local COMPLETION_INSTRUCTIONS=""
    if [[ "$USE_WORKTREE" == true ]]; then
        WORKTREE_INFO="You are running as agent $ID in a git worktree on branch agent/$ID."
        if [[ "$LEAF_MODE" == true ]]; then
            COMPLETION_INSTRUCTIONS="State Management:
- Whenever you stop working and are idle, you must end your message with either:
  - 'WAITING' - if waiting for input or have nothing more to do without further instruction
  - 'I HAVE COMPLETED THE GOAL' - if you have completed your task

When your task is complete:
1. Commit any changes you made (git add && git commit)
2. Say the exact phrase: \"I HAVE COMPLETED THE GOAL\"
   This signals to your parent agent that you are done.
3. Wait for your parent to merge or kill your session."
        else
            # Determine PR instructions based on config and gh availability
            local PR_INSTRUCTIONS=""
            local HAS_GH=$(command -v gh &>/dev/null && echo "true" || echo "false")
            local HAS_REMOTE=$(git remote 2>/dev/null | head -1)

            if [[ "$CONFIG_CREATE_PRS" == "true" && "$HAS_GH" == "true" && -n "$HAS_REMOTE" ]]; then
                PR_INSTRUCTIONS="Once you have completed your primary goal by merging in successful agents, double check that you have completed the goal.
If so:
1. Create a pull request with \`gh pr create --title \"<title>\" --body \"<description>\"\`
2. Say the exact phrase: \"I HAVE COMPLETED THE GOAL\"
This phrase signals to the orchestrator that you are done."
            else
                PR_INSTRUCTIONS="Once you have completed your primary goal by merging in successful agents, double check that you have completed the goal.
If so, say the exact phrase: \"I HAVE COMPLETED THE GOAL\"
This phrase signals to the orchestrator that you are done.
Your work is on branch \`agent/$ID\` for review."
            fi

            COMPLETION_INSTRUCTIONS="State Management:
- Whenever you stop working and are idle, you must end your message with either:
  - 'WAITING' - if waiting for next monitoring cycle or have nothing more to do
  - 'I HAVE COMPLETED THE GOAL' - if you have completed your primary goal

Your workflow:
1. Think through what specific tasks need to be done to accomplish the goal. These tasks should be specific and have clear completion guidelines.
2. Track these tasks in your Claude Code tasks tracker (TodoWrite tool).
3. Spawn a sub-agent for each independent task, providing the specific task and clear completion guidelines.
4. Monitor child tasks every 30s with \`ib list --parent $ID\`
   - If a sub-agent is \`waiting\`, use \`ib look <agent-id>\` to see what it may need. Either send it a message so it can continue working, or if that sub-agent is done, decide if you should merge/kill its session.
   - If a sub-agent is \`complete\`, use \`ib look <agent-id>\` and \`ib diff <agent-id>\` to check its work. If it completed the task correctly, merge or kill it. If it is not actually done, use \`ib send <agent-id> \"message\"\` to tell it what is wrong and how to continue.
   - If a sub-agent is \`stopped\`, its session ended unexpectedly. STOP and notify the user immediately. Tell them which agent stopped and suggest they use \`ib status <agent-id>\` and \`ib diff <agent-id>\` to check its work, then \`ib resume <agent-id>\` to restart it.
   - Sometimes, an agent might get lost or broken and be unable to accomplish the task. It's ok to \`ib kill\` and restart the task with a new agent and clearer task and completion guidelines.
5. When merging successful agents, commit any changes you made directly (git add && git commit).

$PR_INSTRUCTIONS"
        fi
    else
        WORKTREE_INFO="You are running as agent $ID in the main repository (no worktree)."
        COMPLETION_INSTRUCTIONS="When your task is complete:
1. Commit any changes you made (git add && git commit)
2. Exit normally"
    fi

    local IB_INSTRUCTIONS=""
    if [[ "$LEAF_MODE" != true ]]; then
        IB_INSTRUCTIONS="
You have access to the 'ib' tool for multi-agent coordination.
IMPORTANT: Always use 'ib' (not './ib') to ensure you use the current version from PATH.

  ib new-agent --parent $ID --leaf \"task\"   Spawn a leaf sub-agent (focused worker, no sub-agents)
  ib list --parent $ID                        List your sub-agents
  ib look <agent-id>                          Read an agent's output
  ib send <agent-id> \"message\"               Send input to an agent
  ib status <agent-id>                        Check agent's git commits
  ib merge <agent-id>                         Merge agent's work and close it
  ib kill <agent-id>                          Stop an agent without merging

If \`ib merge\` fails due to conflicts, choose the best strategy:
1. Resolve the merge yourself: edit conflicting files, \`git add <files> && git commit\`, then clean up with \`git worktree remove <path> --force && git branch -D agent/<id>\`
2. Spawn a sub-agent to handle the merge resolution, then monitor it to completion
3. If the merge is no longer needed, skip it and note this in your final report
"
    else
        # Leaf agents: simple communication with parent only
        IB_INSTRUCTIONS="
You are a leaf/worker agent focused on your specific task.
IMPORTANT: Always use 'ib' (not './ib') to ensure you use the current version from PATH.

To send a message to your parent: ib send $PARENT \"your message\"

Use this to report completion, ask questions, or share important findings.
"
    fi

    local PROMPT_PREFIX="[AGENT CONTEXT]
$WORKTREE_INFO
$PARENT_INFO
$IB_INSTRUCTIONS
$COMPLETION_INSTRUCTIONS

[USER TASK]
$PROMPT"

    # Save the full prompt (with prefix) for reference
    local PROMPT_FILE="$AGENT_DIR/prompt.txt"
    echo "$PROMPT_PREFIX" > "$PROMPT_FILE"

    # Build claude command arguments
    local CLAUDE_ARGS=""
    if [[ "$YOLO_MODE" == true ]]; then
        CLAUDE_ARGS="--dangerously-skip-permissions --permission-mode bypassPermissions"
    else
        CLAUDE_ARGS="--permission-mode dontAsk"
    fi
    if [[ "$PRINT_MODE" == true ]]; then
        CLAUDE_ARGS="$CLAUDE_ARGS --print"
    fi
    if [[ -n "$ALLOW_TOOLS" ]]; then
        CLAUDE_ARGS="$CLAUDE_ARGS --allowedTools $ALLOW_TOOLS"
    fi
    if [[ -n "$DENY_TOOLS" ]]; then
        CLAUDE_ARGS="$CLAUDE_ARGS --disallowedTools $DENY_TOOLS"
    fi
    if [[ -n "$MODEL" ]]; then
        CLAUDE_ARGS="$CLAUDE_ARGS --model $MODEL"
    fi

    # Build exit handler script
    local EXIT_SCRIPT="$AGENT_DIR/exit-check.sh"
    cat > "$EXIT_SCRIPT" <<'EXITSCRIPT'
#!/bin/bash
echo ""
echo "═══════════════════════════════════════════════════════════"
echo "  Agent session ended - checking for uncommitted work..."
echo "═══════════════════════════════════════════════════════════"

# Check for uncommitted changes
if [[ -n $(git status --porcelain 2>/dev/null) ]]; then
    echo ""
    echo "⚠️  UNCOMMITTED CHANGES DETECTED"
    echo ""
    git status --short
    echo ""
    read -p "Commit these changes? [y/N] " commit_confirm
    if [[ "$commit_confirm" == [yY] || "$commit_confirm" == [yY][eE][sS] ]]; then
        read -p "Commit message: " commit_msg
        if [[ -n "$commit_msg" ]]; then
            git add -A && git commit -m "$commit_msg"
        else
            echo "No message provided, skipping commit."
        fi
    fi
fi

# Check for unpushed commits (only if remote exists)
if git remote | grep -q .; then
    local_commits=$(git log @{u}..HEAD --oneline 2>/dev/null | wc -l | tr -d ' ')
    if [[ "$local_commits" -gt 0 ]]; then
        echo ""
        echo "⚠️  UNPUSHED COMMITS: $local_commits commit(s) not pushed to remote"
        echo ""
        git log @{u}..HEAD --oneline
        echo ""
        read -p "Push to remote? [y/N] " push_confirm
        if [[ "$push_confirm" == [yY] || "$push_confirm" == [yY][eE][sS] ]]; then
            git push
        fi
    fi
fi

echo ""
echo "Agent session complete. Branch: $(git branch --show-current)"
echo "To merge this work: git checkout main && git merge $(git branch --show-current)"
echo ""
EXITSCRIPT
    chmod +x "$EXIT_SCRIPT"

    # Write a startup script that handles the prompt properly
    # Use absolute paths since tmux runs from the worktree directory
    local ABS_AGENT_DIR="$(cd "$AGENT_DIR" && pwd)"
    local ABS_PROMPT_FILE="$ABS_AGENT_DIR/prompt.txt"
    local ABS_EXIT_SCRIPT="$ABS_AGENT_DIR/exit-check.sh"
    local GIT_ROOT="$ROOT_REPO_PATH"  # Root repo path (for PATH so 'ib' is available)
    local STARTUP_SCRIPT="$AGENT_DIR/start.sh"
    cat > "$STARTUP_SCRIPT" <<EOF
#!/bin/bash
# Add git repo root to PATH so 'ib' is available
export PATH="$GIT_ROOT:\$PATH"
claude --session-id "$SESSION_UUID" $CLAUDE_ARGS "\$(cat '$ABS_PROMPT_FILE')"
$ABS_EXIT_SCRIPT
EOF
    chmod +x "$STARTUP_SCRIPT"

    # Ensure tmux server is running (start-server is idempotent)
    if ! tmux start-server 2>/dev/null; then
        echo "Error: could not start tmux server" >&2
        echo "Make sure tmux is installed: brew install tmux" >&2
        rm -rf "$AGENT_DIR"
        if [[ "$USE_WORKTREE" == true ]]; then
            git -C "$ROOT_REPO_PATH" worktree remove "$AGENT_DIR/repo" --force 2>/dev/null || true
            git -C "$ROOT_REPO_PATH" branch -D "$BRANCH_NAME" 2>/dev/null || true
        fi
        exit 1
    fi

    # Start tmux session with startup script (use absolute path)
    local ABS_STARTUP_SCRIPT="$ABS_AGENT_DIR/start.sh"
    if ! tmux new-session -d -s "$TMUX_SESSION" -c "$WORK_PATH" "$ABS_STARTUP_SCRIPT"; then
        echo "Error: could not create tmux session '$TMUX_SESSION'" >&2
        echo "Try running: tmux kill-server && tmux start-server" >&2
        rm -rf "$AGENT_DIR"
        if [[ "$USE_WORKTREE" == true ]]; then
            git -C "$ROOT_REPO_PATH" worktree remove "$AGENT_DIR/repo" --force 2>/dev/null || true
            git -C "$ROOT_REPO_PATH" branch -D "$BRANCH_NAME" 2>/dev/null || true
        fi
        exit 1
    fi

    # Verify session was created
    if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        echo "Error: tmux session '$TMUX_SESSION' failed to start" >&2
        rm -rf "$AGENT_DIR"
        if [[ "$USE_WORKTREE" == true ]]; then
            git -C "$ROOT_REPO_PATH" worktree remove "$AGENT_DIR/repo" --force 2>/dev/null || true
            git -C "$ROOT_REPO_PATH" branch -D "$BRANCH_NAME" 2>/dev/null || true
        fi
        exit 1
    fi

    # For non-yolo mode, auto-accept the workspace trust dialog
    # (yolo bypasses this entirely, but default and strict still see it)
    if [[ "$YOLO_MODE" != true ]]; then
        sleep 2
        tmux send-keys -t "$TMUX_SESSION" Enter
    fi

    # Output the agent ID
    echo "$ID"
}

# =============================================================================
# COMMAND: list
# =============================================================================

cmd_list() {
    local PARENT_FILTER=""
    local JSON_OUTPUT=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --parent)  PARENT_FILTER="$2"; shift 2 ;;
            --json)    JSON_OUTPUT=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib list [options]

Show all agents and their state.

Options:
  --parent ID           Only show children of this agent
  --json                Output as JSON
  -h, --help            Show this help

Output columns:
  ID        Agent identifier
  STATE     running, waiting, complete, or stopped
  AGE       Time since spawn
  PARENT    Parent agent ID (if any)
  PROMPT    First 40 chars of prompt

States:
  running   Agent is actively processing
  waiting   Agent is idle, may need input
  complete  Agent has signaled task completion (merge or kill to close)
  stopped   Session ended unexpectedly, needs user intervention

Orphan Detection:
  This command also checks for orphaned tmux sessions - sessions that exist
  but have no matching agent data. Orphans are shown as warnings.
EOF
                exit 0
                ;;
            *)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
        esac
    done

    # Check if agents directory exists
    if [[ ! -d "$AGENTS_DIR" ]]; then
        if [[ "$JSON_OUTPUT" == true ]]; then
            echo "[]"
        else
            echo "No agents found."
        fi
        exit 0
    fi

    # Collect agent data
    local agents=()
    local found_any=false

    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        [[ -f "$agent_dir/meta.json" ]] || continue

        local id=$(basename "$agent_dir")
        local meta="$agent_dir/meta.json"

        # Read metadata
        local prompt=$(jq -r '.prompt // ""' "$meta" 2>/dev/null | head -1 | cut -c1-40)
        local parent=$(jq -r '.parent // ""' "$meta" 2>/dev/null)
        local created=$(jq -r '.created // ""' "$meta" 2>/dev/null)

        # Filter by parent if requested
        if [[ -n "$PARENT_FILTER" && "$parent" != "$PARENT_FILTER" ]]; then
            continue
        fi

        # Get state
        local state=$(get_state "$id")

        found_any=true

        # Format age
        local age=$(format_age "$created")

        # Handle null parent for display
        [[ "$parent" == "null" ]] && parent="-"

        # Display "unknown" as "waiting" for users
        local display_state="$state"
        [[ "$state" == "unknown" ]] && display_state="waiting"

        if [[ "$JSON_OUTPUT" == true ]]; then
            agents+=("{\"id\":\"$id\",\"state\":\"$state\",\"age\":\"$age\",\"parent\":\"$parent\",\"prompt\":$(echo "$prompt" | jq -Rs .)}")
        else
            printf "%-20s %-10s %-6s %-15s %s\n" "$id" "$display_state" "$age" "$parent" "$prompt"
        fi
    done

    # Check for orphaned tmux sessions (sessions without matching agent directories)
    # Only check sessions with our prefix to avoid warning about unrelated sessions
    local orphans=()
    local known_ids=()

    # Build list of known agent IDs
    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        known_ids+=("$(basename "$agent_dir")")
    done

    # Check our tmux sessions for orphans (only sessions with our prefix)
    while IFS= read -r session; do
        [[ -z "$session" ]] && continue
        # Skip sessions that don't have our prefix
        [[ "$session" != "${SESSION_PREFIX}"* ]] && continue
        # Extract agent ID from session name (strip prefix)
        local agent_id="${session#${SESSION_PREFIX}}"
        # Check if this session has a matching agent directory
        local is_known=false
        for known_id in "${known_ids[@]}"; do
            if [[ "$agent_id" == "$known_id" ]]; then
                is_known=true
                break
            fi
        done
        if [[ "$is_known" == false ]]; then
            orphans+=("$session")
        fi
    done < <(tmux list-sessions -F '#{session_name}' 2>/dev/null || true)

    # Show orphans if any
    if [[ ${#orphans[@]} -gt 0 ]]; then
        if [[ "$JSON_OUTPUT" != true ]]; then
            echo ""
            echo "WARNING: Found ${#orphans[@]} orphaned ib session(s) without agent data:"
            for orphan in "${orphans[@]}"; do
                printf "  %-20s (use 'tmux kill-session -t %s' to remove)\n" "$orphan" "$orphan"
            done
            echo ""
        fi
        found_any=true
    fi

    if [[ "$JSON_OUTPUT" == true ]]; then
        echo "[$(IFS=,; echo "${agents[*]}")]"
    elif [[ "$found_any" != true ]]; then
        echo "No agents found."
    fi
}

# =============================================================================
# COMMAND: send
# =============================================================================

cmd_send() {
    local FROM_ID=""
    local TARGET_ID=""
    local MESSAGE=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --from)
                FROM_ID="$2"
                shift 2
                ;;
            -h|--help)
                cat <<EOF
Usage: ib send <id> "message"
       ib send <id> < file.txt
       echo "answer" | ib send <id>
       ib send --from <sender-id> <id> "message"

Send input to an agent's stdin.

Arguments:
  id          Agent identifier (recipient)
  message     Text to send (optional if piping)

Options:
  --from ID   Prefix message with "[sent by agent <ID>]: " (auto-detected in agent worktrees)
  -h, --help  Show this help

When run from within an agent's worktree, --from is automatically detected by
reading the agent's meta.json, so messages are prefixed with the sender's identity.

Examples:
  ib send task-a1b2 "Option 2 - just verify links"
  ib send task-a1b2 "yes"
  ib send --from worker-xyz parent-abc "I'm done with my task"
  echo "no" | ib send task-a1b2
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$TARGET_ID" ]]; then
                    TARGET_ID="$1"
                else
                    # Rest is the message
                    MESSAGE="$*"
                    break
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$TARGET_ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib send <id> \"message\"" >&2
        exit 1
    fi

    # Resolve partial ID
    local ID
    ID=$(resolve_agent_id "$TARGET_ID") || exit 1

    # Check if agent is running
    local TMUX_SESSION=$(session_name "$ID")
    if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        echo "Error: agent '$ID' is not running" >&2
        exit 1
    fi

    # Get message from remaining args or stdin
    if [[ -z "$MESSAGE" ]]; then
        if [[ ! -t 0 ]]; then
            MESSAGE=$(cat)
        else
            echo "Error: message required (as argument or via stdin)" >&2
            exit 1
        fi
    fi

    # Auto-detect if we're in an agent worktree (FROM_ID not already set)
    if [[ -z "$FROM_ID" ]]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == *"/.agents/"*"/repo"* ]]; then
            # Find the agent directory and read meta.json
            local agent_dir=$(echo "$current_dir" | sed 's|\(.*/.agents/[^/]*\)/repo.*|\1|')
            if [[ -f "$agent_dir/meta.json" ]]; then
                FROM_ID=$(jq -r '.id // ""' "$agent_dir/meta.json" 2>/dev/null)
            fi
        fi
    fi

    # Prefix message if FROM_ID is set (sent by an agent)
    if [[ -n "$FROM_ID" ]]; then
        MESSAGE="[sent by agent $FROM_ID]: $MESSAGE"
    fi

    # Send to tmux session
    # Send message first, then Enter separately with a tiny delay
    # This helps when the target agent is busy processing
    tmux send-keys -t "$TMUX_SESSION" "$MESSAGE"
    sleep 0.1
    tmux send-keys -t "$TMUX_SESSION" Enter

    echo "Sent to $ID"
}

# =============================================================================
# COMMAND: look
# =============================================================================

cmd_look() {
    local ID=""
    local LINES=50
    local FOLLOW=false
    local SHOW_ALL=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --lines)   LINES="$2"; shift 2 ;;
            --all)     SHOW_ALL=true; shift ;;
            --follow)  FOLLOW=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib look <id> [options]

Look at an agent's recent output.

Arguments:
  id              Agent identifier

Options:
  --lines N       Number of lines (default: 50)
  --all           Full scrollback history
  --follow        Watch live (like tail -f)
  -h, --help      Show this help

Examples:
  ib look task-a1b2
  ib look task-a1b2 --lines 200
  ib look task-a1b2 --follow
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib look <id> [options]" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1
    local TMUX_SESSION=$(session_name "$ID")

    # Check if agent session exists
    if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        # Try to read from log if agent is done
        if [[ -f "$AGENTS_DIR/$ID/output.log" ]]; then
            echo "=== Agent finished, showing saved output ===" >&2
            if [[ "$SHOW_ALL" == true ]]; then
                cat "$AGENTS_DIR/$ID/output.log"
            else
                tail -n "$LINES" "$AGENTS_DIR/$ID/output.log"
            fi
            exit 0
        fi
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    if [[ "$FOLLOW" == true ]]; then
        echo "Attaching to $ID (Ctrl+b d to detach)..." >&2
        tmux attach -t "$TMUX_SESSION" -r
    else
        if [[ "$SHOW_ALL" == true ]]; then
            tmux capture-pane -t "$TMUX_SESSION" -p -S -
        else
            tmux capture-pane -t "$TMUX_SESSION" -p -S -"$LINES"
        fi
    fi
}

# =============================================================================
# COMMAND: status
# =============================================================================

cmd_status() {
    local ID=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib status <id>

Show git status of an agent's work compared to main branch.

Displays:
- Commits made by the agent (hash + message)
- Uncommitted changes in worktree
- Files changed summary

Arguments:
  id              Agent identifier

Examples:
  ib status task-a1b2
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib status <id>" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"
    local BRANCH_NAME="agent/$ID"

    # Check if agent exists
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Determine target branch for comparison
    local TARGET_BRANCH=""
    if git show-ref --verify --quiet refs/heads/main; then
        TARGET_BRANCH="main"
    elif git show-ref --verify --quiet refs/heads/master; then
        TARGET_BRANCH="master"
    else
        TARGET_BRANCH="HEAD"
    fi

    # Check if worktree exists
    local WORKTREE_PATH="$AGENT_DIR/repo"
    if [[ ! -d "$WORKTREE_PATH" ]]; then
        echo "Agent '$ID' has no worktree (created with --no-worktree)"
        echo ""
        # Show branch commits if branch exists
        if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
            local commit_count=$(git log "$TARGET_BRANCH..$BRANCH_NAME" --oneline 2>/dev/null | wc -l | tr -d ' ')
            if [[ "$commit_count" -gt 0 ]]; then
                echo "Commits on $BRANCH_NAME (vs $TARGET_BRANCH):"
                git log "$TARGET_BRANCH..$BRANCH_NAME" --oneline
            else
                echo "No commits on $BRANCH_NAME relative to $TARGET_BRANCH"
            fi
        fi
        exit 0
    fi

    echo "Agent: $ID"
    echo "Branch: $BRANCH_NAME"
    echo "Worktree: $WORKTREE_PATH"
    echo ""

    # Show commits
    if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        local commit_count=$(git log "$TARGET_BRANCH..$BRANCH_NAME" --oneline 2>/dev/null | wc -l | tr -d ' ')
        if [[ "$commit_count" -gt 0 ]]; then
            echo "═══ Commits ($commit_count) vs $TARGET_BRANCH ═══"
            git log "$TARGET_BRANCH..$BRANCH_NAME" --format="  %h %s"
            echo ""
        else
            echo "═══ No commits vs $TARGET_BRANCH ═══"
            echo ""
        fi
    fi

    # Show uncommitted changes
    local uncommitted=$(git -C "$WORKTREE_PATH" status --porcelain 2>/dev/null)
    if [[ -n "$uncommitted" ]]; then
        echo "═══ Uncommitted Changes ═══"
        git -C "$WORKTREE_PATH" status --short
        echo ""
    fi

    # Show file change summary
    if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        local files_changed=$(git diff --stat "$TARGET_BRANCH..$BRANCH_NAME" 2>/dev/null | tail -1)
        if [[ -n "$files_changed" && "$files_changed" != *"0 files changed"* ]]; then
            echo "═══ Files Changed ═══"
            echo "  $files_changed"
        fi
    fi
}

# =============================================================================
# COMMAND: diff
# =============================================================================

cmd_diff() {
    local ID=""
    local STAT_ONLY=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --stat)    STAT_ONLY=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib diff <id> [options]

Show the full diff of an agent's work compared to main branch.

Arguments:
  id              Agent identifier

Options:
  --stat          Show diffstat summary only
  -h, --help      Show this help

Examples:
  ib diff task-a1b2
  ib diff task-a1b2 --stat
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib diff <id>" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"
    local BRANCH_NAME="agent/$ID"

    # Check if agent exists
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Determine target branch for comparison
    local TARGET_BRANCH=""
    if git show-ref --verify --quiet refs/heads/main; then
        TARGET_BRANCH="main"
    elif git show-ref --verify --quiet refs/heads/master; then
        TARGET_BRANCH="master"
    else
        TARGET_BRANCH="HEAD"
    fi

    # Check if branch exists
    if ! git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        echo "Error: branch '$BRANCH_NAME' does not exist" >&2
        exit 1
    fi

    if [[ "$STAT_ONLY" == true ]]; then
        git diff --stat "$TARGET_BRANCH..$BRANCH_NAME"
    else
        git diff "$TARGET_BRANCH..$BRANCH_NAME"
    fi
}

# =============================================================================
# COMMAND: kill
# =============================================================================

cmd_kill() {
    local ID=""
    local FORCE=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)   FORCE=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib kill <id> [options]

Close an agent without merging its work. Removes the agent's session,
worktree, branch, and data directory.

Arguments:
  id              Agent identifier

Options:
  --force         Don't ask for confirmation
  -h, --help      Show this help

Examples:
  ib kill task-a1b2
  ib kill task-a1b2 --force
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib kill <id> [options]" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"
    local TMUX_SESSION=$(session_name "$ID")

    # Check if agent exists at all
    if [[ ! -d "$AGENT_DIR" ]] && ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Confirm if not forced
    if [[ "$FORCE" != true ]]; then
        local confirm
        read -p "Kill agent '$ID' and remove all data? [y/N] " confirm
        if [[ "$confirm" != [yY] && "$confirm" != [yY][eE][sS] ]]; then
            echo "Cancelled."
            exit 0
        fi
    fi

    # Archive output before cleanup
    archive_agent_output "$ID"

    # Kill tmux session if running
    if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        tmux kill-session -t "$TMUX_SESSION"
        echo "Killed session: $ID"
    else
        echo "Session not running: $ID"
    fi

    # Always cleanup
    if [[ -d "$AGENT_DIR" ]]; then
        # Remove git worktree if it exists
        if [[ -d "$AGENT_DIR/repo" ]]; then
            git worktree remove "$AGENT_DIR/repo" --force 2>/dev/null || {
                echo "Warning: could not remove worktree, removing directory manually" >&2
                rm -rf "$AGENT_DIR/repo"
            }
            # Also try to delete the branch
            git branch -D "agent/$ID" 2>/dev/null || true
        fi

        # Remove agent directory
        rm -rf "$AGENT_DIR"
        echo "Closed agent: $ID"
    fi
}

# =============================================================================
# COMMAND: resume
# =============================================================================

cmd_resume() {
    local ID=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib resume <id>

Resume a stopped agent session.

When an agent's tmux session ends unexpectedly (crash, reboot, etc.),
the Claude conversation history is preserved. This command restarts
the tmux session and resumes the Claude conversation where it left off.

Arguments:
  id              Agent identifier

Requirements:
  - Agent must exist (directory in .ittybitty/agents/)
  - Agent must be stopped (no active tmux session)
  - Agent must have a session_id in meta.json

Examples:
  ib resume task-a1b2
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib resume <id>" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"

    # Check if agent exists
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Check agent state - must be stopped
    local state=$(get_state "$ID")
    if [[ "$state" != "stopped" ]]; then
        echo "Error: agent '$ID' is not stopped (current state: $state)" >&2
        case "$state" in
            running)
                echo "Agent is actively processing. Use 'ib look $ID' to view output." >&2
                ;;
            waiting)
                echo "Agent is waiting for input. Use 'ib send $ID \"message\"' to continue." >&2
                ;;
            complete)
                echo "Agent has completed. Use 'ib merge $ID' or 'ib kill $ID' to close it." >&2
                ;;
        esac
        exit 1
    fi

    # Read session ID from meta.json
    local META_FILE="$AGENT_DIR/meta.json"
    if [[ ! -f "$META_FILE" ]]; then
        echo "Error: meta.json not found for agent '$ID'" >&2
        exit 1
    fi

    local SESSION_UUID=$(jq -r '.session_id // ""' "$META_FILE" 2>/dev/null)
    if [[ -z "$SESSION_UUID" || "$SESSION_UUID" == "null" ]]; then
        echo "Error: no session_id found in meta.json" >&2
        echo "This agent was created before resume support was added." >&2
        exit 1
    fi

    # Read model from meta.json if set
    local MODEL=$(jq -r '.model // ""' "$META_FILE" 2>/dev/null)
    [[ "$MODEL" == "null" ]] && MODEL=""

    # Determine working directory
    local WORK_PATH="$AGENT_DIR/repo"
    if [[ ! -d "$WORK_PATH" ]]; then
        # No worktree, use git root
        WORK_PATH="$(pwd)"
    fi

    # Read yolo mode from original start.sh to preserve settings
    local YOLO_MODE=false
    if [[ -f "$AGENT_DIR/start.sh" ]] && grep -q "dangerously-skip-permissions" "$AGENT_DIR/start.sh"; then
        YOLO_MODE=true
    fi

    # Build claude args for resume
    local CLAUDE_ARGS=""
    if [[ "$YOLO_MODE" == true ]]; then
        CLAUDE_ARGS="--dangerously-skip-permissions --permission-mode bypassPermissions"
    else
        CLAUDE_ARGS="--permission-mode dontAsk"
    fi
    if [[ -n "$MODEL" ]]; then
        CLAUDE_ARGS="$CLAUDE_ARGS --model $MODEL"
    fi

    # Get git root for PATH
    local GIT_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"

    # Write a resume script
    local RESUME_SCRIPT="$AGENT_DIR/resume.sh"
    local ABS_EXIT_SCRIPT="$(cd "$AGENT_DIR" && pwd)/exit-check.sh"
    cat > "$RESUME_SCRIPT" <<EOF
#!/bin/bash
# Add git repo root to PATH so 'ib' is available
export PATH="$GIT_ROOT:\$PATH"
claude --resume "$SESSION_UUID" $CLAUDE_ARGS
$ABS_EXIT_SCRIPT
EOF
    chmod +x "$RESUME_SCRIPT"

    # Ensure tmux server is running
    if ! tmux start-server 2>/dev/null; then
        echo "Error: could not start tmux server" >&2
        exit 1
    fi

    # Start tmux session with resume script
    local ABS_RESUME_SCRIPT="$(cd "$AGENT_DIR" && pwd)/resume.sh"
    local TMUX_SESSION=$(session_name "$ID")
    if ! tmux new-session -d -s "$TMUX_SESSION" -c "$WORK_PATH" "$ABS_RESUME_SCRIPT"; then
        echo "Error: could not create tmux session '$TMUX_SESSION'" >&2
        exit 1
    fi

    # For non-yolo mode, auto-accept the workspace trust dialog
    if [[ "$YOLO_MODE" != true ]]; then
        sleep 2
        tmux send-keys -t "$TMUX_SESSION" Enter
    fi

    echo "Resumed agent: $ID"
    echo "Use 'ib look $ID' to view output"
}

# =============================================================================
# COMMAND: merge
# =============================================================================

cmd_merge() {
    local ID=""
    local TARGET_BRANCH=""
    local FORCE=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --into)    TARGET_BRANCH="$2"; shift 2 ;;
            --force)   FORCE=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib merge <id> [options]

Merge an agent's work into the main branch and close the agent.
Removes the agent's session, worktree, branch, and data directory.

Arguments:
  id              Agent identifier

Options:
  --into BRANCH   Target branch to merge into (default: main or master)
  --force         Don't ask for confirmation
  -h, --help      Show this help

The merge command:
1. Checks for uncommitted changes in the agent's worktree
2. Switches to the target branch
3. Merges the agent's branch (agent/<id>)
4. Cleans up the worktree, branch, and agent data

Examples:
  ib merge task-a1b2
  ib merge task-a1b2 --into develop
  ib merge task-a1b2 --force
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib merge <id> [options]" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"
    local BRANCH_NAME="agent/$ID"
    local TMUX_SESSION=$(session_name "$ID")

    # Check if agent exists
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Load config and warn about PR settings
    load_config
    if [[ "$CONFIG_CREATE_PRS" == "true" ]]; then
        if ! command -v gh &>/dev/null; then
            echo "Warning: createPullRequests is enabled but 'gh' CLI is not installed" >&2
        fi
        if [[ -z $(git remote 2>/dev/null | head -1) ]]; then
            echo "Warning: createPullRequests is enabled but no git remote is configured" >&2
        fi
    fi

    # Check if worktree exists
    local WORKTREE_PATH="$AGENT_DIR/repo"
    if [[ ! -d "$WORKTREE_PATH" ]]; then
        echo "Error: agent '$ID' has no worktree (was created with --no-worktree?)" >&2
        exit 1
    fi

    # Check for uncommitted changes in the worktree
    if [[ -n $(git -C "$WORKTREE_PATH" status --porcelain 2>/dev/null) ]]; then
        echo "Error: agent '$ID' has uncommitted changes:" >&2
        git -C "$WORKTREE_PATH" status --short >&2
        echo "" >&2
        echo "Please commit or discard changes first, or use 'ib send $ID' to ask the agent to commit." >&2
        exit 1
    fi

    # Determine target branch
    if [[ -z "$TARGET_BRANCH" ]]; then
        # Try main, then master
        if git show-ref --verify --quiet refs/heads/main; then
            TARGET_BRANCH="main"
        elif git show-ref --verify --quiet refs/heads/master; then
            TARGET_BRANCH="master"
        else
            echo "Error: could not determine target branch (no main or master found)" >&2
            echo "Use --into BRANCH to specify target branch" >&2
            exit 1
        fi
    fi

    # Check if agent branch exists
    if ! git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        echo "Error: branch '$BRANCH_NAME' does not exist" >&2
        exit 1
    fi

    # Show what will be merged
    local commit_count=$(git log "$TARGET_BRANCH..$BRANCH_NAME" --oneline 2>/dev/null | wc -l | tr -d ' ')
    if [[ "$commit_count" -eq 0 ]]; then
        echo "Nothing to merge: $BRANCH_NAME has no new commits relative to $TARGET_BRANCH"
        echo "Proceeding with cleanup..."
    else
        echo "Will merge $commit_count commit(s) from $BRANCH_NAME into $TARGET_BRANCH:"
        git log "$TARGET_BRANCH..$BRANCH_NAME" --oneline
        echo ""
    fi

    # Confirm if not forced
    if [[ "$FORCE" != true && "$commit_count" -gt 0 ]]; then
        local confirm
        read -p "Proceed with merge? [y/N] " confirm
        if [[ "$confirm" != [yY] && "$confirm" != [yY][eE][sS] ]]; then
            echo "Cancelled."
            exit 0
        fi
    fi

    # Archive output before cleanup
    archive_agent_output "$ID"

    # Kill the agent session if still running
    if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        echo "Stopping agent session..."
        tmux kill-session -t "$TMUX_SESSION"
    fi

    # Perform the merge
    if [[ "$commit_count" -gt 0 ]]; then
        echo "Merging $BRANCH_NAME into $TARGET_BRANCH..."
        git checkout "$TARGET_BRANCH" || {
            echo "Error: could not checkout $TARGET_BRANCH" >&2
            exit 1
        }
        git merge "$BRANCH_NAME" -m "Merge agent $ID work" || {
            echo "Error: merge failed (conflicts?). Resolve manually." >&2
            exit 1
        }
        echo "Merged successfully!"
    fi

    # Always cleanup
    echo "Cleaning up..."
    # Remove git worktree
    git worktree remove "$WORKTREE_PATH" --force 2>/dev/null || {
        echo "Warning: could not remove worktree, removing directory manually" >&2
        rm -rf "$WORKTREE_PATH"
    }
    # Delete the branch
    git branch -D "$BRANCH_NAME" 2>/dev/null && echo "Deleted branch: $BRANCH_NAME"
    # Remove agent directory
    rm -rf "$AGENT_DIR"
    echo "Closed agent: $ID"
}

# =============================================================================
# COMMAND: hook-status
# =============================================================================

cmd_hook_status() {
    local ID="$1"

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local state=$(get_state "$ID")

    if [[ "$state" == "unknown" ]]; then
        local TMUX_SESSION=$(session_name "$ID")
        local prompt="When you stop working, you must always end your message with either 'WAITING' or 'I HAVE COMPLETED THE GOAL'. If you are waiting for input or have nothing more to do without further instruction, say 'WAITING'. If you have completed your goal, say 'I HAVE COMPLETED THE GOAL'. If you have neither completed your goal nor are waiting, then please resume your work."

        tmux send-keys -t "$TMUX_SESSION" "$prompt"
        sleep 0.1
        tmux send-keys -t "$TMUX_SESSION" Enter
    fi

    # Always print the state for debugging
    echo "$state"
}

# =============================================================================
# MAIN DISPATCH
# =============================================================================

# Initialize paths to use root repo (handles running from worktrees)
init_paths

case "${1:-help}" in
    new-agent|new)
        shift
        cmd_new_agent "$@"
        ;;
    list|ls)
        shift
        cmd_list "$@"
        ;;
    status)
        shift
        cmd_status "$@"
        ;;
    diff)
        shift
        cmd_diff "$@"
        ;;
    merge)
        shift
        cmd_merge "$@"
        ;;
    send)
        shift
        cmd_send "$@"
        ;;
    look)
        shift
        cmd_look "$@"
        ;;
    kill)
        shift
        cmd_kill "$@"
        ;;
    resume)
        shift
        cmd_resume "$@"
        ;;
    hook-status)
        shift
        cmd_hook_status "$@"
        ;;
    help|--help|-h)
        cat <<EOF
ib (ittybitty) - multi-agent orchestration for Claude Code

Usage: ib <command> [options]

Commands:
  new-agent   Start a new agent with a prompt
  list        Show all agents and their state
  send        Send input to an agent
  look        Look at an agent's recent output
  status      Show git status of agent's work (commits, changes)
  diff        Show full diff of agent's work vs main
  merge       Merge agent's work into main branch and close the agent
  kill        Close an agent without merging
  resume      Restart a stopped agent's session

Aliases:
  new         Alias for new-agent
  ls          Alias for list

Environment:
  ITTYBITTY_DIR    Base directory for all data (default: .ittybitty)
                   Contains: agents/, archive/

Configuration:
  .ittybitty.json   Configure agent permissions (see 'ib new-agent --help')

Run 'ib <command> --help' for command-specific help.

Examples:
  ib new-agent "verify all citations in docs/comparison.md"
  ib list
  ib look agent-abc123
  ib status agent-abc123
  ib diff agent-abc123
  ib send agent-abc123 "yes, proceed with option 2"
  ib merge agent-abc123
  ib kill agent-abc123
  ib resume agent-abc123
EOF
        ;;
    *)
        echo "Unknown command: $1" >&2
        echo "Run 'ib help' for usage." >&2
        exit 1
        ;;
esac

#!/bin/bash
# ib (ittybitty) - multi-agent orchestration for Claude Code
# Usage: ib <command> [options]
#
# A minimal tool for spawning and managing multiple Claude Code agents
# using tmux sessions and git worktrees.

set -e

ITTYBITTY_DIR="${ITTYBITTY_DIR:-.ittybitty}"
SESSION_PREFIX="ittybitty-"
TMUX_WIDTH=60  # Width for agent tmux panes (used by watch command)

# Initialize paths - will be set to root repo after get_root_repo is defined
AGENTS_DIR=""
ARCHIVE_DIR=""
ROOT_REPO_PATH=""

# Convert agent ID to tmux session name
session_name() {
    echo "${SESSION_PREFIX}$1"
}

# =============================================================================
# HELPERS
# =============================================================================

# Archive an agent's output before cleanup
# Creates .ittybitty/archive/YYYYMMDD-HHMMSS-<agent-id>/ with output.log, agent.log, meta.json
archive_agent_output() {
    local ID="$1"
    local AGENT_DIR="$AGENTS_DIR/$ID"

    # Capture final output if session is still running
    local SESSION=$(session_name "$ID")
    if tmux has-session -t "$SESSION" 2>/dev/null; then
        tmux capture-pane -t "$SESSION" -p -S - > "$AGENT_DIR/output.log" 2>/dev/null || true
    fi

    # Only archive if there's something to archive
    if [[ -f "$AGENT_DIR/output.log" || -f "$AGENT_DIR/agent.log" || -f "$AGENT_DIR/meta.json" ]]; then
        local timestamp=$(date +%Y%m%d-%H%M%S)
        local archive_folder="$ARCHIVE_DIR/${timestamp}-${ID}"
        mkdir -p "$archive_folder"

        # Archive output.log (tmux output)
        if [[ -f "$AGENT_DIR/output.log" ]]; then
            mv "$AGENT_DIR/output.log" "$archive_folder/output.log"
        fi

        # Archive agent.log (agent's log entries)
        if [[ -f "$AGENT_DIR/agent.log" ]]; then
            cp "$AGENT_DIR/agent.log" "$archive_folder/agent.log"
        fi

        # Archive meta.json (agent config: prompt, model, session_id, etc.)
        if [[ -f "$AGENT_DIR/meta.json" ]]; then
            cp "$AGENT_DIR/meta.json" "$archive_folder/meta.json"
        fi

        # Archive settings.local.json (permissions and hooks configuration)
        # Note: copied to $AGENT_DIR before worktree removal in teardown_agent
        if [[ -f "$AGENT_DIR/settings.local.json" ]]; then
            mv "$AGENT_DIR/settings.local.json" "$archive_folder/settings.local.json"
        fi

        echo "Archived to: $archive_folder/"
    fi
}

# Log a message to an agent's log file and optionally echo to stdout
# Args: $1 = agent ID, $2 = message, $3 = --quiet (optional, suppress stdout)
# This is the central logging function - use it for all agent logging
log_agent() {
    local ID="$1"
    local MESSAGE="$2"
    local QUIET="${3:-}"
    local AGENT_DIR="$AGENTS_DIR/$ID"
    local LOG_FILE="$AGENT_DIR/agent.log"

    # Only log if agent directory exists
    if [[ -d "$AGENT_DIR" ]]; then
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        echo "[$timestamp] $MESSAGE" >> "$LOG_FILE"
    fi

    # Echo to stdout unless --quiet
    if [[ "$QUIET" != "--quiet" ]]; then
        echo "$MESSAGE"
    fi
}

# Log multi-line content with a header/footer to an agent's log file
# Args: $1 = agent ID, $2 = title, $3 = content
log_multi_line() {
    local ID="$1"
    local TITLE="$2"
    local CONTENT="$3"
    local AGENT_DIR="$AGENTS_DIR/$ID"
    local LOG_FILE="$AGENT_DIR/agent.log"

    # Only log if agent directory exists and we have content
    [[ -d "$AGENT_DIR" ]] || return
    [[ -n "$CONTENT" ]] || return

    {
        echo "========== $TITLE =========="
        echo "$CONTENT"
        echo "============================="
    } >> "$LOG_FILE"
}

# Log tmux screen content for debugging state detection
# Args: $1 = agent ID
# Uses LAST_TMUX_CAPTURE if available (set by capture_tmux/get_state), otherwise captures fresh
log_tmux_screen() {
    local ID="$1"

    # Use cached capture if available, otherwise capture fresh
    local tmux_content="$LAST_TMUX_CAPTURE"
    if [[ -z "$tmux_content" ]]; then
        local TMUX_SESSION=$(session_name "$ID")
        tmux_content=$(capture_tmux "$TMUX_SESSION" 20)
    fi

    log_multi_line "$ID" "tmux" "$tmux_content"
}

# Check if ib is being called from within an agent worktree
# Returns: 0 if running as an agent, 1 if not
# Use this to detect when commands like kill/merge/nuke are called by an agent
# so we can error out instead of blocking on interactive prompts
is_running_as_agent() {
    local current_dir=$(pwd)
    if [[ "$current_dir" == *"/.ittybitty/agents/"*"/repo"* ]]; then
        return 0
    fi
    return 1
}

# Get unfinished children of a manager agent (children that haven't been merged/killed)
# Args: $1 = manager agent ID
# Returns: space-separated list of unfinished child IDs (empty if none)
# Children in running, waiting, or complete state all need attention before manager can complete
get_unfinished_children() {
    local MANAGER_ID="$1"
    local unfinished_children=""

    # Iterate through all agent directories
    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        local child_id=$(basename "$agent_dir")
        local meta_file="$agent_dir/meta.json"

        # Skip if no meta.json
        [[ -f "$meta_file" ]] || continue

        # Check if this agent's manager matches
        local manager=$(jq -r '.manager // ""' "$meta_file" 2>/dev/null)
        if [[ "$manager" == "$MANAGER_ID" ]]; then
            # Check if this child is in an unfinished state (running, waiting, or complete)
            # All of these need to be merged or killed before manager can complete
            local state=$(get_state "$child_id")
            if [[ "$state" == "running" || "$state" == "waiting" || "$state" == "complete" ]]; then
                if [[ -n "$unfinished_children" ]]; then
                    unfinished_children="$unfinished_children $child_id"
                else
                    unfinished_children="$child_id"
                fi
            fi
        fi
    done

    echo "$unfinished_children"
}

# Teardown an agent: kill processes, remove worktree, archive, cleanup
# Args: $1 = agent ID
#       $2 = --quiet (optional, suppress stdout for batch mode)
#       $3 = log message (optional, defaults to "Agent killed")
# Returns: 0 if successful, 1 if failed
# Note: Does NOT do confirmation prompts or orphan scanning - callers handle those
teardown_agent() {
    local ID="$1"
    local QUIET="${2:-}"
    local LOG_MSG="${3:-Agent killed}"
    local AGENT_DIR="$AGENTS_DIR/$ID"
    local TMUX_SESSION=$(session_name "$ID")

    # Log the action
    log_agent "$ID" "$LOG_MSG" "$QUIET"

    # Capture tmux output BEFORE killing session (so archive has it)
    if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        tmux capture-pane -t "$TMUX_SESSION" -p -S - > "$AGENT_DIR/output.log" 2>/dev/null || true
    fi

    # Kill Claude process gracefully before killing tmux session
    if kill_agent_process "$ID" 2>/dev/null; then
        log_agent "$ID" "Terminated Claude process" "$QUIET"
    fi

    # Kill tmux session if running
    if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        tmux kill-session -t "$TMUX_SESSION" 2>/dev/null || true
        log_agent "$ID" "Killed tmux session" "$QUIET"
    fi

    # Copy settings.local.json before removing worktree (for archiving)
    if [[ -f "$AGENT_DIR/repo/.claude/settings.local.json" ]]; then
        cp "$AGENT_DIR/repo/.claude/settings.local.json" "$AGENT_DIR/settings.local.json"
    fi

    # Remove git worktree if it exists
    if [[ -d "$AGENT_DIR/repo" ]]; then
        git worktree remove "$AGENT_DIR/repo" --force 2>/dev/null || {
            log_agent "$ID" "Warning: could not remove worktree, removing directory manually" "$QUIET"
            rm -rf "$AGENT_DIR/repo"
        }
        # Also try to delete the branch
        if git branch -D "agent/$ID" 2>/dev/null; then
            log_agent "$ID" "Deleted branch agent/$ID" "$QUIET"
        fi
    fi

    # Archive output after teardown (captures complete log)
    if [[ "$QUIET" == "--quiet" ]]; then
        archive_agent_output "$ID" > /dev/null 2>&1 || true
    else
        archive_agent_output "$ID"
    fi

    # Remove agent directory last
    if [[ -d "$AGENT_DIR" ]]; then
        rm -rf "$AGENT_DIR"
        return 0
    fi

    return 1
}

# Kill the Claude process for an agent using graceful shutdown
# Args: $1 = agent ID
# Returns: 0 if killed successfully, 1 if process not found
kill_agent_process() {
    local ID="$1"
    local AGENT_DIR="$AGENTS_DIR/$ID"
    local TMUX_SESSION=$(session_name "$ID")
    local PID=""

    # Strategy 1: Dynamic lookup from tmux (most reliable)
    if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        local PANE_PID=$(tmux list-panes -t "$TMUX_SESSION" -F '#{pane_pid}' 2>/dev/null | head -1)
        if [[ -n "$PANE_PID" ]]; then
            # Find Claude process under this pane
            PID=$(pgrep -P "$PANE_PID" -f "claude" 2>/dev/null | head -1)
        fi
    fi

    # Strategy 2: Fallback to meta.json PID
    if [[ -z "$PID" && -f "$AGENT_DIR/meta.json" ]]; then
        PID=$(jq -r '.claude_pid // ""' "$AGENT_DIR/meta.json" 2>/dev/null)
        [[ "$PID" == "null" || -z "$PID" ]] && PID=""
    fi

    # No PID found - nothing to kill
    [[ -z "$PID" ]] && return 1

    # Check if process is still running
    ! kill -0 "$PID" 2>/dev/null && return 0  # Already dead, success

    # Graceful shutdown: SIGTERM first
    kill -TERM "$PID" 2>/dev/null || return 1

    # Wait up to 2 seconds for graceful shutdown
    local waited=0
    while kill -0 "$PID" 2>/dev/null && [[ $waited -lt 20 ]]; do
        sleep 0.1
        ((waited++))
    done

    # If still running, force kill with SIGKILL
    if kill -0 "$PID" 2>/dev/null; then
        kill -KILL "$PID" 2>/dev/null || return 1
        sleep 0.1
    fi

    # Return success if process is dead
    ! kill -0 "$PID" 2>/dev/null
}

# Scan for and kill orphaned Claude processes
# An orphaned process is one where:
# 1. The process cwd contains ".ittybitty/agents/"
# 2. The agent directory no longer exists (deleted)
# This prevents false positives from legitimate Claude instances
scan_and_kill_orphans() {
    local killed_count=0

    while IFS= read -r pid; do
        [[ -z "$pid" ]] && continue

        # Get process working directory (macOS: lsof, Linux: /proc)
        local proc_cwd=""
        if [[ "$(uname)" == "Darwin" ]]; then
            proc_cwd=$(lsof -a -d cwd -p "$pid" -Fn 2>/dev/null | grep '^n' | cut -c2-)
        else
            proc_cwd=$(readlink "/proc/$pid/cwd" 2>/dev/null)
        fi

        [[ -z "$proc_cwd" ]] && continue

        # Safety check 1: Must contain ".ittybitty/agents/"
        [[ "$proc_cwd" != *"/.ittybitty/agents/"* ]] && continue

        # Safety check 2: Extract agent dir and verify it doesn't exist
        local agent_path=""
        if [[ "$proc_cwd" =~ (.*/.ittybitty/agents/[^/]+) ]]; then
            agent_path="${BASH_REMATCH[1]}"
        fi

        # Skip if we couldn't extract path or if directory still exists
        [[ -z "$agent_path" || -d "$agent_path" ]] && continue

        # Confirmed orphan - kill it
        echo "  Found orphaned Claude process (PID $pid, deleted dir: $agent_path)"

        if kill -TERM "$pid" 2>/dev/null; then
            local waited=0
            while kill -0 "$pid" 2>/dev/null && [[ $waited -lt 20 ]]; do
                sleep 0.1
                ((waited++))
            done

            # Force kill if still alive
            kill -0 "$pid" 2>/dev/null && kill -KILL "$pid" 2>/dev/null
            sleep 0.1

            if ! kill -0 "$pid" 2>/dev/null; then
                echo "    ✓ Killed orphaned process $pid"
                ((killed_count++))
            else
                echo "    ✗ Failed to kill process $pid"
            fi
        fi
    done < <(pgrep -f "claude" 2>/dev/null)

    [[ $killed_count -gt 0 ]] && echo "Cleaned up $killed_count orphaned Claude process(es)"
    return 0
}

# Load config from .ittybitty.json if it exists
# Sets global variables: CONFIG_MANAGER_ALLOW, CONFIG_MANAGER_DENY, CONFIG_WORKER_ALLOW, CONFIG_WORKER_DENY, CONFIG_CREATE_PRS, CONFIG_MAX_AGENTS, CONFIG_MODEL
load_config() {
    CONFIG_MANAGER_ALLOW=""
    CONFIG_MANAGER_DENY=""
    CONFIG_WORKER_ALLOW=""
    CONFIG_WORKER_DENY=""
    CONFIG_CREATE_PRS="false"
    CONFIG_MAX_AGENTS="10"
    CONFIG_MODEL=""

    local config_file=".ittybitty.json"
    if [[ ! -f "$config_file" ]]; then
        return 0
    fi

    if ! command -v jq &>/dev/null; then
        echo "Warning: jq not available, cannot read $config_file" >&2
        return 0
    fi

    # Read manager permissions
    CONFIG_MANAGER_ALLOW=$(jq -r '.permissions.manager.allow // [] | @json' "$config_file" 2>/dev/null)
    CONFIG_MANAGER_DENY=$(jq -r '.permissions.manager.deny // [] | @json' "$config_file" 2>/dev/null)

    # Read worker permissions
    CONFIG_WORKER_ALLOW=$(jq -r '.permissions.worker.allow // [] | @json' "$config_file" 2>/dev/null)
    CONFIG_WORKER_DENY=$(jq -r '.permissions.worker.deny // [] | @json' "$config_file" 2>/dev/null)

    # Read PR creation setting
    CONFIG_CREATE_PRS=$(jq -r '.createPullRequests // false' "$config_file" 2>/dev/null)

    # Read max agents setting
    CONFIG_MAX_AGENTS=$(jq -r '.maxAgents // 10' "$config_file" 2>/dev/null)

    # Read model setting
    CONFIG_MODEL=$(jq -r '.model // ""' "$config_file" 2>/dev/null)
    if [[ "$CONFIG_MODEL" == "null" ]]; then
        CONFIG_MODEL=""
    fi
}

# Count active agents (agents with meta.json)
count_agents() {
    local count=0
    if [[ ! -d "$AGENTS_DIR" ]]; then
        echo "0"
        return 0
    fi

    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        [[ -f "$agent_dir/meta.json" ]] || continue
        ((count++))
    done

    echo "$count"
}

# Build settings.local.json content for an agent worktree
# Args: $1 = "manager" or "worker"
build_agent_settings() {
    local agent_type="$1"
    local base_settings="{}"

    # Start with existing settings if available
    if [[ -f ".claude/settings.local.json" ]]; then
        base_settings=$(cat ".claude/settings.local.json")
    fi

    # Load config
    load_config

    # Determine which permissions to use
    local allow_json="[]"
    local deny_json="[]"

    if [[ "$agent_type" == "worker" && "$CONFIG_WORKER_ALLOW" != "[]" && "$CONFIG_WORKER_ALLOW" != "" ]]; then
        allow_json="$CONFIG_WORKER_ALLOW"
        deny_json="${CONFIG_WORKER_DENY:-[]}"
    elif [[ "$CONFIG_MANAGER_ALLOW" != "[]" && "$CONFIG_MANAGER_ALLOW" != "" ]]; then
        allow_json="$CONFIG_MANAGER_ALLOW"
        deny_json="${CONFIG_MANAGER_DENY:-[]}"
    fi

    # Always include ib and git permissions
    # Git commands are safe in worktrees: agents can't switch branches or push
    local ib_perms='["Bash(ib:*)", "Bash(./ib:*)", "Bash(git status:*)", "Bash(git add:*)", "Bash(git commit:*)", "Bash(git diff:*)", "Bash(git show:*)", "Bash(git log:*)", "Bash(git ls-files:*)", "Bash(git grep:*)"]'

    # Build the PermissionRequest hook command
    # The hook receives JSON via stdin with tool_name, tool_input, etc.
    # Format: "Permission denied: ToolName (key1: val1..., key2: val2...)"
    local hook_cmd="jq -r '\"Permission denied: \" + .tool_name + if .tool_input then \" (\" + (.tool_input | to_entries | map(.key + \": \" + (.value | tostring | if length > 20 then .[0:20] + \"...\" else . end)) | join(\", \")) + \")\" else \"\" end' | xargs -I {} ib log --id __AGENT_ID__ --quiet \"{}\" && echo '{\"hookSpecificOutput\":{\"hookEventName\":\"PermissionRequest\",\"decision\":{\"behavior\":\"deny\"}}}'"

    # Merge everything together and add hooks
    echo "$base_settings" | jq --argjson ib "$ib_perms" \
        --argjson cfg_allow "$allow_json" \
        --argjson cfg_deny "$deny_json" \
        --arg perm_hook "$hook_cmd" '
        .permissions.allow = ((.permissions.allow // []) + $ib + $cfg_allow | unique) |
        .permissions.deny = ((.permissions.deny // []) + $cfg_deny | unique) |
        .hooks.Stop = [{
            "hooks": [{
                "type": "command",
                "command": "ib",
                "args": ["hook-status", "__AGENT_ID__"]
            }]
        }] |
        .hooks.PermissionRequest = [{
            "matcher": "*",
            "hooks": [{
                "type": "command",
                "command": $perm_hook
            }]
        }]
    '
}

# Resolve a partial agent ID to a full ID
# Returns the full ID if exactly one match, errors otherwise
resolve_agent_id() {
    local partial="$1"
    local matches=()

    # Check for exact match first (tmux session or directory)
    if tmux has-session -t "$(session_name "$partial")" 2>/dev/null || [[ -d "$AGENTS_DIR/$partial" ]]; then
        echo "$partial"
        return 0
    fi

    # Look for partial matches in agent directories
    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        local id=$(basename "$agent_dir")
        if [[ "$id" == *"$partial"* ]]; then
            matches+=("$id")
        fi
    done

    # Also check tmux sessions that might not have directories
    while IFS= read -r session; do
        if [[ "$session" == *"$partial"* ]] && [[ ! " ${matches[*]} " =~ " $session " ]]; then
            matches+=("$session")
        fi
    done < <(tmux list-sessions -F '#{session_name}' 2>/dev/null | grep -E '^agent-')

    case ${#matches[@]} in
        0)
            echo "Error: no agent matching '$partial'" >&2
            return 1
            ;;
        1)
            echo "${matches[0]}"
            return 0
            ;;
        *)
            echo "Error: '$partial' matches multiple agents:" >&2
            printf "  %s\n" "${matches[@]}" >&2
            return 1
            ;;
    esac
}

# Check that we're in a git repo at its root directory
require_git_root() {
    # Check if in a git repo
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "Error: must be run from within a git repository" >&2
        exit 1
    fi

    # Check if at repo root
    local git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    local cwd=$(pwd)
    if [[ "$cwd" != "$git_root" ]]; then
        echo "Error: must be run from git repository root" >&2
        echo "  Current directory: $cwd" >&2
        echo "  Repository root:   $git_root" >&2
        exit 1
    fi
}

# Find the root repository path (the original repo, not a worktree)
# If running from within a worktree, returns the main repo root.
# If running from main repo, returns the current location.
get_root_repo() {
    # First check we're in a git repo
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "Error: not in a git repository" >&2
        return 1
    fi

    # Get the common git directory (shared across all worktrees)
    local common_dir=$(git rev-parse --git-common-dir 2>/dev/null)

    if [[ -z "$common_dir" ]]; then
        # Fallback for older git versions
        git rev-parse --show-toplevel
        return 0
    fi

    # If common_dir is relative (like ".git"), we're in the main repo
    if [[ "$common_dir" == ".git" || "$common_dir" == "$(git rev-parse --git-dir)" ]]; then
        git rev-parse --show-toplevel
    else
        # common_dir is absolute path like /path/to/repo/.git
        # Go up one level to get the repo root
        dirname "$common_dir"
    fi
}

# Initialize global paths to use root repo
# Called once when script runs (if in a git repo)
init_paths() {
    if git rev-parse --git-dir >/dev/null 2>&1; then
        ROOT_REPO_PATH=$(get_root_repo)
        AGENTS_DIR="$ROOT_REPO_PATH/$ITTYBITTY_DIR/agents"
        ARCHIVE_DIR="$ROOT_REPO_PATH/$ITTYBITTY_DIR/archive"
    else
        # Not in a git repo - use relative paths as fallback
        AGENTS_DIR="$ITTYBITTY_DIR/agents"
        ARCHIVE_DIR="$ITTYBITTY_DIR/archive"
    fi
}

# Format age from ISO timestamp
format_age() {
    local created="$1"
    local now=$(date +%s)
    # Strip timezone suffix (use % not %% to get shortest match from end)
    local timestamp="${created%[-+]*}"
    local then=$(date -j -f "%Y-%m-%dT%H:%M:%S" "$timestamp" +%s 2>/dev/null || echo "$now")
    local diff=$((now - then))

    if [[ $diff -lt 60 ]]; then
        echo "${diff}s"
    elif [[ $diff -lt 3600 ]]; then
        echo "$((diff / 60))m"
    elif [[ $diff -lt 86400 ]]; then
        echo "$((diff / 3600))h"
    else
        echo "$((diff / 86400))d"
    fi
}

# Global variable to store the last tmux capture for debugging
# Set by capture_tmux, used by log_tmux_screen
LAST_TMUX_CAPTURE=""

# Capture tmux pane content and store in LAST_TMUX_CAPTURE
# Args: $1 = tmux session name, $2 = number of lines (default 20)
# Returns: captured content via stdout, also sets LAST_TMUX_CAPTURE
capture_tmux() {
    local session="$1"
    local lines="${2:-20}"

    LAST_TMUX_CAPTURE=""

    if tmux has-session -t "$session" 2>/dev/null; then
        LAST_TMUX_CAPTURE=$(tmux capture-pane -t "$session" -p -S "-$lines" 2>/dev/null)
    fi

    echo "$LAST_TMUX_CAPTURE"
}

# Detect agent state from tmux
# States: running, waiting, stopped, complete, unknown
# Also sets LAST_TMUX_CAPTURE for debugging via capture_tmux
get_state() {
    local id="$1"
    local tmux_session=$(session_name "$id")

    if ! tmux has-session -t "$tmux_session" 2>/dev/null; then
        LAST_TMUX_CAPTURE=""
        echo "stopped"
        return
    fi

    # Capture visible pane for state detection (sets LAST_TMUX_CAPTURE)
    local recent=$(capture_tmux "$tmux_session" 20)

    # Check for Claude Code processing indicators (running) FIRST
    # These indicate active work even if completion phrase exists in context
    # - "esc to interrupt" appears when Claude is actively generating
    # - "ctrl+c to interrupt" appears when Claude is actively generating (alternate form)
    # - "ctrl+b ctrl+b" appears when a bash command is running
    # - "⎿  Running…" appears when bash tool is executing
    if echo "$recent" | grep -qE 'esc to interrupt|ctrl\+c to interrupt|ctrl\+b ctrl\+b|⎿  Running'; then
        echo "running"
        return
    fi

    # Check for completion signal (agents say this when done)
    # Use last 15 lines to see past status bar but avoid matching instructions
    local last_lines=$(echo "$recent" | tail -15)
    if echo "$last_lines" | grep -qF 'I HAVE COMPLETED THE GOAL'; then
        echo "complete"
        return
    fi

    # Check for explicit waiting message (but not in instructions)
    # Look for WAITING as a standalone word, not as part of instruction text
    if echo "$last_lines" | grep -qE '^\s*WAITING\s*$|⏺.*WAITING'; then
        echo "waiting"
        return
    fi

    # Idle but no explicit state message = unknown
    echo "unknown"
}

# Wait for Claude to start - logo OR permissions screen appears
# When permissions are NOT needed: logo appears immediately
# When permissions ARE needed: permissions screen appears first, logo after accepting
# Args: $1 = tmux session name
# Returns: 0 if Claude started (logo or permissions detected), 1 if timed out
# Sets global CLAUDE_STARTED_WITH to "logo" or "permissions"
wait_for_claude_start() {
    local TMUX_SESSION="$1"
    local max_wait=30  # Max half-seconds to wait (15 seconds total)
    local waited=0

    while [[ $waited -lt $max_wait ]]; do
        sleep 0.5
        waited=$((waited + 1))

        # Capture ALL history from tmux and check the top 50 lines
        local top_output=$(tmux capture-pane -t "$TMUX_SESSION" -p -S - 2>/dev/null | head -50)

        # Check for Claude logo - indicates Claude launched (no permissions needed)
        if echo "$top_output" | grep -q "Claude Code v"; then
            CLAUDE_STARTED_WITH="logo"
            return 0
        fi

        # Check for permissions screen - indicates Claude started but needs trust
        if echo "$top_output" | grep -qi "Enter to confirm" && echo "$top_output" | grep -qi "trust"; then
            CLAUDE_STARTED_WITH="permissions"
            return 0
        fi
    done

    return 1
}

# Wait for Claude logo only (used after accepting permissions)
# Args: $1 = tmux session name
# Returns: 0 if logo found, 1 if timed out
wait_for_claude_logo() {
    local TMUX_SESSION="$1"
    local max_wait=30  # Max half-seconds to wait (15 seconds total)
    local waited=0

    while [[ $waited -lt $max_wait ]]; do
        sleep 0.5
        waited=$((waited + 1))

        # Capture ALL history and check the top for logo
        local top_output=$(tmux capture-pane -t "$TMUX_SESSION" -p -S - 2>/dev/null | head -50)

        if echo "$top_output" | grep -q "Claude Code v"; then
            return 0
        fi
    done

    return 1
}

# Wait for and auto-accept workspace trust dialog
# Args: $1 = tmux session name
# Returns: 0 if successful, 1 if timed out
auto_accept_workspace_trust() {
    local TMUX_SESSION="$1"
    local max_attempts=5
    local attempt=0

    # Wait for Claude to start (shows either logo or permissions screen)
    echo "  [ib] Waiting for Claude to initialize..." >&2
    if ! wait_for_claude_start "$TMUX_SESSION"; then
        echo "  [ib] Warning: Claude did not start within timeout" >&2
        return 1
    fi

    # If logo appeared directly, no permissions needed
    if [[ "$CLAUDE_STARTED_WITH" == "logo" ]]; then
        echo "  [ib] Past permissions screen" >&2
        return 0
    fi

    # Permissions screen detected - accept it
    while [[ $attempt -lt $max_attempts ]]; do
        echo "  [ib] Permissions screen detected, sending Enter (attempt $((attempt + 1))/$max_attempts)..." >&2
        tmux send-keys -t "$TMUX_SESSION" Enter
        attempt=$((attempt + 1))

        # Wait for Claude to process the Enter
        sleep 4

        # Check RECENT output to see if permissions are still showing
        local recent_output=$(tmux capture-pane -t "$TMUX_SESSION" -p -S -50 2>/dev/null)

        # If permissions gone from recent output, wait for logo to confirm success
        if ! (echo "$recent_output" | grep -qi "Enter to confirm" && echo "$recent_output" | grep -qi "trust"); then
            # Permissions accepted - verify by waiting for logo
            if wait_for_claude_logo "$TMUX_SESSION"; then
                echo "  [ib] Past permissions screen" >&2
                return 0
            fi
        fi
    done

    # Max attempts exceeded
    echo "  [ib] Warning: Permissions screen may still be active after $max_attempts attempts" >&2
    echo "  [ib] Use 'ib look <agent-id>' to check status" >&2
    return 1
}

# =============================================================================
# TREE HELPERS (shared by cmd_tree and cmd_watch)
# =============================================================================

# Build agent data file for tree operations
# Creates a temp file with format: id|manager|state|age|model|prompt
# The caller is responsible for cleaning up the temp file
# Usage: local tmpfile=$(build_agent_data_file)
#        trap "rm -f '$tmpfile'" RETURN
build_agent_data_file() {
    local tmpfile=$(mktemp)

    if [[ ! -d "$AGENTS_DIR" ]]; then
        echo "$tmpfile"
        return
    fi

    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        [[ -f "$agent_dir/meta.json" ]] || continue

        local id=$(basename "$agent_dir")
        local meta="$agent_dir/meta.json"

        # Read metadata
        local prompt=$(jq -r '.prompt // ""' "$meta" 2>/dev/null | head -1 | cut -c1-40)
        local manager=$(jq -r '.manager // ""' "$meta" 2>/dev/null)
        local created=$(jq -r '.created // ""' "$meta" 2>/dev/null)
        local model=$(jq -r '.model // ""' "$meta" 2>/dev/null)

        # Get state and age
        local state=$(get_state "$id")
        local age=$(format_age "$created")

        # Display "unknown" as "waiting" for users
        if [[ "$state" == "unknown" ]]; then
            state="waiting"
        fi

        # Handle null manager
        if [[ "$manager" == "null" || -z "$manager" ]]; then
            manager=""
        fi

        # Handle null model
        if [[ "$model" == "null" || -z "$model" ]]; then
            model="-"
        fi

        # Store as: id|manager|state|age|model|prompt
        echo "$id|$manager|$state|$age|$model|$prompt" >> "$tmpfile"
    done

    echo "$tmpfile"
}

# Get agent IDs in depth-first tree order
# Args: $1 = tmpfile from build_agent_data_file
# Outputs: one agent ID per line in tree traversal order
get_agent_ids_tree_order() {
    local tmpfile="$1"

    if [[ ! -s "$tmpfile" ]]; then
        return
    fi

    # Helper to get children of a manager
    _tree_get_children() {
        local manager_id="$1"
        grep "|${manager_id}|" "$tmpfile" | cut -d'|' -f1
    }

    # Recursive helper to emit agent IDs in tree order
    _tree_emit() {
        local id="$1"
        echo "$id"
        local children=$(_tree_get_children "$id")
        for child in $children; do
            _tree_emit "$child"
        done
    }

    # Find root agents (those with no parent OR whose parent doesn't exist)
    local all_ids=$(cut -d'|' -f1 "$tmpfile")
    local roots=""
    while IFS='|' read -r id parent _rest; do
        if [[ -z "$parent" ]]; then
            roots="$roots $id"
        else
            if ! echo "$all_ids" | grep -q "^${parent}$"; then
                roots="$roots $id"
            fi
        fi
    done < "$tmpfile"
    roots="${roots# }"

    for root in $roots; do
        _tree_emit "$root"
    done
}

# Build tree lines with formatting (pipe-delimited for column alignment)
# Args: $1 = tmpfile from build_agent_data_file
# Outputs: formatted tree lines, one per line
# Caller should pipe through: column -t -s '|'
build_tree_lines() {
    local tmpfile="$1"

    if [[ ! -s "$tmpfile" ]]; then
        return
    fi

    # Helper to get agent info from tmpfile
    _tree_get_agent_info() {
        local lookup_id="$1"
        grep "^${lookup_id}|" "$tmpfile" | head -1
    }

    # Helper to get children of a manager
    _tree_get_children_for_print() {
        local manager_id="$1"
        grep "|${manager_id}|" "$tmpfile" | cut -d'|' -f1
    }

    # Recursive function to print tree
    _tree_print_node() {
        local id="$1"
        local prefix="$2"
        local is_last="$3"

        # Get agent info
        local info=$(_tree_get_agent_info "$id")
        local state=$(echo "$info" | cut -d'|' -f3)
        local age=$(echo "$info" | cut -d'|' -f4)
        local model=$(echo "$info" | cut -d'|' -f5)
        local prompt=$(echo "$info" | cut -d'|' -f6-)

        # Print this node with aligned columns
        local connector child_prefix tree_part
        if [[ -z "$prefix" ]]; then
            # Root node - no prefix/connector
            tree_part="$id"
            child_prefix="."
        elif [[ "$prefix" == "." ]]; then
            # First level child
            connector="├──"
            child_prefix="│   "
            if [[ "$is_last" == "true" ]]; then
                connector="└──"
                child_prefix="    "
            fi
            tree_part="$connector $id"
        else
            # Deeper level
            connector="├──"
            child_prefix="${prefix}│   "
            if [[ "$is_last" == "true" ]]; then
                connector="└──"
                child_prefix="${prefix}    "
            fi
            tree_part="$prefix$connector $id"
        fi

        # Format: tree_part | state | age | model | (orphan note) | prompt
        echo "${tree_part}|${state}|${age}|${model}||${prompt}"

        # Print children
        local children=$(_tree_get_children_for_print "$id")
        if [[ -n "$children" ]]; then
            local child_array=($children)
            local child_count=${#child_array[@]}
            local i=0
            for child in "${child_array[@]}"; do
                i=$((i + 1))
                local child_is_last="false"
                if [[ $i -eq $child_count ]]; then
                    child_is_last="true"
                fi
                _tree_print_node "$child" "$child_prefix" "$child_is_last"
            done
        fi
    }

    # Find roots
    local all_ids=$(cut -d'|' -f1 "$tmpfile")
    local roots=""
    while IFS='|' read -r id parent _rest; do
        if [[ -z "$parent" ]]; then
            roots="$roots $id"
        else
            if ! echo "$all_ids" | grep -q "^${parent}$"; then
                roots="$roots $id"
            fi
        fi
    done < "$tmpfile"
    roots="${roots# }"

    # Print each root and its tree
    local root_array=($roots)
    local root_count=${#root_array[@]}
    local i=0
    for root in "${root_array[@]}"; do
        i=$((i + 1))
        local is_last="false"
        if [[ $i -eq $root_count && $root_count -gt 1 ]]; then
            is_last="true"
        fi
        _tree_print_node "$root" "" "$is_last"
        # Add blank line between trees if multiple roots
        if [[ $i -lt $root_count ]]; then
            echo ""
        fi
    done
}

# =============================================================================
# COMMAND: new-agent
# =============================================================================

cmd_new_agent() {
    local NAME=""
    local MANAGER=""
    local USE_WORKTREE=true
    local ALLOW_TOOLS=""
    local DENY_TOOLS=""
    local PRINT_MODE=false
    local YOLO_MODE=false
    local WORKER_MODE=false
    local MODEL=""
    local PROMPT=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --name)        NAME="$2"; shift 2 ;;
            --manager|--parent)      MANAGER="$2"; shift 2 ;;
            --no-worktree) USE_WORKTREE=false; shift ;;
            --allow-tools) ALLOW_TOOLS="$2"; shift 2 ;;
            --deny-tools)  DENY_TOOLS="$2"; shift 2 ;;
            --print)       PRINT_MODE=true; shift ;;
            --yolo)        YOLO_MODE=true; shift ;;
            --worker|--leaf) WORKER_MODE=true; shift ;;
            --model)       MODEL="$2"; shift 2 ;;
            -h|--help)
                cat <<EOF
Usage: ib new-agent [options] "prompt"

Start a new Claude agent with the given prompt.

Must be run from the root of a git repository. By default, each agent gets
its own git worktree and branch for isolated work.

Options:
  --name NAME           Custom agent name (default: auto-generated)
  --manager ID          Manager agent ID (for hierarchy tracking)
  --no-worktree         Work in repo root instead of isolated worktree
  --allow-tools LIST    Only allow these tools (comma-separated)
  --deny-tools LIST     Deny these tools (comma-separated)
  --print               Run in one-shot mode (no interaction)
  --yolo                Skip all permission prompts (full autonomy)
  --worker              Create a worker agent (no sub-agent spawning)
  --model MODEL         Claude model to use (e.g., opus, sonnet, haiku)
  -h, --help            Show this help

Permission modes:
  (default)   Auto-rejects non-allowed tools, auto-accepts workspace trust
  --yolo      Auto-accepts everything (full autonomy, use with caution)

Agent types:
  (default)   Manager agent - can spawn and manage sub-agents via 'ib' commands
  --worker    Worker agent - cannot spawn sub-agents, focused on task execution

Configuration:
  Create .ittybitty.json in your repo root to configure agent permissions:

    {
      "maxAgents": 10,
      "model": "sonnet",
      "permissions": {
        "manager": { "allow": ["Read", "Write", "Edit"], "deny": [] },
        "worker": { "allow": ["Read", "Write"], "deny": [] }
      }
    }

  - maxAgents: Maximum number of concurrent agents (default: 10)
  - model: Default Claude model for spawned agents (e.g., opus, sonnet, haiku)
           Overridden by --model parameter if provided
  - permissions.manager: Applied to manager (coordinator) agents
  - permissions.worker: Applied to worker agents
  - Bash(ib:*) is always added for agent coordination
  - Base settings from .claude/settings.local.json are merged in

Examples:
  ib new-agent "verify citations in vs-freeform.md"
  ib new-agent --name checker "research and summarize"
  ib new --yolo "research and update the pricing page"
  ib new --worker --manager coordinator "check link #1"
  ib new --model sonnet "quick task for a faster model"
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                PROMPT="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$PROMPT" ]]; then
        echo "Error: prompt required" >&2
        echo "Usage: ib new-agent [options] \"prompt\"" >&2
        exit 1
    fi

    # Verify we're in a git repo
    if [[ -z "$ROOT_REPO_PATH" ]]; then
        echo "Error: must be run from within a git repository" >&2
        exit 1
    fi

    # Auto-detect manager if not explicitly set and we're in an agent worktree
    if [[ -z "$MANAGER" ]]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == *"/.ittybitty/agents/"*"/repo"* ]]; then
            # Find the agent directory and read meta.json
            local agent_dir=$(echo "$current_dir" | sed 's|\(.*/.ittybitty/agents/[^/]*\)/repo.*|\1|')
            if [[ -f "$agent_dir/meta.json" ]]; then
                MANAGER=$(jq -r '.id // ""' "$agent_dir/meta.json" 2>/dev/null)
            fi
        fi
    fi

    # Validate manager ID if provided
    if [[ -n "$MANAGER" ]]; then
        # Try to resolve the manager ID (supports partial IDs)
        local RESOLVED_MANAGER=$(resolve_agent_id "$MANAGER" 2>/dev/null)
        if [[ -z "$RESOLVED_MANAGER" ]]; then
            echo "Error: Manager agent '$MANAGER' not found" >&2
            echo "" >&2
            echo "Run 'ib list' to see available agents." >&2
            exit 1
        fi
        MANAGER="$RESOLVED_MANAGER"

        # Check if the manager is a worker agent
        local MANAGER_DIR="$AGENTS_DIR/$MANAGER"
        local is_worker=$(jq -r '.worker // false' "$MANAGER_DIR/meta.json" 2>/dev/null)
        if [[ "$is_worker" == "true" ]]; then
            echo "Error: '$MANAGER' is a worker agent and cannot manage sub-agents" >&2
            echo "" >&2
            echo "Worker agents are created with --worker and cannot spawn sub-agents." >&2
            echo "Only manager agents can have children." >&2
            exit 1
        fi
    fi

    # Load config for PR settings
    load_config

    # Apply model from config if not specified via --model parameter
    if [[ -z "$MODEL" && -n "$CONFIG_MODEL" ]]; then
        MODEL="$CONFIG_MODEL"
    fi

    # Check max agents limit
    local current_agent_count=$(count_agents)
    if [[ "$current_agent_count" -ge "$CONFIG_MAX_AGENTS" ]]; then
        echo "Error: Maximum agent limit reached ($current_agent_count/$CONFIG_MAX_AGENTS agents)" >&2
        echo "" >&2
        echo "This is a safety limit for the entire repository to prevent runaway agent spawning." >&2
        echo "You can:" >&2
        echo "  1. Check 'ib list' - if you have completed subagents, merge or kill them" >&2
        echo "  2. Wait until agents have completed before trying to create new ones" >&2
        echo "  3. Ask the user to increase the limit in .ittybitty.json (default: $CONFIG_MAX_AGENTS)" >&2
        exit 1
    fi

    # Generate agent ID
    local ID
    if [[ -n "$NAME" ]]; then
        ID="$NAME"
    else
        ID="agent-$(openssl rand -hex 4)"
    fi

    # Check if agent already exists
    local TMUX_SESSION=$(session_name "$ID")
    if [[ -d "$AGENTS_DIR/$ID" ]] || tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        echo "Error: agent '$ID' already exists" >&2
        exit 1
    fi

    # Set up directories in root repo
    local AGENT_DIR="$AGENTS_DIR/$ID"
    mkdir -p "$AGENT_DIR"

    # Set working directory (default to root repo)
    local WORK_PATH="$ROOT_REPO_PATH"

    # Create git worktree if requested
    if [[ "$USE_WORKTREE" == true ]]; then
        local BRANCH_NAME="agent/$ID"
        # Create worktree from root repo, branching from current HEAD
        git -C "$ROOT_REPO_PATH" worktree add "$AGENT_DIR/repo" -b "$BRANCH_NAME" HEAD || {
            echo "Error: could not create worktree" >&2
            rm -rf "$AGENT_DIR"
            exit 1
        }
        WORK_PATH="$AGENT_DIR/repo"

        # Build agent settings with permissions from .ittybitty.json config
        mkdir -p "$AGENT_DIR/repo/.claude"
        local agent_type="manager"
        if [[ "$WORKER_MODE" == true ]]; then
            agent_type="worker"
        fi

        if command -v jq &>/dev/null; then
            # Run build_agent_settings from root repo context
            (cd "$ROOT_REPO_PATH" && build_agent_settings "$agent_type") > "$AGENT_DIR/repo/.claude/settings.local.json"
            # Replace agent ID placeholder in hook configuration
            sed -i '' "s|__AGENT_ID__|$ID|g" "$AGENT_DIR/repo/.claude/settings.local.json"
        else
            # Fallback: minimal settings if jq not available
            if [[ -f "$ROOT_REPO_PATH/.claude/settings.local.json" ]]; then
                cp "$ROOT_REPO_PATH/.claude/settings.local.json" "$AGENT_DIR/repo/.claude/"
            else
                echo '{"permissions":{"allow":["Bash(ib:*)","Bash(./ib:*)"]}}' > "$AGENT_DIR/repo/.claude/settings.local.json"
            fi
        fi
    else
        # Non-worktree mode: ensure ib permissions are in root repo settings
        local ROOT_SETTINGS="$ROOT_REPO_PATH/.claude/settings.local.json"
        if command -v jq &>/dev/null && [[ -f "$ROOT_SETTINGS" ]]; then
            # Check if both patterns are already allowed
            local needs_update=false
            if ! jq -e '.permissions.allow | index("Bash(ib:*)")' "$ROOT_SETTINGS" &>/dev/null; then
                needs_update=true
            fi
            if ! jq -e '.permissions.allow | index("Bash(./ib:*)")' "$ROOT_SETTINGS" &>/dev/null; then
                needs_update=true
            fi
            if [[ "$needs_update" == true ]]; then
                local tmp=$(mktemp)
                jq '.permissions.allow += ["Bash(ib:*)", "Bash(./ib:*)"] | .permissions.allow |= unique' \
                    "$ROOT_SETTINGS" > "$tmp" && mv "$tmp" "$ROOT_SETTINGS"
                echo "Added Bash(ib:*) and Bash(./ib:*) to .claude/settings.local.json" >&2
            fi
        elif [[ ! -f "$ROOT_SETTINGS" ]]; then
            mkdir -p "$ROOT_REPO_PATH/.claude"
            echo '{"permissions":{"allow":["Bash(ib:*)","Bash(./ib:*)"]}}' > "$ROOT_SETTINGS"
            echo "Created .claude/settings.local.json with ib allowed" >&2
        fi
    fi

    # Generate a UUID for the Claude session (enables resume if tmux dies)
    local SESSION_UUID=$(uuidgen | tr '[:upper:]' '[:lower:]')

    # Write metadata
    cat > "$AGENT_DIR/meta.json" <<EOF
{
  "id": "$ID",
  "session_id": "$SESSION_UUID",
  "prompt": $(echo "$PROMPT" | jq -Rs .),
  "manager": $(if [[ -n "$MANAGER" ]]; then echo "\"$MANAGER\""; else echo "null"; fi),
  "created": "$(date -Iseconds)",
  "worktree": $USE_WORKTREE,
  "worker": $WORKER_MODE,
  "model": $(if [[ -n "$MODEL" ]]; then echo "\"$MODEL\""; else echo "null"; fi)
}
EOF

    # Log agent creation
    if [[ -n "$MANAGER" ]]; then
        log_agent "$ID" "Agent created (manager: $MANAGER, prompt: $PROMPT)" --quiet
    else
        log_agent "$ID" "Agent created (prompt: $PROMPT)" --quiet
    fi

    # Build prompt with context prefix
    local MANAGER_INFO=""
    if [[ -n "$MANAGER" ]]; then
        MANAGER_INFO="Your manager agent is: $MANAGER"
    fi

    local WORKTREE_INFO=""
    local COMPLETION_INSTRUCTIONS=""
    if [[ "$USE_WORKTREE" == true ]]; then
        WORKTREE_INFO="You are running as agent $ID in a git worktree on branch agent/$ID."
        if [[ "$WORKER_MODE" == true ]]; then
            COMPLETION_INSTRUCTIONS="State Management:
- Whenever you stop working and are idle, you must end your message with either:
  - 'WAITING' - if waiting for input or have nothing more to do without further instruction
  - 'I HAVE COMPLETED THE GOAL' - if you have completed your task

When your task is complete:
1. Commit any changes you made (git add && git commit)
2. Say the exact phrase: \"I HAVE COMPLETED THE GOAL\"
   This signals to your manager agent that you are done.
3. Wait for your manager to merge or kill your session."
        else
            # Determine PR instructions based on config and gh availability
            local PR_INSTRUCTIONS=""
            local HAS_GH=$(command -v gh &>/dev/null && echo "true" || echo "false")
            local HAS_REMOTE=$(git remote 2>/dev/null | head -1)

            if [[ "$CONFIG_CREATE_PRS" == "true" && "$HAS_GH" == "true" && -n "$HAS_REMOTE" ]]; then
                PR_INSTRUCTIONS="Once you have completed your primary goal by merging in successful agents, double check that you have completed the goal.
If so:
1. Create a pull request with \`gh pr create --title \"<title>\" --body \"<description>\"\`
2. Say the exact phrase: \"I HAVE COMPLETED THE GOAL\"
This phrase signals to the orchestrator that you are done."
            else
                PR_INSTRUCTIONS="Once you have completed your primary goal by merging in successful agents, double check that you have completed the goal.
If so, say the exact phrase: \"I HAVE COMPLETED THE GOAL\"
This phrase signals to the orchestrator that you are done.
Your work is on branch \`agent/$ID\` for review."
            fi

            COMPLETION_INSTRUCTIONS="State Management:
- Whenever you stop working and are idle, you must end your message with either:
  - 'WAITING' - if waiting for next monitoring cycle or have nothing more to do
  - 'I HAVE COMPLETED THE GOAL' - if you have completed your primary goal

Your workflow:
CRITICAL: Before spawning ANY sub-agents, you MUST define clear, objective completion criteria for each task.
You need these criteria to judge whether a sub-agent has truly completed its work when it signals completion.

1. Break down the goal into specific tasks with measurable completion criteria
   - What files should be changed? What should the output look like?
   - What specific conditions define \"done\"? (tests pass, specific files exist, specific content present, etc.)
   - Track these tasks and criteria in your Claude Code tasks tracker (TodoWrite tool)
2. Spawn WORKER sub-agents (--worker) for each independent task
   - Provide the specific task AND the clear completion criteria in the prompt
   - Default to --worker unless the sub-agent itself needs to coordinate multiple parallel sub-agents
3. Enter WAITING mode - watchdogs will notify you when sub-agents need attention
4. When notified, review sub-agent work against your predefined completion criteria:
   - Use \`ib look <agent-id>\` to see what the agent reports
   - Use \`ib status <agent-id>\` to see the agent's commits
   - Use \`ib diff <agent-id>\` to verify the actual changes match your criteria
   - If criteria met: \`ib merge <agent-id>\` or \`ib kill <agent-id>\` (if no changes needed)
   - If criteria NOT met: \`ib send <agent-id> \"message\"\` explaining what's missing and how to fix it
   - If a sub-agent is \`stopped\`, STOP and notify the user immediately
5. When merging successful agents, commit any changes you made directly (git add && git commit).
6. BEFORE completing: You MUST merge or kill ALL sub-agents. Use \`ib list\` to verify no children remain in running, waiting, or complete state.

$PR_INSTRUCTIONS"
        fi
    else
        WORKTREE_INFO="You are running as agent $ID in the main repository (no worktree)."
        COMPLETION_INSTRUCTIONS="When your task is complete:
1. Commit any changes you made (git add && git commit)
2. Exit normally"
    fi

    local IB_INSTRUCTIONS=""
    if [[ "$WORKER_MODE" != true ]]; then
        IB_INSTRUCTIONS="
You have access to the 'ib' tool for multi-agent coordination.
IMPORTANT: Always use 'ib' (not './ib') to ensure you use the current version from PATH.

  ib new-agent --manager $ID --worker \"task\"   Spawn a worker sub-agent (focused worker, no sub-agents)
  ib list --manager $ID                          List your sub-agents
  ib look <agent-id>                             Read an agent's output
  ib send <agent-id> \"message\"                  Send input to an agent
  ib status <agent-id>                           Check agent's git commits
  ib merge <agent-id>                            Merge agent's work and close it
  ib kill <agent-id>                             Stop an agent without merging

TASK SIZING STRATEGY:
When you receive a task, think about what is needed to accomplish it, then decide:

  SMALL TASK (do yourself)
    - One agent can finish quickly
    - Just do the task yourself - don't spawn sub-agents unnecessarily

  MEDIUM TASK (2-3 parallel worker agents)
    - Can be split into 2-3 independent subtasks
    - Spawn WORKER agents to work in parallel (always use --worker unless sub-agent needs to manage its own sub-agents)
    - After spawning them, enter WAITING mode - you'll be notified when they complete

  LARGE TASK (multiple stages)
    - Requires multiple stages that must run serially
    - Use TodoWrite tool to track stages
    - For each stage, spawn WORKER agents to work in parallel (always use --worker)
    - After spawning agents for a stage, enter WAITING mode
    - When notified of completion, review work and move to next stage

AUTOMATIC NOTIFICATIONS:
  - A watchdog monitors each sub-agent you spawn
  - You will be notified when sub-agents complete OR when they need help
  - Once you've created agents to work, enter WAITING mode - don't poll 'ib list'
  - The watchdog ensures you're woken up when action is needed

If \`ib merge\` fails due to conflicts, choose the best strategy:
1. Resolve the merge yourself: edit conflicting files, \`git add <files> && git commit\`, then clean up with \`git worktree remove <path> --force && git branch -D agent/<id>\`
2. Spawn a WORKER sub-agent to handle the merge resolution, then monitor it to completion
3. If the merge is no longer needed, skip it and note this in your final report
"
    else
        # Worker agents: simple communication with manager only
        IB_INSTRUCTIONS="
You are a worker agent focused on your specific task.
IMPORTANT: Always use 'ib' (not './ib') to ensure you use the current version from PATH.

To communicate with your manager: ib send $MANAGER \"your message\"

Use this to:
- Report completion or progress
- Ask questions if requirements are unclear
- Share important findings

If you get stuck or encounter a blocker:
1. Describe the specific problem you're facing
2. Send a message to your manager: ib send $MANAGER \"[STUCK] <description of problem>\"
3. Enter WAITING state
4. Your watchdog will notify your manager that you need help
"
    fi

    # Add role identifier for spawned agents
    local ROLE_MARKER=""
    if [[ "$WORKER_MODE" == true ]]; then
        ROLE_MARKER="<ittybitty>You are an IttyBitty worker agent.</ittybitty>

"
    else
        ROLE_MARKER="<ittybitty>You are an IttyBitty manager agent.</ittybitty>

"
    fi

    local PROMPT_PREFIX="${ROLE_MARKER}[AGENT CONTEXT]
$WORKTREE_INFO
$MANAGER_INFO
$IB_INSTRUCTIONS
$COMPLETION_INSTRUCTIONS

[USER TASK]
$PROMPT"

    # Save the full prompt (with prefix) for reference
    local PROMPT_FILE="$AGENT_DIR/prompt.txt"
    echo "$PROMPT_PREFIX" > "$PROMPT_FILE"

    # Build claude command arguments
    # Note: We don't use --permission-mode dontAsk because we want the
    # PermissionRequest hook to fire for non-allowed tools (to log and deny)
    local CLAUDE_ARGS=""
    if [[ "$YOLO_MODE" == true ]]; then
        CLAUDE_ARGS="--dangerously-skip-permissions --permission-mode bypassPermissions"
    fi
    if [[ "$PRINT_MODE" == true ]]; then
        CLAUDE_ARGS="$CLAUDE_ARGS --print"
    fi
    if [[ -n "$ALLOW_TOOLS" ]]; then
        CLAUDE_ARGS="$CLAUDE_ARGS --allowedTools $ALLOW_TOOLS"
    fi
    if [[ -n "$DENY_TOOLS" ]]; then
        CLAUDE_ARGS="$CLAUDE_ARGS --disallowedTools $DENY_TOOLS"
    fi
    if [[ -n "$MODEL" ]]; then
        CLAUDE_ARGS="$CLAUDE_ARGS --model $MODEL"
    fi

    # Build exit handler script
    local EXIT_SCRIPT="$AGENT_DIR/exit-check.sh"
    cat > "$EXIT_SCRIPT" <<'EXITSCRIPT'
#!/bin/bash
echo ""
echo "═══════════════════════════════════════════════════════════"
echo "  Agent session ended - checking for uncommitted work..."
echo "═══════════════════════════════════════════════════════════"

# Check for uncommitted changes
if [[ -n $(git status --porcelain 2>/dev/null) ]]; then
    echo ""
    echo "⚠️  UNCOMMITTED CHANGES DETECTED"
    echo ""
    git status --short
    echo ""
    read -p "Commit these changes? [y/N] " commit_confirm
    if [[ "$commit_confirm" == [yY] || "$commit_confirm" == [yY][eE][sS] ]]; then
        read -p "Commit message: " commit_msg
        if [[ -n "$commit_msg" ]]; then
            git add -A && git commit -m "$commit_msg"
        else
            echo "No message provided, skipping commit."
        fi
    fi
fi

# Check for unpushed commits (only if remote exists)
if git remote | grep -q .; then
    local_commits=$(git log @{u}..HEAD --oneline 2>/dev/null | wc -l | tr -d ' ')
    if [[ "$local_commits" -gt 0 ]]; then
        echo ""
        echo "⚠️  UNPUSHED COMMITS: $local_commits commit(s) not pushed to remote"
        echo ""
        git log @{u}..HEAD --oneline
        echo ""
        read -p "Push to remote? [y/N] " push_confirm
        if [[ "$push_confirm" == [yY] || "$push_confirm" == [yY][eE][sS] ]]; then
            git push
        fi
    fi
fi

echo ""
echo "Agent session complete. Branch: $(git branch --show-current)"
echo "To merge this work: git checkout main && git merge $(git branch --show-current)"
echo ""
EXITSCRIPT
    chmod +x "$EXIT_SCRIPT"

    # Write a startup script that handles the prompt properly
    # Use absolute paths since tmux runs from the worktree directory
    local ABS_AGENT_DIR="$(cd "$AGENT_DIR" && pwd)"
    local ABS_PROMPT_FILE="$ABS_AGENT_DIR/prompt.txt"
    local ABS_EXIT_SCRIPT="$ABS_AGENT_DIR/exit-check.sh"
    local GIT_ROOT="$ROOT_REPO_PATH"  # Root repo path (for PATH so 'ib' is available)
    local STARTUP_SCRIPT="$AGENT_DIR/start.sh"
    cat > "$STARTUP_SCRIPT" <<EOF
#!/bin/bash
# Add git repo root to PATH so 'ib' is available
export PATH="$GIT_ROOT:\$PATH"

# Start Claude in background and capture PID
claude --session-id "$SESSION_UUID" $CLAUDE_ARGS "\$(cat '$ABS_PROMPT_FILE')" &
CLAUDE_PID=\$!

# Store PID in meta.json for recovery if needed
if command -v jq &>/dev/null; then
    TMP_FILE="\$(mktemp)"
    jq --arg pid "\$CLAUDE_PID" '. + {claude_pid: \$pid}' "$ABS_AGENT_DIR/meta.json" > "\$TMP_FILE" && mv "\$TMP_FILE" "$ABS_AGENT_DIR/meta.json"
fi

# Wait for Claude to complete
wait \$CLAUDE_PID

# Run exit check
$ABS_EXIT_SCRIPT
EOF
    chmod +x "$STARTUP_SCRIPT"

    # Ensure tmux server is running (start-server is idempotent)
    if ! tmux start-server 2>/dev/null; then
        echo "Error: could not start tmux server" >&2
        echo "Make sure tmux is installed: brew install tmux" >&2
        rm -rf "$AGENT_DIR"
        if [[ "$USE_WORKTREE" == true ]]; then
            git -C "$ROOT_REPO_PATH" worktree remove "$AGENT_DIR/repo" --force 2>/dev/null || true
            git -C "$ROOT_REPO_PATH" branch -D "$BRANCH_NAME" 2>/dev/null || true
        fi
        exit 1
    fi

    # Start tmux session with startup script (use absolute path)
    local ABS_STARTUP_SCRIPT="$ABS_AGENT_DIR/start.sh"
    if ! tmux new-session -d -x "$TMUX_WIDTH" -s "$TMUX_SESSION" -c "$WORK_PATH" "$ABS_STARTUP_SCRIPT"; then
        echo "Error: could not create tmux session '$TMUX_SESSION'" >&2
        echo "Try running: tmux kill-server && tmux start-server" >&2
        rm -rf "$AGENT_DIR"
        if [[ "$USE_WORKTREE" == true ]]; then
            git -C "$ROOT_REPO_PATH" worktree remove "$AGENT_DIR/repo" --force 2>/dev/null || true
            git -C "$ROOT_REPO_PATH" branch -D "$BRANCH_NAME" 2>/dev/null || true
        fi
        exit 1
    fi

    # Verify session was created
    if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        echo "Error: tmux session '$TMUX_SESSION' failed to start" >&2
        rm -rf "$AGENT_DIR"
        if [[ "$USE_WORKTREE" == true ]]; then
            git -C "$ROOT_REPO_PATH" worktree remove "$AGENT_DIR/repo" --force 2>/dev/null || true
            git -C "$ROOT_REPO_PATH" branch -D "$BRANCH_NAME" 2>/dev/null || true
        fi
        exit 1
    fi

    # For non-yolo mode, auto-accept the workspace trust dialog
    # (yolo bypasses this entirely, but default and strict still see it)
    if [[ "$YOLO_MODE" != true ]]; then
        auto_accept_workspace_trust "$TMUX_SESSION"
    fi

    # Auto-spawn watchdog if agent has a manager
    if [[ -n "$MANAGER" ]]; then
        ib watchdog "$ID" > "$AGENT_DIR/watchdog.log" 2>&1 &
    fi

    # Output the agent ID
    echo "$ID"
}

# =============================================================================
# COMMAND: list
# =============================================================================

cmd_list() {
    local MANAGER_FILTER=""
    local JSON_OUTPUT=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --manager|--parent)  MANAGER_FILTER="$2"; shift 2 ;;
            --json)    JSON_OUTPUT=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib list [options]

Show all agents and their state.

Options:
  --manager ID          Only show children of this agent
  --json                Output as JSON
  -h, --help            Show this help

Output columns:
  ID        Agent identifier
  STATE     running, waiting, complete, or stopped
  AGE       Time since spawn
  MODEL     Claude model being used
  MANAGER   Manager agent ID (if any)
  PROMPT    First 40 chars of prompt

States:
  running   Agent is actively processing
  waiting   Agent is idle, may need input
  complete  Agent has signaled task completion (merge or kill to close)
  stopped   Session ended unexpectedly, needs user intervention

Orphan Detection:
  This command also checks for orphaned tmux sessions - sessions that exist
  but have no matching agent data. Orphans are shown as warnings.
EOF
                exit 0
                ;;
            *)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
        esac
    done

    # Check if agents directory exists
    if [[ ! -d "$AGENTS_DIR" ]]; then
        if [[ "$JSON_OUTPUT" == true ]]; then
            echo "[]"
        else
            echo "No agents found."
        fi
        exit 0
    fi

    # Collect agent data
    local agents=()
    local agent_lines=()
    local found_any=false
    local orphaned_dirs=()

    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue

        # Track orphaned directories (no meta.json)
        if [[ ! -f "$agent_dir/meta.json" ]]; then
            orphaned_dirs+=("$(basename "$agent_dir")")
            continue
        fi

        local id=$(basename "$agent_dir")
        local meta="$agent_dir/meta.json"

        # Read metadata
        local prompt=$(jq -r '.prompt // ""' "$meta" 2>/dev/null | head -1 | cut -c1-40)
        local manager=$(jq -r '.manager // ""' "$meta" 2>/dev/null)
        local created=$(jq -r '.created // ""' "$meta" 2>/dev/null)
        local model=$(jq -r '.model // ""' "$meta" 2>/dev/null)
        if [[ "$model" == "null" || -z "$model" ]]; then
            model="-"
        fi

        # Filter by manager if requested
        if [[ -n "$MANAGER_FILTER" && "$manager" != "$MANAGER_FILTER" ]]; then
            continue
        fi

        # Get state
        local state=$(get_state "$id")

        found_any=true

        # Format age
        local age=$(format_age "$created")

        # Handle null manager for display
        if [[ "$manager" == "null" || -z "$manager" ]]; then
            manager="-"
        fi

        # Display "unknown" as "waiting" for users
        local display_state="$state"
        if [[ "$state" == "unknown" ]]; then
            display_state="waiting"
        fi

        if [[ "$JSON_OUTPUT" == true ]]; then
            agents+=("{\"id\":\"$id\",\"state\":\"$state\",\"age\":\"$age\",\"manager\":\"$manager\",\"model\":\"$model\",\"prompt\":$(echo "$prompt" | jq -Rs .)}")
        else
            # Store pipe-delimited for column alignment
            agent_lines+=("${id}|${display_state}|${age}|${model}|${manager}|${prompt}")
        fi
    done

    # Print aligned table if not JSON
    if [[ "$JSON_OUTPUT" != true && ${#agent_lines[@]} -gt 0 ]]; then
        printf "%s\n" "${agent_lines[@]}" | column -t -s '|'
    fi

    # Check for orphaned tmux sessions (sessions without matching agent directories)
    # Only check sessions with our prefix to avoid warning about unrelated sessions
    local orphans=()
    local known_ids=()

    # Build list of known agent IDs
    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        known_ids+=("$(basename "$agent_dir")")
    done

    # Check our tmux sessions for orphans (only sessions with our prefix)
    while IFS= read -r session; do
        [[ -z "$session" ]] && continue
        # Skip sessions that don't have our prefix
        [[ "$session" != "${SESSION_PREFIX}"* ]] && continue
        # Extract agent ID from session name (strip prefix)
        local agent_id="${session#${SESSION_PREFIX}}"
        # Check if this session has a matching agent directory
        local is_known=false
        for known_id in "${known_ids[@]}"; do
            if [[ "$agent_id" == "$known_id" ]]; then
                is_known=true
                break
            fi
        done
        if [[ "$is_known" == false ]]; then
            orphans+=("$session")
        fi
    done < <(tmux list-sessions -F '#{session_name}' 2>/dev/null || true)

    # Show orphans if any
    if [[ ${#orphans[@]} -gt 0 ]]; then
        if [[ "$JSON_OUTPUT" != true ]]; then
            echo ""
            echo "WARNING: Found ${#orphans[@]} orphaned ib session(s) without agent data:"
            for orphan in "${orphans[@]}"; do
                printf "  %-20s (use 'tmux kill-session -t %s' to remove)\n" "$orphan" "$orphan"
            done
            echo ""
        fi
        found_any=true
    fi

    # Show orphaned directories if any
    if [[ ${#orphaned_dirs[@]} -gt 0 ]]; then
        if [[ "$JSON_OUTPUT" != true ]]; then
            echo ""
            echo "WARNING: Found ${#orphaned_dirs[@]} orphaned agent director(ies) without meta.json:"
            for orphan_dir in "${orphaned_dirs[@]}"; do
                printf "  %-20s (use 'rm -rf %s/%s' to remove)\n" "$orphan_dir" "$AGENTS_DIR" "$orphan_dir"
            done
            echo ""
        fi
        found_any=true
    fi

    if [[ "$JSON_OUTPUT" == true ]]; then
        echo "[$(IFS=,; echo "${agents[*]}")]"
    elif [[ "$found_any" != true ]]; then
        echo "No agents found."
    fi
}

# =============================================================================
# COMMAND: send
# =============================================================================

cmd_send() {
    local FROM_ID=""
    local TARGET_ID=""
    local MESSAGE=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --from)
                FROM_ID="$2"
                shift 2
                ;;
            -h|--help)
                cat <<EOF
Usage: ib send <id> "message"
       ib send <id> < file.txt
       echo "answer" | ib send <id>
       ib send --from <sender-id> <id> "message"

Send input to an agent's stdin.

Arguments:
  id          Agent identifier (recipient)
  message     Text to send (optional if piping)

Options:
  --from ID   Prefix message with "[sent by agent <ID>]: " (auto-detected in agent worktrees)
  -h, --help  Show this help

When run from within an agent's worktree, --from is automatically detected by
reading the agent's meta.json, so messages are prefixed with the sender's identity.

Examples:
  ib send task-a1b2 "Option 2 - just verify links"
  ib send task-a1b2 "yes"
  ib send --from worker-xyz manager-abc "I'm done with my task"
  echo "no" | ib send task-a1b2
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$TARGET_ID" ]]; then
                    TARGET_ID="$1"
                else
                    # Rest is the message
                    MESSAGE="$*"
                    break
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$TARGET_ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib send <id> \"message\"" >&2
        exit 1
    fi

    # Resolve partial ID
    local ID
    ID=$(resolve_agent_id "$TARGET_ID") || exit 1

    # Check if agent is running
    local TMUX_SESSION=$(session_name "$ID")
    if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        echo "Error: agent '$ID' is not running" >&2
        exit 1
    fi

    # Get message from remaining args or stdin
    if [[ -z "$MESSAGE" ]]; then
        if [[ ! -t 0 ]]; then
            MESSAGE=$(cat)
        else
            echo "Error: message required (as argument or via stdin)" >&2
            exit 1
        fi
    fi

    # Auto-detect if we're in an agent worktree (FROM_ID not already set)
    if [[ -z "$FROM_ID" ]]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == *"/.ittybitty/agents/"*"/repo"* ]]; then
            # Find the agent directory and read meta.json
            local agent_dir=$(echo "$current_dir" | sed 's|\(.*/.ittybitty/agents/[^/]*\)/repo.*|\1|')
            if [[ -f "$agent_dir/meta.json" ]]; then
                FROM_ID=$(jq -r '.id // ""' "$agent_dir/meta.json" 2>/dev/null)
            fi
        fi
    fi

    # Prefix message if FROM_ID is set (sent by an agent)
    if [[ -n "$FROM_ID" ]]; then
        MESSAGE="[sent by agent $FROM_ID]: $MESSAGE"
    fi

    # Send to tmux session
    # Send message first, then Enter separately with a tiny delay
    # This helps when the target agent is busy processing
    tmux send-keys -t "$TMUX_SESSION" "$MESSAGE"
    sleep 0.1
    tmux send-keys -t "$TMUX_SESSION" Enter

    # Log to recipient (quiet - goes to their log only)
    if [[ -n "$FROM_ID" ]]; then
        log_agent "$ID" "Received message from $FROM_ID: ${MESSAGE#\[sent by agent $FROM_ID\]: }" --quiet
    else
        log_agent "$ID" "Received message: $MESSAGE" --quiet
    fi

    # Log to sender and print confirmation
    if [[ -n "$FROM_ID" ]]; then
        log_agent "$FROM_ID" "Sent message to $ID: ${MESSAGE#\[sent by agent $FROM_ID\]: }"
    else
        # No sender agent, just print confirmation
        echo "Sent to $ID"
    fi
}

# =============================================================================
# COMMAND: look
# =============================================================================

cmd_look() {
    local ID=""
    local LINES=50
    local FOLLOW=false
    local SHOW_ALL=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --lines)   LINES="$2"; shift 2 ;;
            --all)     SHOW_ALL=true; shift ;;
            --follow)  FOLLOW=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib look <id> [options]

Look at an agent's recent output.

Arguments:
  id              Agent identifier

Options:
  --lines N       Number of lines (default: 50)
  --all           Full scrollback history
  --follow        Watch live (like tail -f)
  -h, --help      Show this help

Examples:
  ib look task-a1b2
  ib look task-a1b2 --lines 200
  ib look task-a1b2 --follow
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib look <id> [options]" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1
    local TMUX_SESSION=$(session_name "$ID")

    # Check if agent session exists
    if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        # Try to read from log if agent is done
        if [[ -f "$AGENTS_DIR/$ID/output.log" ]]; then
            echo "=== Agent finished, showing saved output ===" >&2
            if [[ "$SHOW_ALL" == true ]]; then
                cat "$AGENTS_DIR/$ID/output.log"
            else
                tail -n "$LINES" "$AGENTS_DIR/$ID/output.log"
            fi
            exit 0
        fi
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    if [[ "$FOLLOW" == true ]]; then
        echo "Attaching to $ID (Ctrl+b d to detach)..." >&2
        tmux attach -t "$TMUX_SESSION" -r
    else
        if [[ "$SHOW_ALL" == true ]]; then
            tmux capture-pane -t "$TMUX_SESSION" -p -S -
        else
            tmux capture-pane -t "$TMUX_SESSION" -p -S -"$LINES"
        fi
    fi
}

# =============================================================================
# COMMAND: status
# =============================================================================

cmd_status() {
    local ID=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib status <id>

Show git status of an agent's work compared to main branch.

Displays:
- Commits made by the agent (hash + message)
- Uncommitted changes in worktree
- Files changed summary

Arguments:
  id              Agent identifier

Examples:
  ib status task-a1b2
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib status <id>" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"
    local BRANCH_NAME="agent/$ID"

    # Check if agent exists
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Determine target branch for comparison
    local TARGET_BRANCH=""
    if git show-ref --verify --quiet refs/heads/main; then
        TARGET_BRANCH="main"
    elif git show-ref --verify --quiet refs/heads/master; then
        TARGET_BRANCH="master"
    else
        TARGET_BRANCH="HEAD"
    fi

    # Check if worktree exists
    local WORKTREE_PATH="$AGENT_DIR/repo"
    if [[ ! -d "$WORKTREE_PATH" ]]; then
        echo "Agent '$ID' has no worktree (created with --no-worktree)"
        echo ""
        # Show branch commits if branch exists
        if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
            local commit_count=$(git log "$TARGET_BRANCH..$BRANCH_NAME" --oneline 2>/dev/null | wc -l | tr -d ' ')
            if [[ "$commit_count" -gt 0 ]]; then
                echo "Commits on $BRANCH_NAME (vs $TARGET_BRANCH):"
                git log "$TARGET_BRANCH..$BRANCH_NAME" --oneline
            else
                echo "No commits on $BRANCH_NAME relative to $TARGET_BRANCH"
            fi
        fi
        exit 0
    fi

    echo "Agent: $ID"
    echo "Branch: $BRANCH_NAME"
    echo "Worktree: $WORKTREE_PATH"
    echo ""

    # Show commits
    if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        local commit_count=$(git log "$TARGET_BRANCH..$BRANCH_NAME" --oneline 2>/dev/null | wc -l | tr -d ' ')
        if [[ "$commit_count" -gt 0 ]]; then
            echo "═══ Commits ($commit_count) vs $TARGET_BRANCH ═══"
            git log "$TARGET_BRANCH..$BRANCH_NAME" --format="  %h %s"
            echo ""
        else
            echo "═══ No commits vs $TARGET_BRANCH ═══"
            echo ""
        fi
    fi

    # Show uncommitted changes
    local uncommitted=$(git -C "$WORKTREE_PATH" status --porcelain 2>/dev/null)
    if [[ -n "$uncommitted" ]]; then
        echo "═══ Uncommitted Changes ═══"
        git -C "$WORKTREE_PATH" status --short
        echo ""
    fi

    # Show file change summary
    if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        local files_changed=$(git diff --stat "$TARGET_BRANCH..$BRANCH_NAME" 2>/dev/null | tail -1)
        if [[ -n "$files_changed" && "$files_changed" != *"0 files changed"* ]]; then
            echo "═══ Files Changed ═══"
            echo "  $files_changed"
        fi
    fi
}

# =============================================================================
# COMMAND: diff
# =============================================================================

cmd_diff() {
    local ID=""
    local STAT_ONLY=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --stat)    STAT_ONLY=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib diff <id> [options]

Show the full diff of an agent's work compared to main branch.

Arguments:
  id              Agent identifier

Options:
  --stat          Show diffstat summary only
  -h, --help      Show this help

Examples:
  ib diff task-a1b2
  ib diff task-a1b2 --stat
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib diff <id>" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"
    local BRANCH_NAME="agent/$ID"

    # Check if agent exists
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Determine target branch for comparison
    local TARGET_BRANCH=""
    if git show-ref --verify --quiet refs/heads/main; then
        TARGET_BRANCH="main"
    elif git show-ref --verify --quiet refs/heads/master; then
        TARGET_BRANCH="master"
    else
        TARGET_BRANCH="HEAD"
    fi

    # Check if branch exists
    if ! git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        echo "Error: branch '$BRANCH_NAME' does not exist" >&2
        exit 1
    fi

    if [[ "$STAT_ONLY" == true ]]; then
        git diff --stat "$TARGET_BRANCH..$BRANCH_NAME"
    else
        git diff "$TARGET_BRANCH..$BRANCH_NAME"
    fi
}

# =============================================================================
# COMMAND: kill
# =============================================================================

cmd_kill() {
    local ID=""
    local FORCE=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)   FORCE=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib kill <id> [options]

Close an agent without merging its work. Removes the agent's session,
worktree, branch, and data directory.

Arguments:
  id              Agent identifier

Options:
  --force         Don't ask for confirmation
  -h, --help      Show this help

Examples:
  ib kill task-a1b2
  ib kill task-a1b2 --force
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib kill <id> [options]" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"
    local TMUX_SESSION=$(session_name "$ID")

    # Check if agent exists at all
    if [[ ! -d "$AGENT_DIR" ]] && ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Confirm if not forced
    if [[ "$FORCE" != true ]]; then
        # If running as an agent, error instead of blocking on interactive prompt
        if is_running_as_agent; then
            echo "Error: Cannot use interactive confirmation in agent mode." >&2
            echo "Use: ib kill $ID --force" >&2
            exit 1
        fi
        local confirm
        read -p "Kill agent '$ID' and remove all data? [y/N] " confirm
        if [[ "$confirm" != [yY] && "$confirm" != [yY][eE][sS] ]]; then
            echo "Cancelled."
            exit 0
        fi
    fi

    # Teardown the agent (logs, kills, archives, removes)
    teardown_agent "$ID" "" "Agent killed"
    echo "Closed agent: $ID"

    # Scan for any orphaned Claude processes after cleanup
    scan_and_kill_orphans
}

# =============================================================================
# COMMAND: nuke (undocumented safety switch)
# =============================================================================

cmd_nuke() {
    local FORCE=false
    local TARGET_ID=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)   FORCE=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib nuke [<id>] [options]

EMERGENCY STOP: Kill agents without merging.

Without ID: Kills ALL active agents immediately.
With ID:    Kills the specified agent and ALL its descendants recursively.

Arguments:
  id              Agent ID to nuke (along with all its children)

Options:
  --force         Don't ask for confirmation
  -h, --help      Show this help

Examples:
  ib nuke                    # Kill ALL agents
  ib nuke manager-agent      # Kill manager-agent and all its children/grandchildren
  ib nuke manager-agent --force
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$TARGET_ID" ]]; then
                    TARGET_ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    # Check if agents directory exists
    if [[ ! -d "$AGENTS_DIR" ]]; then
        echo "No agents found."
        exit 0
    fi

    # If TARGET_ID specified, resolve it and find all descendants
    local agents_to_kill=()
    if [[ -n "$TARGET_ID" ]]; then
        # Resolve partial ID
        TARGET_ID=$(resolve_agent_id "$TARGET_ID") || exit 1

        # Check if this is a worker agent (has no children)
        local AGENT_DIR="$AGENTS_DIR/$TARGET_ID"
        local is_worker=$(jq -r '.worker // false' "$AGENT_DIR/meta.json" 2>/dev/null)

        # Count children
        local child_count=0
        for agent_dir in "$AGENTS_DIR"/*/; do
            [[ -d "$agent_dir" ]] || continue
            [[ -f "$agent_dir/meta.json" ]] || continue
            local manager=$(jq -r '.manager // ""' "$agent_dir/meta.json" 2>/dev/null)
            if [[ "$manager" == "$TARGET_ID" ]]; then
                ((child_count++))
            fi
        done

        # Reject if this is a worker with no children
        if [[ "$is_worker" == "true" && $child_count -eq 0 ]]; then
            echo "Error: '$TARGET_ID' is a worker agent with no descendants." >&2
            echo "Use 'ib kill $TARGET_ID' instead to close a single agent." >&2
            echo "" >&2
            echo "The 'nuke' command is for killing manager agents along with all their descendants." >&2
            exit 1
        fi

        # Build list of all descendants recursively
        get_descendants() {
            local manager_id="$1"
            echo "$manager_id"  # Include the manager itself

            # Find all direct children
            for agent_dir in "$AGENTS_DIR"/*/; do
                [[ -d "$agent_dir" ]] || continue
                [[ -f "$agent_dir/meta.json" ]] || continue

                local id=$(basename "$agent_dir")
                local manager=$(jq -r '.manager // ""' "$agent_dir/meta.json" 2>/dev/null)
                if [[ "$manager" == "null" ]]; then
                    manager=""
                fi

                if [[ "$manager" == "$manager_id" ]]; then
                    # Recursively get this child's descendants
                    get_descendants "$id"
                fi
            done
        }

        # Get all descendants
        agents_to_kill=($(get_descendants "$TARGET_ID"))
        local agent_count=${#agents_to_kill[@]}

        if [[ $agent_count -eq 0 ]]; then
            echo "No agents found to kill."
            exit 0
        fi
    else
        # No TARGET_ID - kill all agents
        local agent_count=0
        for agent_dir in "$AGENTS_DIR"/*/; do
            [[ -d "$agent_dir" ]] || continue
            [[ -f "$agent_dir/meta.json" ]] || continue
            agents_to_kill+=($(basename "$agent_dir"))
            ((agent_count++))
        done

        # Note: Don't exit early if no agents found - continue to check for orphaned sessions
    fi

    # Confirm if not forced and there are agents to kill
    if [[ "$FORCE" != true && ${#agents_to_kill[@]} -gt 0 ]]; then
        # If running as an agent, error instead of blocking on interactive prompt
        if is_running_as_agent; then
            echo "Error: Cannot use interactive confirmation in agent mode." >&2
            echo "Use: ib nuke --force" >&2
            exit 1
        fi
        local confirm
        if [[ -n "$TARGET_ID" ]]; then
            echo "WARNING: This will kill agent '$TARGET_ID' and ${#agents_to_kill[@]} total agent(s) (including descendants) without merging!"
            echo "Agents to be killed:"
            for id in "${agents_to_kill[@]}"; do
                echo "  - $id"
            done
        else
            echo "WARNING: This will kill ALL ${#agents_to_kill[@]} agent(s) without merging!"
        fi
        read -p "Are you sure? [y/N] " confirm
        if [[ "$confirm" != [yY] && "$confirm" != [yY][eE][sS] ]]; then
            echo "Cancelled."
            exit 0
        fi
    fi

    # Kill agents if any found
    if [[ ${#agents_to_kill[@]} -gt 0 ]]; then
        echo "Killing ${#agents_to_kill[@]} agent(s)..."
    fi
    local killed=0
    local failed=0

    # Kill each agent in the list
    for id in "${agents_to_kill[@]}"; do
        [[ -d "$AGENTS_DIR/$id" ]] || continue

        echo -n "  Killing $id... "

        # Teardown the agent (quiet mode for batch)
        if teardown_agent "$id" "--quiet" "Agent nuked"; then
            echo "✓"
            ((killed++))
        else
            echo "✗"
            ((failed++))
        fi
    done

    # Clean up orphaned tmux sessions (sessions without agent directories)
    local orphans=()
    local known_ids=()

    # Build list of remaining known agent IDs
    for agent_dir in "$AGENTS_DIR"/*/; do
        [[ -d "$agent_dir" ]] || continue
        known_ids+=("$(basename "$agent_dir")")
    done

    # Check our tmux sessions for orphans (only sessions with our prefix)
    while IFS= read -r session; do
        [[ -z "$session" ]] && continue
        # Skip sessions that don't have our prefix
        [[ "$session" != "${SESSION_PREFIX}"* ]] && continue
        # Extract agent ID from session name (strip prefix)
        local agent_id="${session#${SESSION_PREFIX}}"
        # Check if this session has a matching agent directory
        local is_known=false
        for known_id in "${known_ids[@]}"; do
            if [[ "$agent_id" == "$known_id" ]]; then
                is_known=true
                break
            fi
        done
        if [[ "$is_known" == false ]]; then
            orphans+=("$session")
        fi
    done < <(tmux list-sessions -F '#{session_name}' 2>/dev/null || true)

    # Kill orphaned sessions if any found
    local orphans_killed=0
    if [[ ${#orphans[@]} -gt 0 ]]; then
        echo ""
        echo "Cleaning up ${#orphans[@]} orphaned tmux session(s)..."
        for orphan in "${orphans[@]}"; do
            echo -n "  Killing $orphan... "
            if tmux kill-session -t "$orphan" 2>/dev/null; then
                echo "✓"
                ((orphans_killed++))
            else
                echo "✗"
            fi
        done
    fi

    # Scan for any orphaned Claude processes after all cleanup
    if [[ $killed -gt 0 || $orphans_killed -gt 0 ]]; then
        echo ""
        echo "Scanning for orphaned Claude processes..."
        scan_and_kill_orphans
    fi

    # Print results
    if [[ $killed -eq 0 && $orphans_killed -eq 0 ]]; then
        echo "No agents or orphaned sessions found."
    else
        echo ""
        if [[ $killed -gt 0 && $orphans_killed -gt 0 ]]; then
            echo "Results: $killed agent(s) killed, $orphans_killed orphaned session(s) cleaned up, $failed failed"
        elif [[ $killed -gt 0 ]]; then
            echo "Results: $killed agent(s) killed, $failed failed"
        elif [[ $orphans_killed -gt 0 ]]; then
            echo "Results: $orphans_killed orphaned session(s) cleaned up"
        fi
    fi

    if [[ $failed -gt 0 ]]; then
        exit 1
    fi
}

# =============================================================================
# COMMAND: resume
# =============================================================================

cmd_resume() {
    local ID=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib resume <id>

Resume a stopped agent session.

When an agent's tmux session ends unexpectedly (crash, reboot, etc.),
the Claude conversation history is preserved. This command restarts
the tmux session and resumes the Claude conversation where it left off.

Arguments:
  id              Agent identifier

Requirements:
  - Agent must exist (directory in .ittybitty/agents/)
  - Agent must be stopped (no active tmux session)
  - Agent must have a session_id in meta.json

Examples:
  ib resume task-a1b2
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib resume <id>" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"

    # Check if agent exists
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Check agent state - must be stopped
    local state=$(get_state "$ID")
    if [[ "$state" != "stopped" ]]; then
        echo "Error: agent '$ID' is not stopped (current state: $state)" >&2
        case "$state" in
            running)
                echo "Agent is actively processing. Use 'ib look $ID' to view output." >&2
                ;;
            waiting)
                echo "Agent is waiting for input. Use 'ib send $ID \"message\"' to continue." >&2
                ;;
            complete)
                echo "Agent has completed. Use 'ib merge $ID' or 'ib kill $ID' to close it." >&2
                ;;
        esac
        exit 1
    fi

    # Read session ID from meta.json
    local META_FILE="$AGENT_DIR/meta.json"
    if [[ ! -f "$META_FILE" ]]; then
        echo "Error: meta.json not found for agent '$ID'" >&2
        exit 1
    fi

    local SESSION_UUID=$(jq -r '.session_id // ""' "$META_FILE" 2>/dev/null)
    if [[ -z "$SESSION_UUID" || "$SESSION_UUID" == "null" ]]; then
        echo "Error: no session_id found in meta.json" >&2
        echo "This agent was created before resume support was added." >&2
        exit 1
    fi

    # Read model from meta.json if set
    local MODEL=$(jq -r '.model // ""' "$META_FILE" 2>/dev/null)
    if [[ "$MODEL" == "null" ]]; then
        MODEL=""
    fi

    # Determine working directory
    local WORK_PATH="$AGENT_DIR/repo"
    if [[ ! -d "$WORK_PATH" ]]; then
        # No worktree, use git root
        WORK_PATH="$(pwd)"
    fi

    # Read yolo mode from original start.sh to preserve settings
    local YOLO_MODE=false
    if [[ -f "$AGENT_DIR/start.sh" ]] && grep -q "dangerously-skip-permissions" "$AGENT_DIR/start.sh"; then
        YOLO_MODE=true
    fi

    # Build claude args for resume
    # Note: We don't use --permission-mode dontAsk because we want the
    # PermissionRequest hook to fire for non-allowed tools (to log and deny)
    local CLAUDE_ARGS=""
    if [[ "$YOLO_MODE" == true ]]; then
        CLAUDE_ARGS="--dangerously-skip-permissions --permission-mode bypassPermissions"
    fi
    if [[ -n "$MODEL" ]]; then
        CLAUDE_ARGS="$CLAUDE_ARGS --model $MODEL"
    fi

    # Get git root for PATH
    local GIT_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"

    # Write a resume script
    local RESUME_SCRIPT="$AGENT_DIR/resume.sh"
    local ABS_AGENT_DIR="$(cd "$AGENT_DIR" && pwd)"
    local ABS_EXIT_SCRIPT="$ABS_AGENT_DIR/exit-check.sh"
    cat > "$RESUME_SCRIPT" <<EOF
#!/bin/bash
# Add git repo root to PATH so 'ib' is available
export PATH="$GIT_ROOT:\$PATH"

# Start Claude in background and capture PID
claude --resume "$SESSION_UUID" $CLAUDE_ARGS &
CLAUDE_PID=\$!

# Store PID in meta.json for recovery if needed
if command -v jq &>/dev/null; then
    TMP_FILE="\$(mktemp)"
    jq --arg pid "\$CLAUDE_PID" '. + {claude_pid: \$pid}' "$ABS_AGENT_DIR/meta.json" > "\$TMP_FILE" && mv "\$TMP_FILE" "$ABS_AGENT_DIR/meta.json"
fi

# Wait for Claude to complete
wait \$CLAUDE_PID

# Run exit check
$ABS_EXIT_SCRIPT
EOF
    chmod +x "$RESUME_SCRIPT"

    # Ensure tmux server is running
    if ! tmux start-server 2>/dev/null; then
        echo "Error: could not start tmux server" >&2
        exit 1
    fi

    # Start tmux session with resume script
    local ABS_RESUME_SCRIPT="$(cd "$AGENT_DIR" && pwd)/resume.sh"
    local TMUX_SESSION=$(session_name "$ID")
    if ! tmux new-session -d -x "$TMUX_WIDTH" -s "$TMUX_SESSION" -c "$WORK_PATH" "$ABS_RESUME_SCRIPT"; then
        echo "Error: could not create tmux session '$TMUX_SESSION'" >&2
        exit 1
    fi

    # For non-yolo mode, auto-accept the workspace trust dialog
    if [[ "$YOLO_MODE" != true ]]; then
        auto_accept_workspace_trust "$TMUX_SESSION"
    fi

    # Log and print the resume
    log_agent "$ID" "Agent resumed"
    echo "Use 'ib look $ID' to view output"
}

# =============================================================================
# COMMAND: merge
# =============================================================================

cmd_merge() {
    local ID=""
    local TARGET_BRANCH=""
    local FORCE=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --into)    TARGET_BRANCH="$2"; shift 2 ;;
            --force)   FORCE=true; shift ;;
            -h|--help)
                cat <<EOF
Usage: ib merge <id> [options]

Merge an agent's work and close the agent.
Removes the agent's session, worktree, branch, and data directory.

When run by an agent (manager merging worker), merges into current branch.
When run from root repo, merges into main/master.

Arguments:
  id              Agent identifier

Options:
  --into BRANCH   Target branch to merge into (default: current branch if agent, main/master if root)
  --force         Don't ask for confirmation
  -h, --help      Show this help

The merge command:
1. Checks for uncommitted changes in the agent's worktree
2. Merges the agent's branch into target
3. Kills the agent's Claude process and tmux session
4. Cleans up the worktree, branch, and agent data

Examples:
  ib merge task-a1b2
  ib merge task-a1b2 --into develop
  ib merge task-a1b2 --force
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$ID" ]]; then
                    ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib merge <id> [options]" >&2
        exit 1
    fi

    # Resolve partial ID
    ID=$(resolve_agent_id "$ID") || exit 1

    local AGENT_DIR="$AGENTS_DIR/$ID"
    local BRANCH_NAME="agent/$ID"
    local TMUX_SESSION=$(session_name "$ID")

    # Check if agent exists
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo "Error: agent '$ID' not found" >&2
        exit 1
    fi

    # Load config and warn about PR settings
    load_config
    if [[ "$CONFIG_CREATE_PRS" == "true" ]]; then
        if ! command -v gh &>/dev/null; then
            echo "Warning: createPullRequests is enabled but 'gh' CLI is not installed" >&2
        fi
        if [[ -z $(git remote 2>/dev/null | head -1) ]]; then
            echo "Warning: createPullRequests is enabled but no git remote is configured" >&2
        fi
    fi

    # Check if worktree exists
    local WORKTREE_PATH="$AGENT_DIR/repo"
    if [[ ! -d "$WORKTREE_PATH" ]]; then
        echo "Error: agent '$ID' has no worktree (was created with --no-worktree?)" >&2
        exit 1
    fi

    # Check for uncommitted changes in the worktree
    if [[ -n $(git -C "$WORKTREE_PATH" status --porcelain 2>/dev/null) ]]; then
        echo "Error: agent '$ID' has uncommitted changes:" >&2
        git -C "$WORKTREE_PATH" status --short >&2
        echo "" >&2
        echo "Please commit or discard changes first, or use 'ib send $ID' to ask the agent to commit." >&2
        exit 1
    fi

    # Determine target branch
    if [[ -z "$TARGET_BRANCH" ]]; then
        # If running as an agent, merge into current branch (manager's branch)
        # This allows work to bubble up through the agent tree
        if is_running_as_agent; then
            TARGET_BRANCH=$(git branch --show-current)
            if [[ -z "$TARGET_BRANCH" ]]; then
                echo "Error: could not determine current branch" >&2
                exit 1
            fi
        else
            # Running from root repo - try main, then master
            if git show-ref --verify --quiet refs/heads/main; then
                TARGET_BRANCH="main"
            elif git show-ref --verify --quiet refs/heads/master; then
                TARGET_BRANCH="master"
            else
                echo "Error: could not determine target branch (no main or master found)" >&2
                echo "Use --into BRANCH to specify target branch" >&2
                exit 1
            fi
        fi
    fi

    # Check if agent branch exists
    if ! git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
        echo "Error: branch '$BRANCH_NAME' does not exist" >&2
        exit 1
    fi

    # Show what will be merged
    local commit_count=$(git log "$TARGET_BRANCH..$BRANCH_NAME" --oneline 2>/dev/null | wc -l | tr -d ' ')
    if [[ "$commit_count" -eq 0 ]]; then
        echo "Nothing to merge: $BRANCH_NAME has no new commits relative to $TARGET_BRANCH"
        echo "Proceeding with cleanup..."
    else
        echo "Will merge $commit_count commit(s) from $BRANCH_NAME into $TARGET_BRANCH:"
        git log "$TARGET_BRANCH..$BRANCH_NAME" --oneline
        echo ""
    fi

    # Confirm if not forced
    if [[ "$FORCE" != true && "$commit_count" -gt 0 ]]; then
        # If running as an agent, error instead of blocking on interactive prompt
        if is_running_as_agent; then
            echo "Error: Cannot use interactive confirmation in agent mode." >&2
            echo "Use: ib merge $ID --force" >&2
            exit 1
        fi
        local confirm
        read -p "Proceed with merge? [y/N] " confirm
        if [[ "$confirm" != [yY] && "$confirm" != [yY][eE][sS] ]]; then
            echo "Cancelled."
            exit 0
        fi
    fi

    # Log the start of merge
    log_agent "$ID" "Starting merge of $BRANCH_NAME into $TARGET_BRANCH ($commit_count commits)"

    # Perform the merge FIRST (before killing anything)
    # This ensures we don't leave agents in limbo if merge fails
    if [[ "$commit_count" -gt 0 ]]; then
        log_agent "$ID" "Checking out $TARGET_BRANCH..."
        local checkout_error
        checkout_error=$(git checkout "$TARGET_BRANCH" 2>&1) || {
            echo "Error: could not checkout $TARGET_BRANCH" >&2
            echo "$checkout_error" >&2
            log_agent "$ID" "ERROR: Failed to checkout $TARGET_BRANCH - $checkout_error"
            if [[ "$checkout_error" == *"already used by worktree"* ]]; then
                echo "Hint: Branch is checked out in another worktree. Try merging from the root repo." >&2
                log_agent "$ID" "HINT: Branch is checked out elsewhere - merge from root repo or use --into"
            fi
            exit 1
        }
        log_agent "$ID" "Merging $BRANCH_NAME..."
        local merge_error
        merge_error=$(git merge "$BRANCH_NAME" -m "Merge agent $ID work" 2>&1) || {
            echo "Error: merge failed" >&2
            echo "$merge_error" >&2
            log_agent "$ID" "ERROR: Merge failed - $merge_error"
            if [[ "$merge_error" == *"CONFLICT"* ]]; then
                echo "Hint: Resolve conflicts manually, then run: git add . && git commit" >&2
                log_agent "$ID" "HINT: Merge conflicts detected - resolve manually"
            fi
            exit 1
        }
        log_agent "$ID" "Merge completed successfully"
    fi

    # Capture tmux output BEFORE killing session (so archive has it)
    log_agent "$ID" "Capturing tmux output..."
    if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        tmux capture-pane -t "$TMUX_SESSION" -p -S - > "$AGENT_DIR/output.log" 2>/dev/null || true
    fi

    # Kill Claude process gracefully before killing tmux session
    log_agent "$ID" "Terminating Claude process..."
    if kill_agent_process "$ID"; then
        log_agent "$ID" "Claude process terminated"
    else
        log_agent "$ID" "No Claude process found (already stopped?)"
    fi

    # Kill the agent session if still running
    log_agent "$ID" "Stopping tmux session..."
    if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        tmux kill-session -t "$TMUX_SESSION"
        log_agent "$ID" "Tmux session stopped"
    else
        log_agent "$ID" "No tmux session found (already stopped?)"
    fi

    # Cleanup worktree
    log_agent "$ID" "Removing worktree..."
    git worktree remove "$WORKTREE_PATH" --force 2>/dev/null || {
        log_agent "$ID" "Warning: could not remove worktree cleanly, removing directory manually"
        rm -rf "$WORKTREE_PATH"
    }
    log_agent "$ID" "Worktree removed"

    # Delete the branch
    log_agent "$ID" "Deleting branch $BRANCH_NAME..."
    if git branch -D "$BRANCH_NAME" 2>/dev/null; then
        log_agent "$ID" "Branch deleted: $BRANCH_NAME"
    else
        log_agent "$ID" "Warning: could not delete branch $BRANCH_NAME"
    fi

    # Final log before archive (this is the last log that will be captured)
    log_agent "$ID" "Merge complete - archiving and closing agent"

    # Archive output (captures complete log including the message above)
    archive_agent_output "$ID"

    # Remove agent directory last (no more logging possible after this)
    rm -rf "$AGENT_DIR"

    echo "Closed agent: $ID"

    # Scan for any orphaned Claude processes after cleanup
    scan_and_kill_orphans
}

# =============================================================================
# COMMAND: hook-status
# =============================================================================

cmd_hook_status() {
    local ID="$1"

    if [[ -z "$ID" ]]; then
        echo "Error: agent ID required" >&2
        exit 1
    fi

    # Resolve partial ID
    local RESOLVED_ID
    if ! RESOLVED_ID=$(resolve_agent_id "$ID" 2>&1); then
        echo "[hook] Resolution failed for '$ID': $RESOLVED_ID" >&2
        exit 1
    fi
    ID="$RESOLVED_ID"

    local state=$(get_state "$ID")
    log_agent "$ID" "[hook] Stop hook triggered, state=$state" --quiet

    local TMUX_SESSION=$(session_name "$ID")

    # Get agent's manager (if any) for worker notifications
    local AGENT_DIR="$AGENTS_DIR/$ID"
    local manager=""
    if [[ -f "$AGENT_DIR/meta.json" ]]; then
        manager=$(jq -r '.manager // ""' "$AGENT_DIR/meta.json" 2>/dev/null)
        [[ "$manager" == "null" ]] && manager=""
    fi

    if [[ "$state" == "unknown" ]]; then
        log_agent "$ID" "[hook] State unknown, sending nudge prompt" --quiet
        local prompt="When you stop working, you must always end your message with either 'WAITING' or 'I HAVE COMPLETED THE GOAL'. If you are waiting for input or have nothing more to do without further instruction, say 'WAITING'. If you have completed your goal, say 'I HAVE COMPLETED THE GOAL'. If you have neither completed your goal nor are waiting, then please resume your work."

        tmux send-keys -t "$TMUX_SESSION" "$prompt"
        sleep 0.1
        tmux send-keys -t "$TMUX_SESSION" Enter
    elif [[ "$state" == "complete" ]]; then
        # For workers: notify manager immediately
        if [[ -n "$manager" ]]; then
            log_agent "$ID" "[hook] Notifying manager $manager: just completed"
            ib send "$manager" "[hook]: Your subtask $ID just completed"
        else
            # For managers: check for unfinished children
            local unfinished=$(get_unfinished_children "$ID")
            if [[ -n "$unfinished" ]]; then
                local child_count=$(echo "$unfinished" | wc -w | tr -d ' ')
                local child_list=$(echo "$unfinished" | tr ' ' ', ')
                log_agent "$ID" "[hook] Complete but has $child_count unfinished children ($child_list), sending reminder" --quiet
                local prompt="You have $child_count unfinished sub-agent(s) that need attention: $child_list. Before you can complete, you must merge or kill each sub-agent using 'ib merge <id>' or 'ib kill <id>'. Use 'ib list' to check their status, 'ib look <id>' to see their output, 'ib status <id>' for their commits, and 'ib diff <id>' to review their changes."

                tmux send-keys -t "$TMUX_SESSION" "$prompt"
                sleep 0.1
                tmux send-keys -t "$TMUX_SESSION" Enter
            else
                log_agent "$ID" "[hook] Complete with no manager and no unfinished children, no action" --quiet
            fi
        fi
    elif [[ "$state" == "waiting" ]]; then
        # For workers: notify manager immediately
        if [[ -n "$manager" ]]; then
            log_agent "$ID" "[hook] Notifying manager $manager: now waiting"
            ib send "$manager" "[hook]: Your subtask $ID is now waiting for input"
        else
            log_agent "$ID" "[hook] Waiting with no manager, no action" --quiet
        fi
    else
        # State is running, stopped, or other - no action needed
        log_agent "$ID" "[hook] State is $state, no action needed" --quiet
    fi

    # Always print the state for debugging
    echo "$state"
}

# =============================================================================
# COMMAND: log
# =============================================================================

cmd_log() {
    local AGENT_ID=""
    local MESSAGE=""
    local QUIET=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --id)
                AGENT_ID="$2"
                shift 2
                ;;
            --quiet|-q)
                QUIET="--quiet"
                shift
                ;;
            -h|--help)
                cat <<EOF
Usage: ib log [--id <agent-id>] [--quiet] "message"

Write a timestamped message to the agent's log file and echo to stdout.

The agent ID is auto-detected when run from an agent worktree.
Log file location: .ittybitty/agents/<id>/agent.log

Options:
  --id ID     Specify agent ID (auto-detected in agent worktrees)
  --quiet,-q  Write to log file only, don't echo to stdout
  -h, --help  Show this help

Examples:
  ib log "Starting task analysis"
  ib log "Found 5 files to process"
  ib log --id my-agent "External log entry"
  ib log --quiet "Silent log entry"
EOF
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                MESSAGE="$1"
                shift
                ;;
        esac
    done

    # Auto-detect agent ID if not specified
    if [[ -z "$AGENT_ID" ]]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" == *"/.ittybitty/agents/"*"/repo"* ]]; then
            # Extract agent ID from path
            local agent_dir=$(echo "$current_dir" | sed 's|\(.*/.ittybitty/agents/[^/]*\)/repo.*|\1|')
            if [[ -f "$agent_dir/meta.json" ]]; then
                AGENT_ID=$(jq -r '.id // ""' "$agent_dir/meta.json" 2>/dev/null)
            fi
        elif [[ "$current_dir" == *"/.ittybitty/agents/"*"/repo"* ]]; then
            # Legacy path format
            local agent_dir=$(echo "$current_dir" | sed 's|\(.*/.ittybitty/agents/[^/]*\)/repo.*|\1|')
            if [[ -f "$agent_dir/meta.json" ]]; then
                AGENT_ID=$(jq -r '.id // ""' "$agent_dir/meta.json" 2>/dev/null)
            fi
        fi
    fi

    if [[ -z "$AGENT_ID" ]]; then
        echo "Error: Could not detect agent ID. Run from an agent worktree or use --id." >&2
        exit 1
    fi

    if [[ -z "$MESSAGE" ]]; then
        echo "Error: Message required" >&2
        echo "Usage: ib log \"message\"" >&2
        exit 1
    fi

    # Resolve partial ID if needed
    AGENT_ID=$(resolve_agent_id "$AGENT_ID") || exit 1

    # Use the log_agent helper
    log_agent "$AGENT_ID" "$MESSAGE" "$QUIET"
}

cmd_watchdog() {
    local AGENT_ID=""
    local QUIET=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --quiet)
                QUIET=true
                shift
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                if [[ -z "$AGENT_ID" ]]; then
                    AGENT_ID="$1"
                else
                    echo "Unknown argument: $1" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    # Validate argument
    if [[ -z "$AGENT_ID" ]]; then
        echo "Error: agent ID required" >&2
        echo "Usage: ib watchdog <agent-id> [--quiet]" >&2
        exit 1
    fi

    # Resolve partial ID
    AGENT_ID=$(resolve_agent_id "$AGENT_ID") || exit 1

    # Get agent directory
    local AGENT_DIR="$AGENTS_DIR/$AGENT_ID"
    if [[ ! -d "$AGENT_DIR" ]]; then
        echo "Error: Agent $AGENT_ID not found" >&2
        exit 1
    fi

    # Load manager from meta.json
    local manager=$(jq -r '.manager // ""' "$AGENT_DIR/meta.json" 2>/dev/null)

    # Check if agent has a manager (skip check in quiet mode)
    if [[ "$QUIET" != "true" ]]; then
        if [[ -z "$manager" || "$manager" == "null" ]]; then
            echo "Agent $AGENT_ID has no manager, exiting" >&2
            echo "Hint: Use --quiet to monitor agents without managers" >&2
            exit 1
        fi
    else
        # In quiet mode, set manager to "none" if it doesn't exist
        if [[ -z "$manager" || "$manager" == "null" ]]; then
            manager="(none)"
        fi
    fi

    # Set up Ctrl+C trap for clean exit
    trap 'echo ""; echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] Stopped monitoring $AGENT_ID"; log_agent "$AGENT_ID" "[watchdog] Stopped monitoring" --quiet; exit 0' INT

    echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] Monitoring agent $AGENT_ID (manager: $manager)"
    log_agent "$AGENT_ID" "[watchdog] Started monitoring (manager: $manager)" --quiet

    # Initialize counters and flags
    local waiting_counter=0
    local notified_complete=false
    local notify_interval=6  # Start at 30 seconds (6 * 5s), doubles after each notification
    local max_notify_interval=768  # Cap at 64 minutes (768 * 5s = 3840s)
    local prev_state=""

    # Main monitoring loop - runs while agent's worktree exists
    while [[ -d "$AGENT_DIR/repo" ]]; do
        state=$(get_state "$AGENT_ID")

        case "$state" in
            waiting)
                waiting_counter=$((waiting_counter + 1))

                # Only log state change or when counter increments (to show progress)
                if [[ "$prev_state" != "waiting" ]]; then
                    echo "[watchdog] Agent state: waiting (counter: $waiting_counter, next notify at: $notify_interval)"
                    log_agent "$AGENT_ID" "[watchdog] State changed to: waiting" --quiet
                    log_tmux_screen "$AGENT_ID"
                fi

                # Check if we've reached the notification threshold
                if [[ $waiting_counter -ge $notify_interval ]]; then
                    local wait_time=$((notify_interval * 5))
                    echo "[watchdog] THRESHOLD REACHED: Agent has been waiting for ${wait_time}+ seconds"
                    if [[ "$QUIET" == "true" ]]; then
                        echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] QUIET MODE: Would notify manager $manager: agent recently started waiting"
                    else
                        echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] Notifying manager $manager: agent recently started waiting"
                        log_agent "$AGENT_ID" "[watchdog] Notified manager $manager: recently waiting" --quiet
                        ib send "$manager" "[watchdog]: Your subtask $AGENT_ID recently started waiting for input"
                    fi

                    # Reset counter and double the interval (exponential backoff: 30s, 1m, 2m, 4m, 8m, 16m, 32m, 64m)
                    waiting_counter=0
                    notify_interval=$((notify_interval * 2))

                    # Cap at max interval (64 minutes)
                    if [[ $notify_interval -gt $max_notify_interval ]]; then
                        notify_interval=$max_notify_interval
                    fi

                    local next_seconds=$((notify_interval * 5))
                    echo "[watchdog] Next notification in ${next_seconds} seconds"
                    log_agent "$AGENT_ID" "[watchdog] Backoff increased: next notify in ${next_seconds}s" --quiet
                fi
                ;;

            complete)
                waiting_counter=0
                notify_interval=6  # Reset to initial interval when completing
                if [[ "$notified_complete" != "true" ]]; then
                    echo "[watchdog] Agent state: complete"
                    log_agent "$AGENT_ID" "[watchdog] State changed to: complete" --quiet
                    log_tmux_screen "$AGENT_ID"
                    if [[ "$QUIET" == "true" ]]; then
                        echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] QUIET MODE: Would notify manager $manager: agent recently completed"
                    else
                        echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] Notifying manager $manager: agent recently completed"
                        log_agent "$AGENT_ID" "[watchdog] Notified manager $manager: recently completed" --quiet
                        ib send "$manager" "[watchdog]: Your subtask $AGENT_ID recently completed"
                    fi
                    notified_complete=true
                fi
                # No logging if already notified - silence
                ;;

            running)
                # Only log on state change or if clearing flags
                if [[ "$prev_state" != "running" ]]; then
                    if [[ $waiting_counter -gt 0 ]]; then
                        echo "[watchdog] Agent state: running (reset waiting counter and interval)"
                    else
                        echo "[watchdog] Agent state: running"
                    fi
                    log_agent "$AGENT_ID" "[watchdog] State changed to: running" --quiet
                    log_tmux_screen "$AGENT_ID"
                fi
                waiting_counter=0
                notify_interval=6  # Reset to initial interval when resuming work

                # If agent resumed from complete, allow re-notification
                if [[ "$notified_complete" == "true" ]]; then
                    echo "[watchdog] Agent resumed from complete - clearing completion flag"
                    log_agent "$AGENT_ID" "[watchdog] Resumed from complete" --quiet
                    notified_complete=false
                fi
                ;;

            unknown)
                # Treat unknown like waiting - agent may need attention
                waiting_counter=$((waiting_counter + 1))

                # Only log state change
                if [[ "$prev_state" != "unknown" ]]; then
                    echo "[watchdog] Agent state: unknown (counter: $waiting_counter, next notify at: $notify_interval)"
                    log_agent "$AGENT_ID" "[watchdog] State changed to: unknown" --quiet
                    log_tmux_screen "$AGENT_ID"
                fi

                # Check if we've reached the notification threshold
                if [[ $waiting_counter -ge $notify_interval ]]; then
                    local wait_time=$((notify_interval * 5))
                    echo "[watchdog] THRESHOLD REACHED: Agent state unknown for ${wait_time}+ seconds"
                    if [[ "$QUIET" == "true" ]]; then
                        echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] QUIET MODE: Would notify manager $manager: agent state is unknown"
                    else
                        echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] Notifying manager $manager: agent state is unknown"
                        log_agent "$AGENT_ID" "[watchdog] Notified manager $manager: state unknown" --quiet
                        ib send "$manager" "[watchdog]: Your subtask $AGENT_ID state is unknown - may need attention"
                    fi

                    # Reset counter and double the interval (exponential backoff)
                    waiting_counter=0
                    notify_interval=$((notify_interval * 2))

                    # Cap at max interval (64 minutes)
                    if [[ $notify_interval -gt $max_notify_interval ]]; then
                        notify_interval=$max_notify_interval
                    fi

                    local next_seconds=$((notify_interval * 5))
                    echo "[watchdog] Next notification in ${next_seconds} seconds"
                    log_agent "$AGENT_ID" "[watchdog] Backoff increased: next notify in ${next_seconds}s" --quiet
                fi
                ;;

            stopped)
                # Only log on state change
                if [[ "$prev_state" != "stopped" ]]; then
                    if [[ $waiting_counter -gt 0 ]]; then
                        echo "[watchdog] Agent state: stopped (reset waiting counter and interval)"
                    else
                        echo "[watchdog] Agent state: stopped"
                    fi
                    log_agent "$AGENT_ID" "[watchdog] State changed to: stopped" --quiet
                    # Note: log_tmux_screen won't capture anything since session is stopped
                    log_tmux_screen "$AGENT_ID"
                fi
                waiting_counter=0
                notify_interval=6  # Reset to initial interval
                ;;
        esac

        prev_state="$state"
        sleep 5
    done

    # Agent killed/merged - worktree gone
    echo "$(date +"%Y-%m-%d %H:%M:%S"): [watchdog] Agent $AGENT_ID worktree removed, exiting"
    log_agent "$AGENT_ID" "[watchdog] Exiting (agent worktree removed)" --quiet
}

# =============================================================================
# COMMAND: tree
# =============================================================================

cmd_tree() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib tree

Show all agents in a tree structure displaying manager-worker relationships.

This makes it easy to see the hierarchy of agents and which agents spawned
which sub-agents.

Examples:
  ib tree
EOF
                exit 0
                ;;
            *)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
        esac
    done

    # Check if agents directory exists
    if [[ ! -d "$AGENTS_DIR" ]]; then
        echo "No agents found."
        exit 0
    fi

    # Build agent data using shared helper
    local tmpfile=$(build_agent_data_file)
    trap "rm -f '$tmpfile'" EXIT

    if [[ ! -s "$tmpfile" ]]; then
        echo "No agents found."
        exit 0
    fi

    # Build and display tree using shared helper
    build_tree_lines "$tmpfile" | column -t -s '|'
}

# =============================================================================
# COMMAND: watch (undocumented)
# =============================================================================

cmd_watch() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat <<EOF
Usage: ib watch

Full-screen dashboard for monitoring all agents.

Controls:
  j/k     Select next/previous agent
  ;/l     Scroll panes down/up
  Ctrl-C  Exit

The display shows:
  - Agent tree (top 5 lines, scrolls with selection)
  - Selected agent info (model, prompt)
  - Split view: tmux output (left) and agent log (right)

EOF
                exit 0
                ;;
            *)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
        esac
    done

    # State variables
    local TERM_LINES TERM_COLS
    local SELECTED_INDEX=0
    local PREV_SELECTED_INDEX=-1  # Track for scroll reset on agent change
    local AGENT_COUNT=0
    local TREE_SCROLL=0  # Which line of tree to start display from
    local SCROLL_OFFSET=0  # Shared scroll offset for both panes (0 = bottom/autoscroll)

    # Cleanup function for exit
    watch_cleanup() {
        stty echo    # Restore terminal echo
        tput cnorm   # Show cursor
        tput clear   # Clear screen
        echo "Exited ib watch"
    }

    # Trap Ctrl-C and other exits
    trap watch_cleanup EXIT

    # Hide cursor and disable terminal echo
    tput civis
    stty -echo

    # Main render function
    watch_render() {
        # Get terminal size
        TERM_LINES=$(tput lines)
        TERM_COLS=$(tput cols)

        # Move cursor to top-left (no flicker vs clear)
        tput cup 0 0

        # Build agent data
        local tmpfile=$(build_agent_data_file)

        if [[ ! -s "$tmpfile" ]]; then
            # No agents - show message
            AGENT_COUNT=0
            echo "No agents running."
            echo ""
            echo "Waiting for agents... (Ctrl-C to exit)"

            # Clear rest of screen
            local line
            for ((line=3; line<TERM_LINES; line++)); do
                printf "%-${TERM_COLS}s\n" ""
            done

            rm -f "$tmpfile"
            return
        fi

        # Get agent IDs in tree order (for selection tracking)
        local agent_ids=()
        while IFS= read -r line; do
            [[ -n "$line" ]] && agent_ids+=("$line")
        done < <(get_agent_ids_tree_order "$tmpfile")
        AGENT_COUNT=${#agent_ids[@]}

        # Clamp selection to valid range
        if [[ $SELECTED_INDEX -ge $AGENT_COUNT ]]; then
            SELECTED_INDEX=$((AGENT_COUNT - 1))
        fi
        if [[ $SELECTED_INDEX -lt 0 ]]; then
            SELECTED_INDEX=0
        fi

        # Get the selected agent ID and its data from tmpfile
        local selected_id="${agent_ids[$SELECTED_INDEX]}"
        local selected_info
        selected_info=$(grep "^${selected_id}|" "$tmpfile" | head -1)
        local selected_state=$(echo "$selected_info" | cut -d'|' -f3)
        local selected_model=$(echo "$selected_info" | cut -d'|' -f5)
        local selected_prompt=$(echo "$selected_info" | cut -d'|' -f6-)

        # Get tree lines
        local tree_lines=()
        while IFS= read -r line; do
            tree_lines+=("$line")
        done < <(build_tree_lines "$tmpfile" | column -t -s '|')
        local total_tree_lines=${#tree_lines[@]}

        # Calculate tree scroll to keep selection visible (window of 5)
        if [[ $SELECTED_INDEX -lt $TREE_SCROLL ]]; then
            TREE_SCROLL=$SELECTED_INDEX
        elif [[ $SELECTED_INDEX -ge $((TREE_SCROLL + 5)) ]]; then
            TREE_SCROLL=$((SELECTED_INDEX - 4))
        fi

        # Display 5 lines of tree with selection highlighting
        local display_line
        for ((display_line=0; display_line<5; display_line++)); do
            local tree_idx=$((TREE_SCROLL + display_line))
            if [[ $tree_idx -lt $total_tree_lines ]]; then
                local line="${tree_lines[$tree_idx]}"
                if [[ $tree_idx -eq $SELECTED_INDEX ]]; then
                    # Highlight selected line with reverse video
                    printf "\e[7m%-${TERM_COLS}.${TERM_COLS}s\e[0m\n" "$line"
                else
                    printf "%-${TERM_COLS}.${TERM_COLS}s\n" "$line"
                fi
            else
                printf "%-${TERM_COLS}s\n" ""
            fi
        done

        # Prompt display (agent ID/state/model already shown in tree)
        local prompt_max=$((TERM_COLS - 8))
        local display_prompt="$selected_prompt"
        if [[ ${#display_prompt} -gt $prompt_max ]]; then
            display_prompt="${display_prompt:0:$((prompt_max - 3))}..."
        fi
        printf "%-${TERM_COLS}s\n" "Prompt: $display_prompt"

        # Calculate pane dimensions
        # Left pane uses TMUX_WIDTH, right pane gets the rest
        local pane_height=$((TERM_LINES - 8))
        local left_pane_width=$TMUX_WIDTH
        local right_pane_width=$((TERM_COLS - TMUX_WIDTH - 3))  # -3 for " │ " separator

        # Pane headers (use same separator as content for alignment)
        local left_header="── TMUX OUTPUT "
        local right_header="── AGENT LOG "
        # Pad headers with ─ to fill width
        while [[ ${#left_header} -lt $left_pane_width ]]; do
            left_header="${left_header}─"
        done
        while [[ ${#right_header} -lt $right_pane_width ]]; do
            right_header="${right_header}─"
        done
        printf "%s │ %s\n" "$left_header" "$right_header"

        # Reset scroll offset when agent changes
        if [[ $SELECTED_INDEX -ne $PREV_SELECTED_INDEX ]]; then
            SCROLL_OFFSET=0
            PREV_SELECTED_INDEX=$SELECTED_INDEX
        fi

        # ===== PHASE 1: COLLECT & PROCESS DATA =====

        # Capture more lines for scrolling (up to 500 lines of history)
        local capture_lines=500

        # Get tmux output for selected agent (all lines, for total count)
        local tmux_session
        tmux_session=$(session_name "$selected_id")
        local all_tmux_lines=()
        if tmux has-session -t "$tmux_session" 2>/dev/null; then
            while IFS= read -r line; do
                all_tmux_lines+=("$line")
            done < <(tmux capture-pane -t "$tmux_session" -p -S -"$capture_lines" 2>/dev/null)
        else
            local output_file="$AGENTS_DIR/$selected_id/output.log"
            if [[ -f "$output_file" ]]; then
                while IFS= read -r line; do
                    all_tmux_lines+=("$line")
                done < <(tail -n "$capture_lines" "$output_file" 2>/dev/null)
            fi
        fi

        # Get agent log and wrap it (all lines, for total count)
        local all_log_lines=()
        local log_raw_count=0
        local log_file="$AGENTS_DIR/$selected_id/agent.log"
        if [[ -f "$log_file" ]]; then
            while IFS= read -r raw_line; do
                ((log_raw_count++))
                while IFS= read -r wrapped_line; do
                    all_log_lines+=("$wrapped_line")
                done < <(printf '%s\n' "$raw_line" | fold -w "$right_pane_width")
            done < <(tail -n "$capture_lines" "$log_file" 2>/dev/null)
        fi

        local tmux_total=${#all_tmux_lines[@]}
        local log_total=${#all_log_lines[@]}

        # Calculate and clamp scroll offset
        local tmux_max_scroll=$((tmux_total - pane_height))
        local log_max_scroll=$((log_total - pane_height))
        [[ $tmux_max_scroll -lt 0 ]] && tmux_max_scroll=0
        [[ $log_max_scroll -lt 0 ]] && log_max_scroll=0
        local max_scroll=$tmux_max_scroll
        [[ $log_max_scroll -lt $max_scroll ]] && max_scroll=$log_max_scroll
        [[ $SCROLL_OFFSET -gt $max_scroll ]] && SCROLL_OFFSET=$max_scroll
        [[ $SCROLL_OFFSET -lt 0 ]] && SCROLL_OFFSET=0

        # Extract visible window of tmux lines (strip ANSI, truncate to width)
        local visible_tmux_lines=()
        local pane_line
        for ((pane_line=0; pane_line<pane_height; pane_line++)); do
            local tmux_idx=$((tmux_total - pane_height + pane_line - SCROLL_OFFSET))
            if [[ $tmux_idx -ge 0 && $tmux_idx -lt $tmux_total ]]; then
                # Strip ANSI and truncate in one pipeline
                local processed
                processed=$(printf '%s' "${all_tmux_lines[$tmux_idx]}" | sed 's/\x1b\[[0-9;]*m//g' | cut -c1-"$left_pane_width")
                visible_tmux_lines+=("$processed")
            else
                visible_tmux_lines+=("")
            fi
        done

        # Extract visible window of log lines (already wrapped, just slice)
        local visible_log_lines=()
        for ((pane_line=0; pane_line<pane_height; pane_line++)); do
            local log_idx=$((log_total - pane_height + pane_line - SCROLL_OFFSET))
            if [[ $log_idx -ge 0 && $log_idx -lt $log_total ]]; then
                visible_log_lines+=("${all_log_lines[$log_idx]}")
            else
                visible_log_lines+=("")
            fi
        done

        # ===== PHASE 2: RENDER (no processing, just print) =====

        local pane_start_row=8
        for ((pane_line=0; pane_line<pane_height; pane_line++)); do
            local row=$((pane_start_row + pane_line))
            printf '\e[%d;1H\e[K%s\e[%d;%dH │ %s' \
                "$row" "${visible_tmux_lines[$pane_line]}" \
                "$row" "$((left_pane_width + 1))" \
                "${visible_log_lines[$pane_line]}"
        done

        # Move cursor to line after panes
        printf '\e[%d;1H' "$((pane_start_row + pane_height))"

        # Bottom help line with time on far right
        local help_text="j/k: select    ;/l: scroll    Ctrl-C: quit"
        [[ $SCROLL_OFFSET -gt 0 ]] && help_text="[+$SCROLL_OFFSET]  $help_text"
        local current_time
        current_time=$(date +%H:%M:%S)
        local right_info="q:${LAST_QUEUE_SIZE}  ${current_time}"
        local padding=$((TERM_COLS - ${#help_text} - ${#right_info}))
        printf "%s%*s%s" "$help_text" "$padding" "" "$right_info"

        rm -f "$tmpfile"
    }

    # Process a single key
    watch_process_key() {
        local key="$1"
        case "$key" in
            j)
                # Move selection down
                if [[ $AGENT_COUNT -gt 0 ]]; then
                    SELECTED_INDEX=$(( (SELECTED_INDEX + 1) % AGENT_COUNT ))
                fi
                ;;
            k)
                # Move selection up
                if [[ $AGENT_COUNT -gt 0 ]]; then
                    SELECTED_INDEX=$(( (SELECTED_INDEX - 1 + AGENT_COUNT) % AGENT_COUNT ))
                fi
                ;;
            \;)
                # Scroll down (show older content) - ; key
                SCROLL_OFFSET=$((SCROLL_OFFSET + 10))
                ;;
            l)
                # Scroll up (show newer content, toward bottom)
                SCROLL_OFFSET=$((SCROLL_OFFSET - 10))
                if [[ $SCROLL_OFFSET -lt 0 ]]; then
                    SCROLL_OFFSET=0
                fi
                ;;
        esac
    }

    # Start persistent background key reader
    local keyfile=$(mktemp)
    (
        exec < /dev/tty
        while true; do
            IFS= read -rsn1 k && printf "%s" "$k" >> "$keyfile"
        done
    ) &
    local reader_pid=$!

    # Cleanup reader on exit
    watch_cleanup_reader() {
        kill $reader_pid 2>/dev/null
        rm -f "$keyfile"
    }
    trap 'watch_cleanup_reader; watch_cleanup' EXIT

    # Main loop
    local LAST_QUEUE_SIZE=0

    while true; do
        # Render frame
        watch_render

        # Small delay for input collection
        sleep 0.02

        # Collect and clear accumulated keys
        local keys_to_process=""
        if [[ -s "$keyfile" ]]; then
            keys_to_process=$(cat "$keyfile")
            : > "$keyfile"  # Clear for next frame
        fi
        LAST_QUEUE_SIZE=${#keys_to_process}

        # Process all accumulated keys
        local i
        for ((i=0; i<${#keys_to_process}; i++)); do
            watch_process_key "${keys_to_process:$i:1}"
        done
    done
}

# =============================================================================
# MAIN DISPATCH
# =============================================================================

# Initialize paths to use root repo (handles running from worktrees)
init_paths

case "${1:-help}" in
    new-agent|new)
        shift
        cmd_new_agent "$@"
        ;;
    list|ls)
        shift
        cmd_list "$@"
        ;;
    tree)
        shift
        cmd_tree "$@"
        ;;
    watch)
        shift
        cmd_watch "$@"
        ;;
    status)
        shift
        cmd_status "$@"
        ;;
    diff)
        shift
        cmd_diff "$@"
        ;;
    merge)
        shift
        cmd_merge "$@"
        ;;
    send)
        shift
        cmd_send "$@"
        ;;
    look)
        shift
        cmd_look "$@"
        ;;
    kill)
        shift
        cmd_kill "$@"
        ;;
    nuke)
        shift
        cmd_nuke "$@"
        ;;
    resume)
        shift
        cmd_resume "$@"
        ;;
    hook-status)
        shift
        cmd_hook_status "$@"
        ;;
    log)
        shift
        cmd_log "$@"
        ;;
    watchdog)
        shift
        cmd_watchdog "$@"
        ;;
    help|--help|-h)
        SHOW_UNDOCUMENTED=false
        if [[ "$2" == "--undocumented" || "$2" == "-u" ]]; then
            SHOW_UNDOCUMENTED=true
        fi

        cat <<EOF
ib (ittybitty) - multi-agent orchestration for Claude Code

Usage: ib <command> [options]

Commands:
  new-agent   Start a new agent with a prompt
  list        Show all agents and their state
  tree        Show agents in a tree structure (manager-worker hierarchy)
  send        Send input to an agent
  look        Look at an agent's recent output
  status      Show git status of agent's work (commits, changes)
  diff        Show full diff of agent's work vs main
  merge       Merge agent's work into main branch and close the agent
  kill        Close an agent without merging
  resume      Restart a stopped agent's session
  watchdog    Monitor an agent and notify manager when it needs attention

Aliases:
  new         Alias for new-agent
  ls          Alias for list
EOF

        if [[ "$SHOW_UNDOCUMENTED" == true ]]; then
            cat <<EOF

Undocumented Commands:
  nuke        EMERGENCY STOP: Kill all agents, or a manager and all descendants
  hook-status Internal: Check agent state and nudge if unknown (used by hooks)
  log         Write timestamped message to agent's log file (auto-detects agent ID)

Undocumented Options:
  help --undocumented   Show this extended help (you found it!)
EOF
        fi

        cat <<EOF

Environment:
  ITTYBITTY_DIR    Base directory for all data (default: .ittybitty)
                   Contains: agents/, archive/

Configuration:
  .ittybitty.json   Configure agent permissions (see 'ib new-agent --help')

Run 'ib <command> --help' for command-specific help.

Examples:
  ib new-agent "verify all citations in docs/comparison.md"
  ib list
  ib tree
  ib look agent-abc123
  ib status agent-abc123
  ib diff agent-abc123
  ib send agent-abc123 "yes, proceed with option 2"
  ib watchdog agent-abc123
  ib merge agent-abc123
  ib kill agent-abc123
  ib resume agent-abc123
EOF
        ;;
    *)
        echo "Unknown command: $1" >&2
        echo "Run 'ib help' for usage." >&2
        exit 1
        ;;
esac
